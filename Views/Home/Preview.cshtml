@model ExcelToPdfConverter.Models.PreviewModel

@{
    ViewData["Title"] = "Preview - " + Model.OriginalFileName;
}

@Html.AntiForgeryToken()

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

<div class="container-fluid px-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center py-4 mb-4 border-bottom">
        <div>
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb mb-2">
                    <li class="breadcrumb-item"><a href="@Url.Action("Index")" class="text-decoration-none">Home</a></li>
                    <li class="breadcrumb-item active">Preview</li>
                </ol>
            </nav>
            <h1 class="h3 mb-1 text-gradient">File Preview</h1>
            <p class="text-muted mb-0">Review and select sheets for PDF conversion</p>
        </div>
        <div class="d-flex gap-2">
            <a href="@Url.Action("Index")" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back
            </a>
            <!-- New Merge PDF Button -->
            <button type="button" id="mergePdfBtn" class="btn btn-info px-4">
                <i class="fas fa-file-pdf me-2"></i>Merge PDF Files
            </button>
            <button type="button" id="pdfPreviewBtn" class="btn btn-primary px-4">
                <i class="fas fa-eye me-2"></i>PDF Preview Manager
            </button>
            <button id="convertBtn" class="btn btn-success px-4">
                <i class="fas fa-file-pdf me-2"></i>Convert & Download
            </button>
        </div>
    </div>

    <!-- PDF Upload Section (Initially hidden) -->
    <div id="pdfUploadSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-info text-white">
            <h5 class="mb-0">
                <i class="fas fa-file-upload me-2"></i>Upload PDF Files for Merging
            </h5>
        </div>
        <div class="card-body">
            <div class="alert alert-info border-0">
                <i class="fas fa-info-circle me-2"></i>
                Upload PDF files to merge with your converted Excel sheets. You can upload multiple files at once.
            </div>

            <!-- File Upload Area -->
            <div class="file-upload-area border-dashed rounded-3 p-4 text-center mb-3" id="pdfFileUploadArea">
                <i class="fas fa-file-pdf text-info mb-3" style="font-size: 3rem;"></i>
                <h5 class="mb-3">Drag & Drop your PDF files here</h5>
                <p class="text-muted mb-3">or click to browse multiple files</p>

                <div class="mb-3">
                    <input type="file" class="form-control d-none" name="PdfFiles" id="PdfFiles"
                           accept=".pdf" multiple>
                    <label for="PdfFiles" class="btn btn-info btn-lg px-4" id="pdfFileLabel">
                        <i class="fas fa-folder-open me-2"></i>Choose PDF Files
                    </label>
                </div>

                <div id="pdfFileNames" class="text-muted small mt-2"></div>
                <div class="form-text">Supported format: .pdf • Maximum file size: 50MB per file</div>
            </div>

            <!-- Uploaded Files List -->
            <div id="uploadedFilesList" class="mt-3" style="display: none;">
                <h6 class="mb-3">Uploaded Files:</h6>
                <div id="uploadedFilesContainer" class="list-group"></div>
            </div>

            <!-- Action Buttons -->
            <div class="d-flex gap-2 mt-4">
                <button type="button" id="cancelUploadBtn" class="btn btn-outline-secondary flex-grow-1">
                    <i class="fas fa-times me-2"></i>Cancel
                </button>
                <button type="button" id="addMorePdfsBtn" class="btn btn-primary flex-grow-1">
                    <i class="fas fa-plus me-2"></i>Add More PDFs
                </button>
                <button type="button" id="mergeUploadedPdfsBtn" class="btn btn-success flex-grow-1">
                    <i class="fas fa-merge me-2"></i>Merge Uploaded PDFs
                </button>
            </div>
        </div>
    </div>

    <!-- Merged PDF Files List (Initially hidden) -->
    <div id="mergedPdfSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-success text-white">
            <h5 class="mb-0">
                <i class="fas fa-check-circle me-2"></i>Merged PDF Files
            </h5>
        </div>
        <div class="card-body">
            <div id="mergedPdfList" class="list-group">
                <!-- Merged PDF files will appear here -->
            </div>
        </div>
    </div>

    <!-- PDF Preview Modal -->
    <div class="modal fade" id="pdfPreviewModal" tabindex="-1" aria-labelledby="pdfPreviewModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title" id="pdfPreviewModalLabel">
                        <i class="fas fa-file-pdf me-2"></i>PDF Page Manager
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge bg-light text-dark me-2">
                            <span id="pageCountBadge">0</span> pages
                        </span>
                        <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="modal-body p-0 d-flex" style="height: calc(100vh - 120px);">
                    <!-- PDF Preview Area -->
                    <div class="flex-grow-1 d-flex flex-column" style="width: 60%; background-color: #525659;">
                        <div id="pdfPreviewContainer" class="flex-grow-1 d-flex justify-content-center align-items-center">
                            <div class="text-center">
                                <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                <h5 class="mb-2 text-white">PDF Preview Area</h5>
                                <p class="text-light mb-0">Preview will appear here</p>
                            </div>
                        </div>
                        <div class="border-top bg-dark text-white p-2" style="display: none;" id="pageInfoBar">
                            <div class="row align-items-center">
                                <div class="col-md-8">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-info-circle me-2"></i>
                                        <small>
                                            Page <span id="currentPageDisplay">1</span> of <span id="totalPagesDisplay2">0</span> •
                                            Orientation: <span id="orientationDisplay">Portrait</span> •
                                            Rotation: <span id="rotationDisplay">0°</span>
                                        </small>
                                    </div>
                                </div>
                                <div class="col-md-4 text-end">
                                    <div class="btn-group btn-group-sm">
                                        <button type="button" class="btn btn-outline-light" id="quickPrevPage">
                                            <i class="fas fa-chevron-left"></i>
                                        </button>
                                        <button type="button" class="btn btn-outline-light" id="quickNextPage">
                                            <i class="fas fa-chevron-right"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Controls Sidebar -->
                    <div class="controls-sidebar border-start" style="width: 40%; background: #ffffff; overflow-y: auto;">
                        <div id="pdfControls" style="display: none;">
                            <!-- Page Controls -->
                            <div class="p-3 border-bottom bg-light">
                                <h6 class="mb-3">
                                    <i class="fas fa-cogs me-2"></i>Page Controls
                                </h6>
                                <div class="row g-3">
                                    <div class="col-8">
                                        <div class="d-flex align-items-center">
                                            <button id="prevPage" class="btn btn-outline-primary btn-sm me-2">
                                                <i class="fas fa-chevron-left"></i> Prev
                                            </button>
                                            <div class="input-group input-group-sm flex-grow-1 me-2">
                                                <input type="number" id="pageNumInput" class="form-control text-center" min="1" value="1">
                                                <span class="input-group-text">/ <span id="page_count">1</span></span>
                                            </div>
                                            <button id="nextPage" class="btn btn-outline-primary btn-sm">
                                                Next <i class="fas fa-chevron-right"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="col-4 text-end">
                                        <div class="text-muted small">Page</div>
                                        <div class="fw-bold" id="currentPageInfo">1</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Orientation & Rotation Controls -->
                            <div class="p-3 border-bottom">
                                <h6 class="mb-3">
                                    <i class="fas fa-compress-alt me-2"></i>Page Orientation & Rotation
                                </h6>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Set orientation for current page • Content will rotate with page
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-success orientation-btn active flex-grow-1"
                                            data-orientation="portrait">
                                        <i class="fas fa-portrait me-1"></i>Portrait
                                    </button>
                                    <button type="button" class="btn btn-outline-warning orientation-btn flex-grow-1"
                                            data-orientation="landscape">
                                        <i class="fas fa-landscape me-1"></i>Landscape
                                    </button>
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-warning rotate-btn flex-grow-1" data-rotation="-90">
                                        <i class="fas fa-undo me-1"></i>Rotate Left
                                    </button>
                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="90">
                                        <i class="fas fa-redo me-1"></i>Rotate Right
                                    </button>
                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="180">
                                        <i class="fas fa-sync-alt me-1"></i>Flip
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary rotate-btn flex-grow-1" id="resetRotation">
                                        <i class="fas fa-history me-1"></i>Reset
                                    </button>
                                </div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllPortrait">
                                        <i class="fas fa-copy me-1"></i>Apply Portrait to All
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllLandscape">
                                        <i class="fas fa-copy me-1"></i>Apply Landscape to All
                                    </button>
                                </div>
                            </div>

                            <!-- Page Thumbnails -->
                            <div class="p-3">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0">
                                        <i class="fas fa-images me-2"></i>Page Thumbnails
                                        <small class="text-muted">(Drag to reorder)</small>
                                    </h6>
                                    <div>
                                        <span class="badge bg-primary" id="visiblePagesCount">0</span>
                                    </div>
                                </div>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Drag thumbnails to reorder pages • Click × to remove pages
                                </div>
                                <div id="thumbnailContainer" class="row g-2 mb-3" style="max-height: 400px; overflow-y: auto;"></div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="showAllPages">
                                        <i class="fas fa-eye me-1"></i>Show All
                                    </button>
                                    <button type="button" class="btn btn-outline-danger btn-sm flex-grow-1" id="removeAllPages">
                                        <i class="fas fa-trash me-1"></i>Remove All
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <div class="w-100 d-flex justify-content-between align-items-center">
                        <div class="text-muted small">
                            <div class="d-flex gap-3">
                                <span>
                                    <i class="fas fa-copy me-1"></i>
                                    Total Pages: <span id="totalPagesCount">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-eye me-1"></i>
                                    Visible: <span id="visiblePagesDisplay">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-compress-alt me-1"></i>
                                    <span id="orientationSummary">Portrait: 0, Landscape: 0</span>
                                </span>
                            </div>
                        </div>
                        <div class="d-flex">
                            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">
                                <i class="fas fa-times me-1"></i>Close
                            </button>
                            <button type="button" id="downloadFinalPdfBtn" class="btn btn-success">
                                <i class="fas fa-download me-1"></i>Download PDF
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Cards -->
    <div class="row g-4 mb-4">
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-primary mb-3">
                        <i class="fas fa-layer-group fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.FileSelections.Count</h3>
                    <p class="text-muted mb-0">Total Sheets</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-danger mb-3">
                        <i class="fas fa-exclamation-triangle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllNameErrors.Count</h3>
                    <p class="text-muted mb-0">#NAME? Errors</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-calendar-check fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllInvoiceDates.Count</h3>
                    <p class="text-muted mb-0">Invoice Dates</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-check-circle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1" id="selectedSheetsCount">0</h3>
                    <p class="text-muted mb-0">Sheets Selected</p>
                </div>
            </div>
        </div>
    </div>


    <!-- Separate Error Sections -->
    @if (Model.HasNameErrors)
    {
        <div class="card border-0 shadow-sm mb-4">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0">
                    <i class="fas fa-exclamation-triangle me-2"></i>#NAME? Errors Found
                </h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Sheet Name</th>
                                <th>Location</th>
                                <th>Cell Reference</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var error in Model.AllNameErrors)
                            {
                                <tr>
                                    <td><strong>@error.SheetName</strong></td>
                                    <td>@error.FullLocation</td>
                                    <td><code>@error.Location</code></td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }

    @if (Model.HasInvoiceDates)
    {
        <div class="card border-0 shadow-sm mb-4">
            <div class="card-header  bg-danger text-white">
                <h5 class="mb-0">
                    <i class="fas fa-calendar-check me-2"></i>Invoice Dates Found (@Model.AllInvoiceDates.Count)
                </h5>
            </div>
            <div class="card-body">
                <div class="alert alert-info">
                    <strong>Debug Info:</strong> Found @Model.AllInvoiceDates.Count invoice dates across all sheets.
                </div>
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>#</th>
                                <th>Sheet Name</th>
                                <th>Invoice Date Text</th>
                                <th>Date Value</th>
                                <th>Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            @{
                                int counter = 1;
                            }
                            @foreach (var invoiceDate in Model.AllInvoiceDates)
                            {
                                <tr>
                                    <td>@(counter++)</td>
                                    <td><strong>@invoiceDate.SheetName</strong></td>
                                    <td><code>@invoiceDate.InvoiceDateText</code></td>
                                    <td><strong class="text-danger">@invoiceDate.DateValue</strong></td>
                                    <td><code>@invoiceDate.Location</code></td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }
    else
    {
        <div class="alert alert-warning">
            <strong>No Invoice Dates Found:</strong> The system did not find any invoice dates in the Excel file.
            Console showed: Credit Note (1), Tax Invoice (1), AOC (1), working sheet (1)
        </div>
    }

    <!-- Sheet Selection -->
    <div class="card border-0 shadow-sm">
        <div class="card-header bg-white py-3 border-bottom">
            <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="fas fa-list-check text-primary me-2"></i>Sheet Selection & Ordering
                </h5>
                <div class="d-flex align-items-center gap-2">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="selectAll" checked>
                        <label class="form-check-label small fw-bold" for="selectAll">
                            Select All
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-hover mb-0" id="sheetSelectionTable">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 60px;" class="text-center ps-4">#</th>
                            <th style="width: 60px;" class="text-center">Select</th>
                            <th>Sheet Name</th>
                            <th style="width: 120px;" class="text-center">#NAME? Errors</th>
                            <th style="width: 120px;" class="text-center">Invoice Dates</th>
                        </tr>
                    </thead>
                    <tbody id="sortable">
                        @foreach (var file in Model.FileSelections.OrderBy(f => f.SortOrder))
                        {
                            <tr data-sheet="@file.SheetName" data-order="@file.SortOrder" class="sortable-row">
                                <td class="text-center align-middle ps-4">
                                    <div class="d-flex align-items-center justify-content-center">
                                        <div class="drag-handle me-2" style="cursor: grab;">
                                            <i class="fas fa-grip-vertical text-muted"></i>
                                        </div>
                                        <span class="order-badge badge bg-primary rounded-pill">@(file.SortOrder + 1)</span>
                                    </div>
                                </td>
                                <td class="text-center align-middle">
                                    <input type="checkbox" name="selectedSheets" value="@file.SheetName"
                                    @(file.IsSelected ? "checked" : "")
                                           class="sheet-checkbox form-check-input">
                                </td>
                                <td class="align-middle">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-table text-muted me-2"></i>
                                        <strong>@file.SheetName</strong>
                                    </div>
                                </td>
                                <td class="text-center align-middle">
                                    @if (file.HasNameErrors)
                                    {
                                        <span class="badge bg-danger rounded-pill">
                                            @file.NameErrors.Count
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="badge bg-success rounded-pill">0</span>
                                    }
                                </td>
                                <td class="text-center align-middle">
                                    @if (file.HasInvoiceDates)
                                    {
                                        <span class="badge bg-success rounded-pill">
                                            @file.InvoiceDates.Count
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="badge bg-secondary rounded-pill">0</span>
                                    }
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sessionId = '@Model.SessionId';
            const convertBtn = document.getElementById('convertBtn');
            const selectAllCheckbox = document.getElementById('selectAll');
            const sheetCheckboxes = document.querySelectorAll('.sheet-checkbox');
            const selectedSheetsCount = document.getElementById('selectedSheetsCount');

            // PDF Preview Variables
            const pdfPreviewBtn = document.getElementById('pdfPreviewBtn');
            const pdfPreviewModal = new bootstrap.Modal(document.getElementById('pdfPreviewModal'));
            const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
            const pdfControls = document.getElementById('pdfControls');
            const downloadFinalPdfBtn = document.getElementById('downloadFinalPdfBtn');
            const pageNumInput = document.getElementById('pageNumInput');
            const pageCountSpan = document.getElementById('page_count');
            const currentPageInfo = document.getElementById('currentPageInfo');
            const totalPagesCount = document.getElementById('totalPagesCount');
            const totalPagesDisplay2 = document.getElementById('totalPagesDisplay2');
            const currentPageDisplay = document.getElementById('currentPageDisplay');
            const orientationDisplay = document.getElementById('orientationDisplay');
            const rotationDisplay = document.getElementById('rotationDisplay');
            const pageCountBadge = document.getElementById('pageCountBadge');
            const visiblePagesCount = document.getElementById('visiblePagesCount');
            const visiblePagesDisplay = document.getElementById('visiblePagesDisplay');
            const pageInfoBar = document.getElementById('pageInfoBar');
            const thumbnailContainer = document.getElementById('thumbnailContainer');
            const showAllPages = document.getElementById('showAllPages');
            const removeAllPages = document.getElementById('removeAllPages');
            const quickPrevPage = document.getElementById('quickPrevPage');
            const quickNextPage = document.getElementById('quickNextPage');
            const prevPage = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            const applyToAllPortrait = document.getElementById('applyToAllPortrait');
            const applyToAllLandscape = document.getElementById('applyToAllLandscape');
            const orientationSummary = document.getElementById('orientationSummary');

            let pdfDoc = null;
            let pageNum = 1;
            let pageRendering = false;
            let pageNumPending = null;
            let currentOrientations = {};
            let currentRotations = {};
            let currentPdfUrl = null;
            let pageOrder = [];
            let thumbnailSortable = null;
            let pdfData = null;
            let pdfFileName = "";

            // PDF Upload Variables
            const mergePdfBtn = document.getElementById('mergePdfBtn');
            const pdfUploadSection = document.getElementById('pdfUploadSection');
            const pdfFileInput = document.getElementById('PdfFiles');
            const pdfFileUploadArea = document.getElementById('pdfFileUploadArea');
            const uploadedFilesContainer = document.getElementById('uploadedFilesContainer');
            const uploadedFilesList = document.getElementById('uploadedFilesList');
            const pdfFileNames = document.getElementById('pdfFileNames');
            const cancelUploadBtn = document.getElementById('cancelUploadBtn');
            const mergeUploadedPdfsBtn = document.getElementById('mergeUploadedPdfsBtn');
            const addMorePdfsBtn = document.getElementById('addMorePdfsBtn');
            const mergedPdfSection = document.getElementById('mergedPdfSection');
            const mergedPdfList = document.getElementById('mergedPdfList');

            let uploadedPdfs = [];
            let mergedPdfs = [];

            function validateBeforeConversion() {
                let hasNameErrors = @Json.Serialize(Model.HasNameErrors);
                let hasInvoiceDates = @Json.Serialize(Model.HasInvoiceDates);
                let allInvoiceDates = @Json.Serialize(Model.AllInvoiceDates);

                console.log("=== VALIDATION CHECK ===");
                console.log("- Has Name Errors:", hasNameErrors);
                console.log("- Has Invoice Dates:", hasInvoiceDates);
                console.log("- All Invoice Dates:", allInvoiceDates);

                // Check for #NAME? errors
                if (hasNameErrors) {
                    showValidationError("Please fix all #NAME? errors before converting to PDF.");
                    return false;
                }

                // Check for invoice date mismatches
                if (hasInvoiceDates && allInvoiceDates && allInvoiceDates.length > 0) {
                    let hasMismatch = checkInvoiceDateMismatches(allInvoiceDates);
                    if (hasMismatch) {
                        showValidationError("Please fix Invoice Date mismatches before converting to PDF.");
                        return false;
                    }
                }

                console.log("✅ Validation passed - no errors found");
                return true;
            }

            function checkInvoiceDateMismatches(invoiceDates) {
                console.log("Checking invoice date mismatches...");

                let hasMismatch = false;
                let parsedDates = [];

                invoiceDates.forEach(invoiceDate => {
                    if (invoiceDate.dateValue && invoiceDate.dateValue.trim() !== '') {
                        const parsedDate = parseDateString(invoiceDate.dateValue.trim());
                        if (parsedDate) {
                            parsedDates.push({
                                originalText: invoiceDate.dateValue.trim(),
                                parsedDate: parsedDate,
                                sheet: invoiceDate.sheetName,
                                location: invoiceDate.location
                            });
                        }
                    }
                });

                console.log("Parsed dates found:", parsedDates);

                if (parsedDates.length > 1) {
                    const firstParsedDate = parsedDates[0].parsedDate;

                    const allSame = parsedDates.every(item =>
                        item.parsedDate.getTime() === firstParsedDate.getTime()
                    );

                    if (!allSame) {
                        console.log("❌ Date mismatch found!");
                        hasMismatch = true;
                        showDateMismatchDetailsImproved(parsedDates);
                    } else {
                        console.log("✅ All invoice dates are same (different formats, same date)");
                    }
                } else if (parsedDates.length === 1) {
                    console.log("✅ Only one invoice date found - no mismatch possible");
                } else {
                    console.log("ℹ️ No invoice date values found");
                }

                return hasMismatch;
            }

            function parseDateString(dateString) {
                console.log(`Parsing date: "${dateString}"`);

                const dateFormats = [
                    /^([A-Za-z]+),\s*(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                    /^([A-Za-z]+),\s*([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                    /^(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                    /^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                    /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
                    /^(\d{1,2})-([A-Za-z]+)-(\d{4})$/i,
                    /^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i
                ];

                for (const format of dateFormats) {
                    const match = dateString.match(format);
                    if (match) {
                        console.log(`Matched format: ${format}`);

                        let day, month, year;

                        if (format === dateFormats[0]) {
                            day = parseInt(match[2]);
                            month = getMonthNumber(match[3]);
                            year = parseInt(match[4]);
                        } else if (format === dateFormats[1]) {
                            day = parseInt(match[3]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[4]);
                        } else if (format === dateFormats[2]) {
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[3]) {
                            day = parseInt(match[2]);
                            month = getMonthNumber(match[1]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[4]) {
                            year = parseInt(match[1]);
                            month = parseInt(match[2]);
                            day = parseInt(match[3]);
                        } else if (format === dateFormats[5]) {
                            const monthCandidate = parseInt(match[1]);
                            const dayCandidate = parseInt(match[2]);
                            year = parseInt(match[3]);

                            if (monthCandidate >= 1 && monthCandidate <= 12) {
                                month = monthCandidate;
                                day = dayCandidate;
                            } else {
                                month = dayCandidate;
                                day = monthCandidate;
                            }
                        } else if (format === dateFormats[6]) {
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[7]) {
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        }

                        if (month && day && year) {
                            const parsedDate = new Date(year, month - 1, day);
                            console.log(`Successfully parsed: ${parsedDate}`);
                            return parsedDate;
                        }
                    }
                }

                const parsed = Date.parse(dateString);
                if (!isNaN(parsed)) {
                    console.log(`Parsed using Date.parse: ${new Date(parsed)}`);
                    return new Date(parsed);
                }

                console.log(`❌ Could not parse date: "${dateString}"`);
                return null;
            }

            function getMonthNumber(monthName) {
                const months = {
                    'january': 1, 'jan': 1,
                    'february': 2, 'feb': 2,
                    'march': 3, 'mar': 3,
                    'april': 4, 'apr': 4,
                    'may': 5,
                    'june': 6, 'jun': 6,
                    'july': 7, 'jul': 7,
                    'august': 8, 'aug': 8,
                    'september': 9, 'sep': 9,
                    'october': 10, 'oct': 10,
                    'november': 11, 'nov': 11,
                    'december': 12, 'dec': 12
                };

                return months[monthName.toLowerCase()] || null;
            }

            function showDateMismatchDetailsImproved(parsedDates) {
                let dateGroups = {};

                parsedDates.forEach(item => {
                    const dateKey = item.parsedDate.toDateString();
                    if (!dateGroups[dateKey]) {
                        dateGroups[dateKey] = [];
                    }
                    dateGroups[dateKey].push({
                        sheet: item.sheet,
                        location: item.location,
                        originalText: item.originalText,
                        formattedDate: item.parsedDate.toLocaleDateString('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        })
                    });
                });

                console.log("Date Groups:", dateGroups);

                if (Object.keys(dateGroups).length > 1) {
                    let errorHTML = `
                        <div class="text-start">
                            <h5 class="text-danger mb-3">❌ Invoice Date Mismatch Found</h5>
                            <p class="mb-3">Different invoice dates found in sheets:</p>
                            <div class="alert alert-warning border-0">
                    `;

                    let groupCounter = 1;
                    for (const [dateKey, sheets] of Object.entries(dateGroups)) {
                        const dateObj = new Date(dateKey);
                        const formattedDate = dateObj.toLocaleDateString('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        });

                        errorHTML += `
                            <div class="mb-3">
                                <strong>Date Group ${groupCounter}: ${formattedDate}</strong>
                                <ul class="mb-0 mt-1">
                        `;

                        sheets.forEach(sheet => {
                            errorHTML += `
                                <li>
                                    <strong>${sheet.sheet}</strong>
                                    (${sheet.location}):
                                    <code>${sheet.originalText}</code>
                                </li>
                            `;
                        });

                        errorHTML += `
                                </ul>
                            </div>
                        `;
                        groupCounter++;
                    }

                    errorHTML += `
                            </div>
                            <p class="text-muted mt-3">
                                <i class="fas fa-info-circle me-1"></i>
                                All invoice dates must have the same date value (format can be different).
                            </p>
                        </div>
                    `;

                    Swal.fire({
                        icon: 'error',
                        title: 'Invoice Date Mismatch',
                        html: errorHTML,
                        confirmButtonText: 'OK',
                        confirmButtonColor: '#dc3545',
                        backdrop: true,
                        allowOutsideClick: false,
                        width: '800px'
                    });
                }
            }

            function showValidationError(message) {
                Swal.fire({
                    icon: 'error',
                    title: 'Validation Failed',
                    html: `
                        <div class="text-start">
                            <h5 class="text-danger mb-3">❌ Cannot Convert to PDF</h5>
                            <p class="mb-3">${message}</p>
                            <div class="alert alert-warning border-0">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                <strong>Please fix these issues:</strong>
                                <ul class="mb-0 mt-2">
                                    ${message.includes('#NAME?') ? '<li>Fix all #NAME? formula errors in Excel file</li>' : ''}
                                    ${message.includes('Invoice Date') ? '<li>Ensure all Invoice Dates have the same value</li>' : ''}
                                </ul>
                            </div>
                        </div>
                    `,
                    confirmButtonText: 'OK',
                    confirmButtonColor: '#dc3545',
                    backdrop: true,
                    allowOutsideClick: false
                });
            }

            // PDF Upload Functionality
            mergePdfBtn.addEventListener('click', function() {
                if (!validateBeforeConversion()) {
                    return;
                }
                pdfUploadSection.style.display = 'block';
                mergedPdfSection.style.display = 'block';
                this.style.display = 'none';
                updateMergedPdfList();
            });

            cancelUploadBtn.addEventListener('click', function() {
                pdfUploadSection.style.display = 'none';
                mergePdfBtn.style.display = 'block';
            });

            addMorePdfsBtn.addEventListener('click', function() {
                pdfFileInput.value = '';
                pdfFileInput.click();
            });

            // File input change
            pdfFileInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                handlePdfFiles(files);
            });

            // Drag and drop functionality
            pdfFileUploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                pdfFileUploadArea.classList.add('drag-over');
                pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
            });

            pdfFileUploadArea.addEventListener('dragenter', function(e) {
                e.preventDefault();
                e.stopPropagation();
                pdfFileUploadArea.classList.add('drag-over');
                pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
            });

            pdfFileUploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();

                const relatedTarget = e.relatedTarget;
                if (!pdfFileUploadArea.contains(relatedTarget)) {
                    pdfFileUploadArea.classList.remove('drag-over');
                    pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');
                }
            });

            pdfFileUploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();

                pdfFileUploadArea.classList.remove('drag-over');
                pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');

                const files = Array.from(e.dataTransfer.files).filter(file =>
                    file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                );

                if (files.length > 0) {
                    handlePdfFiles(files);
                } else {
                    showError('Please drop PDF files only.');
                }
            });

            // File upload area click
            pdfFileUploadArea.addEventListener('click', function(e) {
                if (e.target === pdfFileUploadArea || !e.target.closest('label')) {
                    pdfFileInput.click();
                }
            });

            function handlePdfFiles(files) {
                let validFiles = [];
                let invalidFiles = [];

                files.forEach(file => {
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        if (file.size <= 50 * 1024 * 1024) {
                            validFiles.push(file);
                        } else {
                            invalidFiles.push(`${file.name} (File too large)`);
                        }
                    } else {
                        invalidFiles.push(`${file.name} (Not a PDF)`);
                    }
                });

                if (invalidFiles.length > 0) {
                    showError(`Invalid files:\n${invalidFiles.join('\n')}`);
                }

                if (validFiles.length > 0) {
                    uploadPdfFiles(validFiles);
                }
            }

            // async function uploadPdfFiles(files) {
            //     const formData = new FormData();
            //     files.forEach(file => {
            //         formData.append('pdfFiles', file);
            //     });

            //     formData.append('sessionId', sessionId);

            //     try {
            //         const response = await fetch('@Url.Action("UploadPdfFiles", "Home")', {
            //             method: 'POST',
            //             body: formData,
            //             headers: {
            //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
            //             }
            //         });

            //         const result = await response.json();
            //         if (result.success) {
            //             uploadedPdfs = uploadedPdfs.concat(result.uploadedFiles);
            //             updateUploadedFilesList();
            //             showSuccess(`${files.length} PDF file(s) uploaded successfully`);
            //             pdfFileInput.value = '';
            //             mergeUploadedPdfsBtn.style.display = 'block';
            //         } else {
            //             showError(result.message);
            //         }
            //     } catch (error) {
            //         console.error('Error uploading PDF files:', error);
            //         showError('Error uploading files: ' + error.message);
            //     }
            // }

            // function updateUploadedFilesList() {
            //     uploadedFilesContainer.innerHTML = '';

            //     if (uploadedPdfs.length === 0) {
            //         uploadedFilesList.style.display = 'none';
            //         return;
            //     }

            //     uploadedFilesList.style.display = 'block';
            //     pdfFileNames.textContent = `${uploadedPdfs.length} PDF file(s) uploaded`;

            //     uploadedPdfs.forEach((pdf, index) => {
            //         const listItem = document.createElement('div');
            //         listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
            //         listItem.innerHTML = `
            //             <div class="d-flex align-items-center">
            //                 <i class="fas fa-file-pdf text-danger me-3 fs-5"></i>
            //                 <div>
            //                     <div class="fw-bold">${pdf.name}</div>
            //                     <small class="text-muted">${(pdf.size / 1024).toFixed(2)} KB</small>
            //                 </div>
            //             </div>
            //             <button type="button" class="btn btn-sm btn-outline-danger remove-pdf-btn" data-index="${index}">
            //                 <i class="fas fa-times"></i>
            //             </button>
            //         `;
            //         uploadedFilesContainer.appendChild(listItem);
            //     });

            //     document.querySelectorAll('.remove-pdf-btn').forEach(btn => {
            //         btn.addEventListener('click', function() {
            //             const index = parseInt(this.getAttribute('data-index'));
            //             removePdfFile(index);
            //         });
            //     });
            // }

            async function uploadPdfFiles(files) {
    const formData = new FormData();
    files.forEach(file => {
        formData.append('pdfFiles', file);
    });

    formData.append('sessionId', sessionId);

    try {
        const response = await fetch('@Url.Action("UploadPdfFiles", "Home")', {
            method: 'POST',
            body: formData,
            headers: {
                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
            }
        });

        const result = await response.json();
        if (result.success) {
            // Append new files to existing list - FIXED HERE
            if (result.uploadedFiles && result.uploadedFiles.length > 0) {
                result.uploadedFiles.forEach(file => {
                    uploadedPdfs.push({
                        name: file.name,
                        size: file.size,
                        uniqueName: file.uniqueName
                    });
                });
                updateUploadedFilesList();
                showSuccess(`${files.length} PDF file(s) uploaded successfully`);
            }
            
            pdfFileInput.value = '';
            mergeUploadedPdfsBtn.style.display = 'block';
        } else {
            showError(result.message);
        }
    } catch (error) {
        console.error('Error uploading PDF files:', error);
        showError('Error uploading files: ' + error.message);
    }
}

function updateUploadedFilesList() {
    uploadedFilesContainer.innerHTML = '';

    if (uploadedPdfs.length === 0) {
        uploadedFilesList.style.display = 'none';
        pdfFileNames.textContent = 'No files uploaded';
        return;
    }

    uploadedFilesList.style.display = 'block';
    pdfFileNames.textContent = `${uploadedPdfs.length} PDF file(s) uploaded`;

    uploadedPdfs.forEach((pdf, index) => {
        const listItem = document.createElement('div');
        listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
        listItem.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="fas fa-file-pdf text-danger me-3 fs-5"></i>
                <div>
                    <div class="fw-bold">${pdf.name}</div>
                    <small class="text-muted">${(pdf.size / 1024).toFixed(2)} KB</small>
                </div>
            </div>
            <button type="button" class="btn btn-sm btn-outline-danger remove-pdf-btn" data-index="${index}">
                <i class="fas fa-times"></i>
            </button>
        `;
        uploadedFilesContainer.appendChild(listItem);
    });

    document.querySelectorAll('.remove-pdf-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            removePdfFile(index);
        });
    });
}


            function removePdfFile(index) {
                if (index >= 0 && index < uploadedPdfs.length) {
                    fetch('@Url.Action("RemovePdfFile", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            fileName: uploadedPdfs[index].name
                        })
                    }).then(response => response.json())
                      .then(result => {
                          if (result.success) {
                              uploadedPdfs.splice(index, 1);
                              updateUploadedFilesList();
                              showSuccess('PDF file removed');
                          }
                      });
                }
            }

            mergeUploadedPdfsBtn.addEventListener('click', async function() {
                if (uploadedPdfs.length === 0) {
                    showError('Please upload PDF files first.');
                    return;
                }

                this.disabled = true;
                this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

                try {
                    const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        mergedPdfs.push({
                            name: result.fileName,
                            size: result.fileSize,
                            pages: result.totalPages,
                            timestamp: new Date().toLocaleString()
                        });

                        updateMergedPdfList();
                        showSuccess(`PDF files merged successfully (${result.totalPages} pages)`);

                        uploadedPdfs = [];
                        updateUploadedFilesList();
                        pdfUploadSection.style.display = 'none';
                        mergePdfBtn.style.display = 'block';
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error merging PDFs:', error);
                    showError('Error merging PDFs: ' + error.message);
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
                }
            });

            function updateMergedPdfList() {
                mergedPdfList.innerHTML = '';

                if (mergedPdfs.length === 0) {
                    mergedPdfSection.style.display = 'none';
                    return;
                }

                mergedPdfSection.style.display = 'block';

                mergedPdfs.forEach((pdf, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                    listItem.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-file-pdf text-success me-3 fs-5"></i>
                            <div>
                                <div class="fw-bold">${pdf.name}</div>
                                <div class="small text-muted">
                                    <span>${pdf.pages} pages • ${(pdf.size / 1024).toFixed(2)} KB</span>
                                    <br>
                                    <span>Created: ${pdf.timestamp}</span>
                                </div>
                            </div>
                        </div>
                        <div>
                            <button type="button" class="btn btn-sm btn-outline-primary download-merged-btn me-2" data-index="${index}">
                                <i class="fas fa-download"></i>
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-danger remove-merged-btn" data-index="${index}">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    `;
                    mergedPdfList.appendChild(listItem);
                });

                document.querySelectorAll('.download-merged-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const index = parseInt(this.getAttribute('data-index'));
                        downloadMergedPdf(index);
                    });
                });

                document.querySelectorAll('.remove-merged-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const index = parseInt(this.getAttribute('data-index'));
                        removeMergedPdf(index);
                    });
                });
            }

            async function downloadMergedPdf(index) {
                if (index >= 0 && index < mergedPdfs.length) {
                    try {
                        const response = await fetch('@Url.Action("DownloadMergedPdf", "Home")', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify({
                                sessionId: sessionId,
                                fileName: mergedPdfs[index].name
                            })
                        });

                        const result = await response.json();
                        if (result.success) {
                            const link = document.createElement('a');
                            link.href = 'data:application/pdf;base64,' + result.pdfData;
                            link.download = result.fileName;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        }
                    } catch (error) {
                        console.error('Error downloading merged PDF:', error);
                        showError('Error downloading PDF: ' + error.message);
                    }
                }
            }

            async function removeMergedPdf(index) {
                if (index >= 0 && index < mergedPdfs.length) {
                    try {
                        const response = await fetch('@Url.Action("RemoveMergedPdf", "Home")', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify({
                                sessionId: sessionId,
                                fileName: mergedPdfs[index].name
                            })
                        });

                        const result = await response.json();
                        if (result.success) {
                            mergedPdfs.splice(index, 1);
                            updateMergedPdfList();
                            showSuccess('Merged PDF removed');
                        }
                    } catch (error) {
                        console.error('Error removing merged PDF:', error);
                    }
                }
            }

            // pdfPreviewBtn.addEventListener('click', async function() {
            //     if (!validateBeforeConversion()) {
            //         return;
            //     }

            //     if (!sessionId) {
            //         showError('Session information not available.');
            //         return;
            //     }

            //     const selectedSheets = getSelectedSheets();
            //     if (selectedSheets.length === 0) {
            //         showError('Please select at least one sheet for PDF preview.');
            //         return;
            //     }

            //     pdfPreviewBtn.disabled = true;
            //     pdfPreviewBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating PDF...';

            //     try {
            //         const pageOrderData = [];

            //         if (pageOrder && pageOrder.length > 0) {
            //             pageOrder.forEach(p => {
            //                 pageOrderData.push({
            //                     OriginalPage: p.originalPage,
            //                     CurrentOrder: p.currentOrder,
            //                     Visible: p.visible,
            //                     Orientation: p.orientation || 'portrait',
            //                     Rotation: p.rotation || 0
            //                 });
            //             });
            //             console.log(`📊 Sending ${pageOrderData.length} pages to preview, visible: ${pageOrderData.filter(p => p.Visible).length}`);
            //         } else {
            //             console.log('ℹ️ No existing page order found');
            //         }

            //         const includeMergedPdfs = mergedPdfs && mergedPdfs.length > 0;

            //         const result = await generatePdfPreviewWithFitToPage(
            //             sessionId,
            //             selectedSheets,
            //             pageOrderData.length > 0 ? pageOrderData : null,
            //             includeMergedPdfs);

            //         if (result.success) {
            //             pdfData = result.pdfData;
            //             pdfFileName = result.fileName;

            //             pdfPreviewModal.show();
            //             await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName);
            //             showSuccess('PDF generated with FitToPage applied!');
            //         } else {
            //             showError(result.message || 'Failed to generate PDF preview.');
            //         }
            //     } catch (error) {
            //         console.error('Error generating PDF preview:', error);
            //         showError('Error generating PDF preview: ' + error.message);
            //     } finally {
            //         pdfPreviewBtn.disabled = false;
            //         pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager';
            //     }
            // });

            pdfPreviewBtn.addEventListener('click', async function() {
    if (!validateBeforeConversion()) {
        return;
    }

    if (!sessionId) {
        showError('Session information not available.');
        return;
    }

    const selectedSheets = getSelectedSheets();
    if (selectedSheets.length === 0) {
        showError('Please select at least one sheet for PDF preview.');
        return;
    }

    pdfPreviewBtn.disabled = true;
    pdfPreviewBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating PDF...';

    try {
        const pageOrderData = [];
        
        if (pageOrder && pageOrder.length > 0) {
            pageOrder.forEach(p => {
                pageOrderData.push({
                    OriginalPage: p.originalPage,
                    CurrentOrder: p.currentOrder,
                    Visible: p.visible,
                    Orientation: p.orientation || 'portrait',
                    Rotation: p.rotation || 0
                });
            });
        }

        // ALWAYS include merged PDFs if they exist
        const includeMergedPdfs = true; // Changed to always include
        
        const result = await generatePdfPreviewWithFitToPage(
            sessionId, 
            selectedSheets,
            pageOrderData.length > 0 ? pageOrderData : null,
            includeMergedPdfs);
            
        if (result.success) {
            pdfData = result.pdfData;
            pdfFileName = result.fileName;
            
            pdfPreviewModal.show();
            await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName);
            showSuccess('PDF generated with FitToPage applied!');
        } else {
            showError(result.message || 'Failed to generate PDF preview.');
        }
    } catch (error) {
        console.error('Error generating PDF preview:', error);
        showError('Error generating PDF preview: ' + error.message);
    } finally {
        pdfPreviewBtn.disabled = false;
        pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager';
    }
});


            async function generatePdfPreviewWithFitToPage(sessionId, selectedSheets, pageOrderData, includeMergedPdfs = false) {
                const formattedPageOrderData = pageOrderData
                    ? pageOrderData.map(p => ({
                        OriginalPage: p.originalPage || p.OriginalPage || 0,
                        CurrentOrder: p.currentOrder || p.CurrentOrder || 0,
                        Visible: p.visible !== undefined ? p.visible : (p.Visible !== undefined ? p.Visible : true),
                        Orientation: p.orientation || p.Orientation || 'portrait',
                        Rotation: p.rotation || p.Rotation || 0
                    }))
                    : null;

                const requestBody = {
                    sessionId: sessionId,
                    selectedSheets: selectedSheets,
                    includeMergedPdfs: includeMergedPdfs
                };

                if (formattedPageOrderData) {
                    requestBody.pageOrderData = formattedPageOrderData;
                }

                const response = await fetch('@Url.Action("GeneratePdfPreviewWithFitToPage", "Home")', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify(requestBody)
                });

                return await response.json();
            }

            async function displayPdfPreviewWithExistingSettings(pdfData, fileName) {
                console.log('📱 Loading PDF with existing page settings...');

                const byteCharacters = atob(pdfData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/pdf' });

                if (currentPdfUrl) {
                    URL.revokeObjectURL(currentPdfUrl);
                }
                currentPdfUrl = URL.createObjectURL(blob);

                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

                try {
                    const pdfDoc_ = await loadingTask.promise;
                    pdfDoc = pdfDoc_;
                    const totalPages = pdfDoc.numPages;

                    console.log(`📊 PDF loaded: ${totalPages} pages`);

                    pageOrder = [];
                    currentOrientations = {};
                    currentRotations = {};

                    for (let i = 1; i <= totalPages; i++) {
                        try {
                            const page = await pdfDoc.getPage(i);
                            const viewport = page.getViewport({ scale: 1.0 });
                            const isLandscape = viewport.width > viewport.height;

                            currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                            currentRotations[i] = 0;

                            pageOrder.push({
                                originalPage: i,
                                currentOrder: i,
                                orientation: isLandscape ? 'landscape' : 'portrait',
                                rotation: 0,
                                visible: true
                            });
                        } catch (error) {
                            console.error(`Error loading page ${i}:`, error);
                            pageOrder.push({
                                originalPage: i,
                                currentOrder: i,
                                orientation: 'portrait',
                                rotation: 0,
                                visible: true
                            });
                        }
                    }

                    console.log(`🆕 Initialized pageOrder with ${pageOrder.length} pages`);

                    pageCountSpan.textContent = totalPages;
                    totalPagesCount.textContent = totalPages;
                    totalPagesDisplay2.textContent = totalPages;
                    pageCountBadge.textContent = totalPages;
                    visiblePagesCount.textContent = totalPages;
                    visiblePagesDisplay.textContent = totalPages;
                    pageNumInput.max = totalPages;
                    pageNumInput.value = 1;
                    currentPageDisplay.textContent = '1';
                    currentPageInfo.textContent = '1';
                    rotationDisplay.textContent = '0°';

                    updateOrientationDisplay(1);
                    updateOrientationSummary();

                    pdfControls.style.display = 'block';
                    pageInfoBar.style.display = 'block';
                    downloadFinalPdfBtn.style.display = 'block';

                    pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                    pageNum = 1;
                    await renderPage(pageNum);

                    await createThumbnails();
                    initializeThumbnailSortable();

                } catch (error) {
                    console.error('Error loading PDF:', error);
                    pdfPreviewContainer.innerHTML = `
                        <div class="alert alert-danger m-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            Error loading PDF: ${error.message}
                        </div>
                    `;
                }
            }

            async function displayPdfPreview(pdfData, fileName) {
                pdfPreviewContainer.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x text-white mb-3"></i><p class="text-white">Loading PDF...</p></div>';
                thumbnailContainer.innerHTML = '';
                pageOrder = [];
                currentOrientations = {};
                currentRotations = {};

                const byteCharacters = atob(pdfData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/pdf' });

                if (currentPdfUrl) {
                    URL.revokeObjectURL(currentPdfUrl);
                }
                currentPdfUrl = URL.createObjectURL(blob);

                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

                try {
                    const pdfDoc_ = await loadingTask.promise;
                    pdfDoc = pdfDoc_;
                    const totalPages = pdfDoc.numPages;

                    pageOrder = [];
                    for (let i = 1; i <= totalPages; i++) {
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.0 });
                        const isLandscape = viewport.width > viewport.height;

                        currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                        currentRotations[i] = 0;

                        pageOrder.push({
                            originalPage: i,
                            currentOrder: i,
                            orientation: isLandscape ? 'landscape' : 'portrait',
                            rotation: 0,
                            visible: true
                        });
                    }

                    pageCountSpan.textContent = totalPages;
                    totalPagesCount.textContent = totalPages;
                    totalPagesDisplay2.textContent = totalPages;
                    pageCountBadge.textContent = totalPages;
                    visiblePagesCount.textContent = totalPages;
                    visiblePagesDisplay.textContent = totalPages;
                    pageNumInput.max = totalPages;
                    pageNumInput.value = 1;
                    currentPageDisplay.textContent = '1';
                    currentPageInfo.textContent = '1';
                    rotationDisplay.textContent = '0°';

                    updateOrientationDisplay(1);
                    updateOrientationSummary();

                    pdfControls.style.display = 'block';
                    pageInfoBar.style.display = 'block';
                    downloadFinalPdfBtn.style.display = 'block';

                    pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                    pageNum = 1;
                    await renderPage(pageNum);

                    await createThumbnails();
                    initializeThumbnailSortable();

                } catch (error) {
                    console.error('Error loading PDF:', error);
                    pdfPreviewContainer.innerHTML = `
                        <div class="alert alert-danger m-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            Error loading PDF: ${error.message}
                        </div>
                    `;
                }
            }

            async function renderPage(num) {
                pageRendering = true;

                const pageData = pageOrder.find(p => p.originalPage === num && p.visible);
                if (!pageData) {
                    const nextVisible = pageOrder.find(p => p.visible && p.originalPage > num);
                    if (nextVisible) {
                        pageNum = nextVisible.originalPage;
                        queueRenderPage(pageNum);
                        return;
                    }
                }

                try {
                    const page = await pdfDoc.getPage(num);
                    const viewport = page.getViewport({ scale: 1.0 });
                    const originalWidth = viewport.width;
                    const originalHeight = viewport.height;

                    const currentOrientation = currentOrientations[num] || 'portrait';
                    const currentRotation = currentRotations[num] || 0;

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    const containerWidth = pdfPreviewContainer.clientWidth - 100;
                    const containerHeight = pdfPreviewContainer.clientHeight - 100;

                    let baseScaleX = containerWidth / originalWidth;
                    let baseScaleY = containerHeight / originalHeight;
                    let baseScale = Math.min(baseScaleX, baseScaleY) * 0.9;

                    let renderWidth, renderHeight;

                    if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                        renderWidth = originalHeight * baseScale;
                        renderHeight = originalWidth * baseScale;
                    } else {
                        renderWidth = originalWidth * baseScale;
                        renderHeight = originalHeight * baseScale;
                    }

                    let finalScale = baseScale;

                    if (currentRotation !== 0) {
                        const rotatedWidth = Math.abs(renderWidth * Math.cos(currentRotation * Math.PI / 180)) +
                                          Math.abs(renderHeight * Math.sin(currentRotation * Math.PI / 180));
                        const rotatedHeight = Math.abs(renderWidth * Math.sin(currentRotation * Math.PI / 180)) +
                                           Math.abs(renderHeight * Math.cos(currentRotation * Math.PI / 180));

                        const rotatedScaleX = containerWidth / rotatedWidth;
                        const rotatedScaleY = containerHeight / rotatedHeight;
                        finalScale = Math.min(rotatedScaleX, rotatedScaleY) * 0.9;
                    }

                    if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                        renderWidth = originalHeight * finalScale;
                        renderHeight = originalWidth * finalScale;
                    } else {
                        renderWidth = originalWidth * finalScale;
                        renderHeight = originalHeight * finalScale;
                    }

                    let canvasWidth = renderWidth;
                    let canvasHeight = renderHeight;

                    if (currentRotation !== 0) {
                        const padding = 50;
                        canvasWidth = renderWidth + padding * 2;
                        canvasHeight = renderHeight + padding * 2;
                    }

                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;

                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(currentRotation * Math.PI / 180);
                    ctx.translate(-renderWidth / 2, -renderHeight / 2);

                    const renderContext = {
                        canvasContext: ctx,
                        viewport: page.getViewport({ scale: finalScale })
                    };

                    await page.render(renderContext).promise;
                    ctx.restore();

                    const container = document.getElementById('canvas-container');
                    container.innerHTML = '';

                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.style.position = 'relative';
                    wrapperDiv.style.border = '2px solid ' + (currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd');
                    wrapperDiv.style.borderRadius = '8px';
                    wrapperDiv.style.backgroundColor = 'white';
                    wrapperDiv.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
                    wrapperDiv.style.padding = '15px';
                    wrapperDiv.style.overflow = 'hidden';

                    const orientationLabel = document.createElement('div');
                    orientationLabel.className = 'page-info-label orientation-label';
                    orientationLabel.innerHTML = `<i class="fas ${currentOrientation === 'landscape' ? 'fa-landscape' : 'fa-portrait'}"></i> ${currentOrientation.toUpperCase()}`;
                    orientationLabel.style.position = 'absolute';
                    orientationLabel.style.top = '5px';
                    orientationLabel.style.right = '5px';
                    orientationLabel.style.backgroundColor = currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd';
                    orientationLabel.style.color = 'white';
                    orientationLabel.style.padding = '2px 8px';
                    orientationLabel.style.borderRadius = '4px';
                    orientationLabel.style.fontSize = '12px';
                    orientationLabel.style.zIndex = '100';
                    wrapperDiv.appendChild(orientationLabel);

                    if (currentRotation !== 0) {
                        const rotationLabel = document.createElement('div');
                        rotationLabel.className = 'page-info-label rotation-label';
                        rotationLabel.innerHTML = `<i class="fas fa-sync-alt"></i> ${currentRotation}°`;
                        rotationLabel.style.position = 'absolute';
                        rotationLabel.style.top = '5px';
                        rotationLabel.style.left = '5px';
                        rotationLabel.style.backgroundColor = '#dc3545';
                        rotationLabel.style.color = 'white';
                        rotationLabel.style.padding = '2px 8px';
                        rotationLabel.style.borderRadius = '4px';
                        rotationLabel.style.fontSize = '12px';
                        rotationLabel.style.zIndex = '100';
                        wrapperDiv.appendChild(rotationLabel);
                    }

                    const canvasContainer = document.createElement('div');
                    canvasContainer.style.width = '100%';
                    canvasContainer.style.height = '100%';
                    canvasContainer.style.display = 'flex';
                    canvasContainer.style.justifyContent = 'center';
                    canvasContainer.style.alignItems = 'center';
                    canvasContainer.style.overflow = 'hidden';

                    canvasContainer.appendChild(canvas);
                    wrapperDiv.appendChild(canvasContainer);
                    container.appendChild(wrapperDiv);

                    pageRendering = false;

                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }

                    const visiblePageNumber = pageOrder.filter(p => p.visible && p.originalPage <= num).length;
                    pageNumInput.value = visiblePageNumber;
                    currentPageDisplay.textContent = visiblePageNumber;
                    currentPageInfo.textContent = visiblePageNumber;
                    updateOrientationDisplay(num);
                    updateRotationDisplay(num);
                    updateUIControls(num);

                } catch (error) {
                    console.error('Error rendering page:', error);
                }
            }

            function queueRenderPage(num) {
                if (pageRendering) {
                    pageNumPending = num;
                } else {
                    renderPage(num);
                }
            }

            function updateOrientationDisplay(pageNum) {
                const orientation = currentOrientations[pageNum] || 'portrait';
                orientationDisplay.textContent = orientation === 'portrait' ? 'Portrait' : 'Landscape';
            }

            function updateRotationDisplay(pageNum) {
                const rotation = currentRotations[pageNum] || 0;
                rotationDisplay.textContent = rotation + '°';
            }

            function updateUIControls(pageNum) {
                document.querySelectorAll('.orientation-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.orientation === (currentOrientations[pageNum] || 'portrait')) {
                        btn.classList.add('active');
                    }
                });

                updateThumbnailRotationBadge(pageNum, currentRotations[pageNum] || 0);
            }

            async function createThumbnails() {
                thumbnailContainer.innerHTML = '';

                if (!pdfDoc) return;

                const visiblePages = pageOrder
                    .filter(page => page.visible)
                    .sort((a, b) => a.currentOrder - b.currentOrder);

                for (let i = 0; i < visiblePages.length; i++) {
                    const page = visiblePages[i];
                    const pageNum = page.originalPage;
                    await createThumbnailElement(pageNum, i, page.orientation, page.rotation);
                }

                updatePageStatistics();
            }

            async function createThumbnailElement(pageNum, index, orientation, rotation = 0) {
                const colDiv = document.createElement('div');
                colDiv.className = 'col-6 col-md-4';
                colDiv.setAttribute('data-page', pageNum);

                const thumbnailDiv = document.createElement('div');
                thumbnailDiv.className = 'thumbnail-item';
                thumbnailDiv.dataset.page = pageNum;
                thumbnailDiv.style.cssText = `
                    cursor: move;
                    border: 2px solid ${orientation === 'landscape' ? '#ffc107' : '#0d6efd'};
                    border-radius: 8px;
                    overflow: hidden;
                    background: white;
                    transition: all 0.2s ease;
                    margin-bottom: 10px;
                    height: 180px;
                    display: flex;
                    flex-direction: column;
                    position: relative;
                `;

                const orientationIcon = orientation === 'portrait' ? 'fa-portrait' : 'fa-landscape';
                const orientationColor = orientation === 'portrait' ? 'primary' : 'warning';

                thumbnailDiv.innerHTML = `
                    <div class="position-absolute top-0 end-0 p-1">
                        <button type="button" class="btn btn-sm btn-danger remove-page-btn"
                                data-page="${pageNum}"
                                title="Remove this page">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="position-absolute top-0 start-0 p-1">
                        <span class="badge bg-${orientationColor}">
                            <i class="fas ${orientationIcon}"></i>
                        </span>
                    </div>
                    <div class="thumbnail-canvas flex-grow-1 d-flex justify-content-center align-items-center p-2">
                        <div class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div class="thumbnail-label bg-light p-2 text-center border-top">
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">Page ${pageNum}</small>
                            <div>
                                <small class="badge bg-${orientationColor}">
                                    <i class="fas ${orientationIcon}"></i>
                                </small>
                                <small class="badge bg-info rotation-badge ms-1">${rotation}°</small>
                            </div>
                        </div>
                        <div class="mt-1">
                            <small class="text-primary">
                                <i class="fas fa-sort me-1"></i>Order: ${index + 1}
                            </small>
                        </div>
                    </div>
                `;

                thumbnailContainer.appendChild(colDiv);
                colDiv.appendChild(thumbnailDiv);

                await loadThumbnail(pageNum, thumbnailDiv.querySelector('.thumbnail-canvas'), rotation);

                thumbnailDiv.querySelector('.remove-page-btn').addEventListener('click', function(e) {
                    e.stopPropagation();
                    const pageToRemove = parseInt(this.getAttribute('data-page'));
                    removePage(pageToRemove);
                });

                thumbnailDiv.addEventListener('click', function(e) {
                    if (!e.target.closest('.remove-page-btn')) {
                        const pageNum = parseInt(this.dataset.page);
                        goToPage(pageNum);
                    }
                });
            }

            async function loadThumbnail(pageNum, canvasContainer, rotation = 0) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 0.15 });
                    const originalWidth = viewport.width;
                    const originalHeight = viewport.height;

                    const thumbnailSize = 100;

                    let scaleX = thumbnailSize / originalWidth;
                    let scaleY = thumbnailSize / originalHeight;
                    let scale = Math.min(scaleX, scaleY);

                    let canvasWidth = originalWidth * scale;
                    let canvasHeight = originalHeight * scale;

                    if (rotation === 90 || rotation === -90 || rotation === 270) {
                        const temp = canvasWidth;
                        canvasWidth = canvasHeight;
                        canvasHeight = temp;
                    }

                    const padding = 10;
                    const finalWidth = canvasWidth + padding * 2;
                    const finalHeight = canvasHeight + padding * 2;

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = finalWidth;
                    canvas.height = finalHeight;

                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.save();
                    ctx.translate(finalWidth / 2, finalHeight / 2);
                    ctx.rotate(rotation * Math.PI / 180);
                    ctx.translate(-canvasWidth / 2, -canvasHeight / 2);

                    const renderContext = {
                        canvasContext: ctx,
                        viewport: page.getViewport({ scale: scale })
                    };

                    await page.render(renderContext).promise;
                    ctx.restore();

                    canvasContainer.innerHTML = '';
                    canvasContainer.appendChild(canvas);

                } catch (error) {
                    console.error(`Error loading thumbnail for page ${pageNum}:`, error);
                    canvasContainer.innerHTML = '<div class="text-muted small">Error loading thumbnail</div>';
                }
            }

            function initializeThumbnailSortable() {
                if (thumbnailSortable) {
                    thumbnailSortable.destroy();
                }

                thumbnailSortable = new Sortable(thumbnailContainer, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'sortable-drag',
                    filter: '.remove-page-btn',
                    onStart: function(evt) {
                        evt.item.style.opacity = '0.8';
                    },
                    onEnd: function(evt) {
                        evt.item.style.opacity = '1';

                        const items = thumbnailContainer.querySelectorAll('[data-page]');
                        const newOrder = [];

                        items.forEach((item, index) => {
                            const pageNum = parseInt(item.getAttribute('data-page'));
                            const pageData = pageOrder.find(p => p.originalPage === pageNum);
                            if (pageData) {
                                pageData.currentOrder = index + 1;
                                newOrder.push(pageData);
                            }
                        });

                        pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);
                        updateThumbnailLabels();
                        updatePageStatistics();
                        showToast('Page order updated!');
                    }
                });
            }

            function updateThumbnailLabels() {
                const thumbnails = document.querySelectorAll('.thumbnail-item');
                thumbnails.forEach((thumb, index) => {
                    const label = thumb.querySelector('.text-primary small');
                    if (label) {
                        label.innerHTML = `<i class="fas fa-sort me-1"></i>Order: ${index + 1}`;
                    }
                });
            }

            function removePage(pageNum) {
                const pageIndex = pageOrder.findIndex(p => p.originalPage === pageNum);
                if (pageIndex !== -1) {
                    pageOrder[pageIndex].visible = false;
                    pageOrder[pageIndex].currentOrder = 9999;

                    if (pageNum === pageNum) {
                        const nextVisiblePage = pageOrder.find(p => p.visible);
                        if (nextVisiblePage) {
                            goToPage(nextVisiblePage.originalPage);
                        } else {
                            pdfPreviewContainer.innerHTML = `
                                <div class="text-center">
                                    <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                    <h5 class="mb-2 text-white">No pages to display</h5>
                                    <p class="text-light">All pages have been removed</p>
                                </div>
                            `;
                        }
                    }

                    createThumbnails();
                    updatePageStatistics();
                    showToast(`Page ${pageNum} removed from download list`);
                }
            }

            function goToPage(targetPage) {
                const pageData = pageOrder.find(p => p.originalPage === targetPage);
                if (pageData && pageData.visible) {
                    pageNum = targetPage;
                    queueRenderPage(pageNum);
                }
            }

            document.querySelectorAll('.orientation-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const orientation = this.dataset.orientation;
                    setCurrentPageOrientation(orientation);
                });
            });

            function setCurrentPageOrientation(orientation) {
                if (!pageNum) return;

                currentOrientations[pageNum] = orientation;

                const pageData = pageOrder.find(p => p.originalPage === pageNum);
                if (pageData) {
                    pageData.orientation = orientation;
                }

                updateOrientationDisplay(pageNum);

                document.querySelectorAll('.orientation-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.orientation === orientation) {
                        btn.classList.add('active');
                    }
                });

                queueRenderPage(pageNum);
                updateOrientationSummary();
                showToast(`Page ${pageNum} set to ${orientation}`);
            }

            applyToAllPortrait.addEventListener('click', function() {
                if (confirm('Apply Portrait orientation to all pages?')) {
                    pageOrder.forEach(page => {
                        if (page.visible) {
                            page.orientation = 'portrait';
                            currentOrientations[page.originalPage] = 'portrait';
                        }
                    });
                    createThumbnails();
                    updateOrientationSummary();
                    queueRenderPage(pageNum);
                    showToast('Portrait orientation applied to all pages');
                }
            });

            applyToAllLandscape.addEventListener('click', function() {
                if (confirm('Apply Landscape orientation to all pages?')) {
                    pageOrder.forEach(page => {
                        if (page.visible) {
                            page.orientation = 'landscape';
                            currentOrientations[page.originalPage] = 'landscape';
                        }
                    });
                    createThumbnails();
                    updateOrientationSummary();
                    queueRenderPage(pageNum);
                    showToast('Landscape orientation applied to all pages');
                }
            });

            function updateOrientationSummary() {
                let portraitCount = 0;
                let landscapeCount = 0;

                pageOrder.forEach(page => {
                    if (page.visible) {
                        if (page.orientation === 'portrait') {
                            portraitCount++;
                        } else {
                            landscapeCount++;
                        }
                    }
                });

                orientationSummary.textContent = `Portrait: ${portraitCount}, Landscape: ${landscapeCount}`;
            }

            document.querySelectorAll('.rotate-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (this.id === 'resetRotation') {
                        resetRotation();
                    } else {
                        const rotation = parseInt(this.dataset.rotation);
                        applyRotation(rotation);
                    }
                });
            });

            function applyRotation(rotation) {
                if (!pageNum) return;

                if (!currentRotations[pageNum]) {
                    currentRotations[pageNum] = 0;
                }

                currentRotations[pageNum] = (currentRotations[pageNum] + rotation) % 360;
                if (currentRotations[pageNum] < 0) {
                    currentRotations[pageNum] += 360;
                }

                const pageData = pageOrder.find(p => p.originalPage === pageNum);
                if (pageData) {
                    pageData.rotation = currentRotations[pageNum];
                }

                updateRotationDisplay(pageNum);
                queueRenderPage(pageNum);

                updateThumbnailRotationBadge(pageNum, currentRotations[pageNum]);

                showToast(`Page rotated to ${currentRotations[pageNum]}°`);
            }

            function resetRotation() {
                if (!pageNum) return;

                currentRotations[pageNum] = 0;
                const pageData = pageOrder.find(p => p.originalPage === pageNum);
                if (pageData) {
                    pageData.rotation = 0;
                }

                updateRotationDisplay(pageNum);
                queueRenderPage(pageNum);
                updateThumbnailRotationBadge(pageNum, 0);

                showToast('Rotation reset to 0°');
            }

            function updateThumbnailRotationBadge(pageNum, rotation) {
                const thumbnails = document.querySelectorAll(`[data-page="${pageNum}"] .thumbnail-item`);
                thumbnails.forEach(thumb => {
                    const rotationElement = thumb.querySelector('.rotation-badge');
                    if (rotationElement) {
                        rotationElement.textContent = rotation + '°';
                    }
                });
            }

            prevPage.addEventListener('click', function() {
                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

                if (currentIndex > 0) {
                    const prevPageNum = visiblePages[currentIndex - 1].originalPage;
                    pageNum = prevPageNum;
                    queueRenderPage(pageNum);
                }
            });

            nextPage.addEventListener('click', function() {
                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

                if (currentIndex < visiblePages.length - 1) {
                    const nextPageNum = visiblePages[currentIndex + 1].originalPage;
                    pageNum = nextPageNum;
                    queueRenderPage(pageNum);
                }
            });

            quickPrevPage.addEventListener('click', function() {
                prevPage.click();
            });

            quickNextPage.addEventListener('click', function() {
                nextPage.click();
            });

            pageNumInput.addEventListener('change', function() {
                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                let newIndex = parseInt(this.value) - 1;

                if (newIndex < 0) newIndex = 0;
                if (newIndex >= visiblePages.length) newIndex = visiblePages.length - 1;

                if (visiblePages[newIndex]) {
                    pageNum = visiblePages[newIndex].originalPage;
                    queueRenderPage(pageNum);
                }
            });

            showAllPages.addEventListener('click', function() {
                pageOrder.forEach(page => {
                    page.visible = true;
                    page.currentOrder = page.originalPage;
                });

                pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);

                createThumbnails();
                initializeThumbnailSortable();
                showToast('All pages restored');
            });

            removeAllPages.addEventListener('click', function() {
                if (confirm('Remove all pages from download list?')) {
                    pageOrder.forEach(page => {
                        page.visible = false;
                        page.currentOrder = 9999;
                    });

                    createThumbnails();
                    pdfPreviewContainer.innerHTML = `
                        <div class="text-center">
                            <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                            <h5 class="mb-2 text-white">All pages removed</h5>
                            <p class="text-light">Click "Show All" to restore pages</p>
                        </div>
                    `;
                    updatePageStatistics();
                    showToast('All pages removed from download list');
                }
            });

            function updatePageStatistics() {
                const visiblePages = pageOrder.filter(p => p.visible).length;
                const totalPages = pageOrder.length;

                visiblePagesCount.textContent = visiblePages;
                visiblePagesDisplay.textContent = visiblePages;
                pageCountBadge.textContent = visiblePages;

                downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages} pages)`;

                pageCountSpan.textContent = visiblePages;
                totalPagesDisplay2.textContent = visiblePages;

                updateOrientationSummary();
            }

            // downloadFinalPdfBtn.addEventListener('click', async function() {
            //     if (!currentPdfUrl) {
            //         showError('No PDF available to download.');
            //         return;
            //     }

            //     const visiblePages = pageOrder
            //         .filter(p => p.visible)
            //         .sort((a, b) => a.currentOrder - b.currentOrder);

            //     if (visiblePages.length === 0) {
            //         showError('No pages selected for download.');
            //         return;
            //     }

            //     downloadFinalPdfBtn.disabled = true;
            //     downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

            //     try {
            //         const pageOrderData = pageOrder.map(page => ({
            //             OriginalPage: page.originalPage,
            //             CurrentOrder: page.currentOrder,
            //             Visible: page.visible,
            //             Orientation: page.orientation,
            //             Rotation: page.rotation
            //         }));

            //         const selectedSheets = getSelectedSheets();

            //         const response = await fetch('@Url.Action("GenerateReorderedPdf", "Home")', {
            //             method: 'POST',
            //             headers: {
            //                 'Content-Type': 'application/json',
            //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
            //             },
            //             body: JSON.stringify({
            //                 sessionId: sessionId,
            //                 selectedSheets: selectedSheets,
            //                 pageOrderData: pageOrderData,
            //                 orientationData: currentOrientations,
            //                 rotationData: currentRotations
            //             })
            //         });

            //         const result = await response.json();

            //         if (result.success) {
            //             const link = document.createElement('a');
            //             link.href = 'data:application/pdf;base64,' + result.pdfData;
            //             link.download = result.fileName || 'document.pdf';
            //             document.body.appendChild(link);
            //             link.click();
            //             document.body.removeChild(link);

            //             showSuccess(`Downloaded ${visiblePages.length} pages with orientations and rotations applied`);
            //         } else {
            //             showError(result.message || 'Failed to generate PDF');
            //         }
            //     } catch (error) {
            //         console.error('Error downloading PDF:', error);
            //         showError('Error downloading PDF: ' + error.message);
            //     } finally {
            //         downloadFinalPdfBtn.disabled = false;
            //         downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
            //     }
            // });

                    downloadFinalPdfBtn.addEventListener('click', async function() {

                         await new Promise(resolve => setTimeout(resolve, 500));

            if (!currentPdfUrl) {
                showError('No PDF available to download.');
                return;
            }

            const visiblePages = pageOrder
                .filter(p => p.visible)
                .sort((a, b) => a.currentOrder - b.currentOrder);

            if (visiblePages.length === 0) {
                showError('No pages selected for download.');
                return;
            }

            downloadFinalPdfBtn.disabled = true;
            downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

            try {
                // Prepare page data with rotation - SIMPLIFIED
                const pageOrderData = pageOrder.map(page => ({
                    OriginalPage: page.originalPage,
                    CurrentOrder: page.currentOrder,
                    Visible: page.visible,
                    Orientation: page.orientation,
                    Rotation: page.rotation
                }));

                // Prepare orientation and rotation data
                const orientationData = {};
                const rotationData = {};

                pageOrder.forEach(page => {
                    if (page.visible) {
                        orientationData[page.originalPage] = page.orientation;
                        rotationData[page.originalPage] = page.rotation;
                    }
                });

                // Get selected sheets
                const selectedSheets = getSelectedSheets();

                // Send to server for processing - USE SIMPLIFIED VERSION
                const response = await fetch('@Url.Action("GenerateReorderedPdf", "Home")', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify({
                        sessionId: sessionId,
                        selectedSheets: selectedSheets,
                        pageOrderData: pageOrderData,
                        orientationData: orientationData,
                        rotationData: rotationData,
                                        // ✅ SIMPLE FIX: Add scale factor
                scaleFactor: 0.85 // 85% instead of 90%

                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Download the PDF
                    const link = document.createElement('a');
                    link.href = 'data:application/pdf;base64,' + result.pdfData;
                    link.download = result.fileName || 'document.pdf';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    showSuccess(`Downloaded ${visiblePages.length} pages with orientations and rotations applied`);
                } else {
                    showError(result.message || 'Failed to generate PDF');
                }
            } catch (error) {
                console.error('Error downloading PDF:', error);
                showError('Error downloading PDF: ' + error.message);
            } finally {
                downloadFinalPdfBtn.disabled = false;
                downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
            }
        });

            function showToast(message) {
                const toast = document.createElement('div');
                toast.className = 'toast align-items-center text-white bg-primary border-0';
                toast.setAttribute('role', 'alert');
                toast.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            <i class="fas fa-check-circle me-2"></i>
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                    </div>
                `;

                const toastContainer = document.querySelector('.toast-container');
                if (!toastContainer) {
                    const container = document.createElement('div');
                    container.className = 'toast-container position-fixed top-0 end-0 p-3';
                    document.body.appendChild(container);
                    container.appendChild(toast);
                } else {
                    toastContainer.appendChild(toast);
                }

                const bsToast = new bootstrap.Toast(toast);
                bsToast.show();

                setTimeout(() => {
                    toast.remove();
                }, 3000);
            }

            function getSelectedSheets() {
                const selectedSheets = [];
                document.querySelectorAll('.sheet-checkbox:checked').forEach(checkbox => {
                    selectedSheets.push(checkbox.value);
                });
                return selectedSheets;
            }

            const sortableElement = document.getElementById('sortable');
            if (sortableElement) {
                const sortable = new Sortable(sortableElement, {
                    handle: '.drag-handle',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'sortable-drag',
                    onStart: function(evt) {
                        evt.item.style.backgroundColor = '#e3f2fd';
                        document.body.style.cursor = 'grabbing';
                    },
                    onEnd: function(evt) {
                        evt.item.style.backgroundColor = '';
                        document.body.style.cursor = '';
                        updateOrderNumbers();
                        updateSelectedCount();
                    }
                });
            }

            selectAllCheckbox.addEventListener('change', function() {
                const isChecked = this.checked;
                sheetCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
                updateSelectedCount();
            });

            sheetCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateSelectedCount);
            });

            function updateOrderNumbers() {
                const rows = document.querySelectorAll('#sortable tr');
                rows.forEach((row, index) => {
                    const badge = row.querySelector('.order-badge');
                    if (badge) {
                        badge.textContent = index + 1;
                        row.setAttribute('data-order', index);
                    }
                });
            }

            function updateSelectedCount() {
                const selectedCount = document.querySelectorAll('.sheet-checkbox:checked').length;
                selectedSheetsCount.textContent = selectedCount;
                const totalCheckboxes = sheetCheckboxes.length;
                selectAllCheckbox.checked = selectedCount === totalCheckboxes;
                selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCheckboxes;
            }

            convertBtn.addEventListener('click', function() {
                if (!validateBeforeConversion()) {
                    return;
                }

                const selectedSheets = getSelectedSheets();
                if (selectedSheets.length === 0) {
                    alert('Please select at least one sheet to convert.');
                    return;
                }

                submitConversionForm(selectedSheets);
            });

            function submitConversionForm(selectedSheets) {
                const btn = convertBtn;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Converting...';

                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '@Url.Action("ConvertToPdf")';

                const sessionIdInput = document.createElement('input');
                sessionIdInput.type = 'hidden';
                sessionIdInput.name = 'sessionId';
                sessionIdInput.value = sessionId;
                form.appendChild(sessionIdInput);

                selectedSheets.forEach((sheet, index) => {
                    const sheetInput = document.createElement('input');
                    sheetInput.type = 'hidden';
                    sheetInput.name = 'selectedSheets';
                    sheetInput.value = sheet;
                    form.appendChild(sheetInput);

                    const orderInput = document.createElement('input');
                    orderInput.type = 'hidden';
                    orderInput.name = 'sheetOrders';
                    orderInput.value = index;
                    form.appendChild(orderInput);
                });

                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]');
                if (antiForgeryToken) {
                    form.appendChild(antiForgeryToken.cloneNode(true));
                }

                document.body.appendChild(form);
                form.submit();
            }

            function showError(message) {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: message,
                    confirmButtonColor: '#dc3545'
                });
            }

            function showSuccess(message) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success',
                    text: message,
                    confirmButtonColor: '#198754',
                    timer: 3000
                });
            }

            updateOrderNumbers();
            updateSelectedCount();
        });
    </script>

    <style>
        .text-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .sortable-ghost {
            opacity: 0.5;
            background: #e3f2fd;
        }

        .sortable-chosen {
            background-color: #e3f2fd !important;
        }

        .sortable-drag {
            transform: rotate(5deg);
        }

        .thumbnail-item:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .thumbnail-canvas canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .page-info-label {
            position: absolute;
            top: 5px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
            color: white;
        }

        .orientation-label {
            right: 5px;
            background-color: #0d6efd;
        }

        .rotation-label {
            left: 5px;
            background-color: #dc3545;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border: none;
            border-radius: 8px;
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            border: none;
            border-radius: 8px;
        }

        .card {
            border-radius: 15px;
        }

        .table th {
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
        }

        .badge {
            font-size: 0.85em;
            font-weight: 500;
        }

        .drag-handle {
            cursor: grab;
        }

            .drag-handle:active {
                cursor: grabbing;
            }

        .file-upload-area {
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background-color: transparent !important;
        }

            .file-upload-area:hover {
                border-color: #17a2b8;
                background-color: rgba(23, 162, 184, 0.05);
            }

            .file-upload-area.drag-over {
                border-color: #17a2b8 !important;
                background-color: rgba(23, 162, 184, 0.15) !important;
                transform: scale(1.02);
            }

        .border-dashed {
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
        }

        .list-group-item {
            border-left: 0;
            border-right: 0;
        }

            .list-group-item:first-child {
                border-top: 0;
            }

            .list-group-item:last-child {
                border-bottom: 0;
            }
    </style>
}



@* @model ExcelToPdfConverter.Models.PreviewModel

@{
    ViewData["Title"] = "Preview - " + Model.OriginalFileName;
}

@Html.AntiForgeryToken()

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

<div class="container-fluid px-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center py-4 mb-4 border-bottom">
        <div>
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb mb-2">
                    <li class="breadcrumb-item"><a href="@Url.Action("Index")" class="text-decoration-none">Home</a></li>
                    <li class="breadcrumb-item active">Preview</li>
                </ol>
            </nav>
            <h1 class="h3 mb-1 text-gradient">File Preview</h1>
            <p class="text-muted mb-0">Review and select sheets for PDF conversion</p>
        </div>
        <div class="d-flex gap-2">
            <a href="@Url.Action("Index")" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back
            </a>
            <!-- New Merge PDF Button -->
            <button type="button" id="mergePdfBtn" class="btn btn-info px-4">
                <i class="fas fa-file-pdf me-2"></i>Merge PDF Files
            </button>
            <button type="button" id="pdfPreviewBtn" class="btn btn-primary px-4">
                <i class="fas fa-eye me-2"></i>PDF Preview Manager
            </button>
            <button id="convertBtn" class="btn btn-success px-4">
                <i class="fas fa-file-pdf me-2"></i>Convert & Download
            </button>
        </div>
    </div>

    <!-- PDF Upload Section (Initially hidden) -->
    <div id="pdfUploadSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-info text-white">
            <h5 class="mb-0">
                <i class="fas fa-file-upload me-2"></i>Upload PDF Files for Merging
            </h5>
        </div>
        <div class="card-body">
            <div class="alert alert-info border-0">
                <i class="fas fa-info-circle me-2"></i>
                Upload PDF files to merge with your converted Excel sheets. You can upload multiple files at once.
            </div>

            <!-- File Upload Area -->
            <div class="file-upload-area border-dashed rounded-3 p-4 text-center mb-3" id="pdfFileUploadArea">
                <i class="fas fa-file-pdf text-info mb-3" style="font-size: 3rem;"></i>
                <h5 class="mb-3">Drag & Drop your PDF files here</h5>
                <p class="text-muted mb-3">or click to browse multiple files</p>

                <div class="mb-3">
                    <input type="file" class="form-control d-none" name="PdfFiles" id="PdfFiles"
                           accept=".pdf" multiple>
                    <label for="PdfFiles" class="btn btn-info btn-lg px-4" id="pdfFileLabel">
                        <i class="fas fa-folder-open me-2"></i>Choose PDF Files
                    </label>
                </div>

                <div id="pdfFileNames" class="text-muted small mt-2"></div>
                <div class="form-text">Supported format: .pdf • Maximum file size: 50MB per file</div>
            </div>

            <!-- Uploaded Files List -->
            <div id="uploadedFilesList" class="mt-3" style="display: none;">
                <h6 class="mb-3">Uploaded Files:</h6>
                <div id="uploadedFilesContainer" class="list-group"></div>
            </div>

            <!-- Action Buttons -->
            <div class="d-flex gap-2 mt-4">
                <button type="button" id="clearUploadsBtn" class="btn btn-outline-warning flex-grow-1">
                    <i class="fas fa-broom me-2"></i>Clear All Uploads
                </button>
                <button type="button" id="mergeUploadedPdfsBtn" class="btn btn-success flex-grow-1">
                    <i class="fas fa-merge me-2"></i>Merge Uploaded PDFs
                </button>
            </div>
        </div>
    </div>

    <!-- Merged PDF Files List (Initially hidden) -->
    <div id="mergedPdfSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-success text-white">
            <h5 class="mb-0">
                <i class="fas fa-check-circle me-2"></i>Merged PDF Files
            </h5>
        </div>
        <div class="card-body">
            <div class="alert alert-success border-0 mb-3">
                <i class="fas fa-info-circle me-2"></i>
                Merged PDF files will be combined with your Excel conversion. You can continue uploading more PDFs.
            </div>
            <div id="mergedPdfList" class="list-group">
                <!-- Merged PDF files will appear here -->
            </div>
        </div>
    </div>

    <!-- PDF Preview Modal -->
    <div class="modal fade" id="pdfPreviewModal" tabindex="-1" aria-labelledby="pdfPreviewModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title" id="pdfPreviewModalLabel">
                        <i class="fas fa-file-pdf me-2"></i>PDF Page Manager
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge bg-light text-dark me-2">
                            <span id="pageCountBadge">0</span> pages
                        </span>
                        <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="modal-body p-0 d-flex" style="height: calc(100vh - 120px);">
                    <!-- PDF Preview Area -->
                    <div class="flex-grow-1 d-flex flex-column" style="width: 60%; background-color: #525659;">
                        <div id="pdfPreviewContainer" class="flex-grow-1 d-flex justify-content-center align-items-center">
                            <div class="text-center">
                                <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                <h5 class="mb-2 text-white">PDF Preview Area</h5>
                                <p class="text-light mb-0">Preview will appear here</p>
                            </div>
                        </div>
                        <div class="border-top bg-dark text-white p-2" style="display: none;" id="pageInfoBar">
                            <div class="row align-items-center">
                                <div class="col-md-8">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-info-circle me-2"></i>
                                        <small>
                                            Page <span id="currentPageDisplay">1</span> of <span id="totalPagesDisplay2">0</span> •
                                            Orientation: <span id="orientationDisplay">Portrait</span> •
                                            Rotation: <span id="rotationDisplay">0°</span>
                                        </small>
                                    </div>
                                </div>
                                <div class="col-md-4 text-end">
                                    <div class="btn-group btn-group-sm">
                                        <button type="button" class="btn btn-outline-light" id="quickPrevPage">
                                            <i class="fas fa-chevron-left"></i>
                                        </button>
                                        <button type="button" class="btn btn-outline-light" id="quickNextPage">
                                            <i class="fas fa-chevron-right"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Controls Sidebar -->
                    <div class="controls-sidebar border-start" style="width: 40%; background: #ffffff; overflow-y: auto;">
                        <div id="pdfControls" style="display: none;">
                            <!-- Page Controls -->
                            <div class="p-3 border-bottom bg-light">
                                <h6 class="mb-3">
                                    <i class="fas fa-cogs me-2"></i>Page Controls
                                </h6>
                                <div class="row g-3">
                                    <div class="col-8">
                                        <div class="d-flex align-items-center">
                                            <button id="prevPage" class="btn btn-outline-primary btn-sm me-2">
                                                <i class="fas fa-chevron-left"></i> Prev
                                            </button>
                                            <div class="input-group input-group-sm flex-grow-1 me-2">
                                                <input type="number" id="pageNumInput" class="form-control text-center" min="1" value="1">
                                                <span class="input-group-text">/ <span id="page_count">1</span></span>
                                            </div>
                                            <button id="nextPage" class="btn btn-outline-primary btn-sm">
                                                Next <i class="fas fa-chevron-right"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="col-4 text-end">
                                        <div class="text-muted small">Page</div>
                                        <div class="fw-bold" id="currentPageInfo">1</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Orientation & Rotation Controls -->
                            <div class="p-3 border-bottom">
                                <h6 class="mb-3">
                                    <i class="fas fa-compress-alt me-2"></i>Page Orientation & Rotation
                                </h6>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Set orientation for current page • Content will rotate with page
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-success orientation-btn active flex-grow-1"
                                            data-orientation="portrait">
                                        <i class="fas fa-portrait me-1"></i>Portrait
                                    </button>
                                    <button type="button" class="btn btn-outline-warning orientation-btn flex-grow-1"
                                            data-orientation="landscape">
                                        <i class="fas fa-landscape me-1"></i>Landscape
                                    </button>
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-warning rotate-btn flex-grow-1" data-rotation="-90">
                                        <i class="fas fa-undo me-1"></i>Rotate Left
                                    </button>
                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="90">
                                        <i class="fas fa-redo me-1"></i>Rotate Right
                                    </button>
                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="180">
                                        <i class="fas fa-sync-alt me-1"></i>Flip
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary rotate-btn flex-grow-1" id="resetRotation">
                                        <i class="fas fa-history me-1"></i>Reset
                                    </button>
                                </div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllPortrait">
                                        <i class="fas fa-copy me-1"></i>Apply Portrait to All
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllLandscape">
                                        <i class="fas fa-copy me-1"></i>Apply Landscape to All
                                    </button>
                                </div>
                            </div>

                            <!-- Page Thumbnails -->
                            <div class="p-3">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0">
                                        <i class="fas fa-images me-2"></i>Page Thumbnails
                                        <small class="text-muted">(Drag to reorder)</small>
                                    </h6>
                                    <div>
                                        <span class="badge bg-primary" id="visiblePagesCount">0</span>
                                    </div>
                                </div>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Drag thumbnails to reorder pages • Click × to remove pages
                                </div>
                                <div id="thumbnailContainer" class="row g-2 mb-3" style="max-height: 400px; overflow-y: auto;"></div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="showAllPages">
                                        <i class="fas fa-eye me-1"></i>Show All
                                    </button>
                                    <button type="button" class="btn btn-outline-danger btn-sm flex-grow-1" id="removeAllPages">
                                        <i class="fas fa-trash me-1"></i>Remove All
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <div class="w-100 d-flex justify-content-between align-items-center">
                        <div class="text-muted small">
                            <div class="d-flex gap-3">
                                <span>
                                    <i class="fas fa-copy me-1"></i>
                                    Total Pages: <span id="totalPagesCount">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-eye me-1"></i>
                                    Visible: <span id="visiblePagesDisplay">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-compress-alt me-1"></i>
                                    <span id="orientationSummary">Portrait: 0, Landscape: 0</span>
                                </span>
                            </div>
                        </div>
                        <div class="d-flex">
                            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">
                                <i class="fas fa-times me-1"></i>Close
                            </button>
                            <button type="button" id="downloadFinalPdfBtn" class="btn btn-success">
                                <i class="fas fa-download me-1"></i>Download PDF
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Cards -->
    <div class="row g-4 mb-4">
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-primary mb-3">
                        <i class="fas fa-layer-group fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.FileSelections.Count</h3>
                    <p class="text-muted mb-0">Total Sheets</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-danger mb-3">
                        <i class="fas fa-exclamation-triangle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllNameErrors.Count</h3>
                    <p class="text-muted mb-0">#NAME? Errors</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-calendar-check fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllInvoiceDates.Count</h3>
                    <p class="text-muted mb-0">Invoice Dates</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-check-circle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1" id="selectedSheetsCount">0</h3>
                    <p class="text-muted mb-0">Sheets Selected</p>
                </div>
            </div>
        </div>
    </div>


    <!-- Separate Error Sections -->
    @if (Model.HasNameErrors)
    {
        <div class="card border-0 shadow-sm mb-4">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0">
                    <i class="fas fa-exclamation-triangle me-2"></i>#NAME? Errors Found
                </h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Sheet Name</th>
                                <th>Location</th>
                                <th>Cell Reference</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var error in Model.AllNameErrors)
                            {
                                <tr>
                                    <td><strong>@error.SheetName</strong></td>
                                    <td>@error.FullLocation</td>
                                    <td><code>@error.Location</code></td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }

    @if (Model.HasInvoiceDates)
    {
        <div class="card border-0 shadow-sm mb-4">
            <div class="card-header  bg-danger text-white">
                <h5 class="mb-0">
                    <i class="fas fa-calendar-check me-2"></i>Invoice Dates Found (@Model.AllInvoiceDates.Count)
                </h5>
            </div>
            <div class="card-body">
                <div class="alert alert-info">
                    <strong>Debug Info:</strong> Found @Model.AllInvoiceDates.Count invoice dates across all sheets.
                </div>
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>#</th>
                                <th>Sheet Name</th>
                                <th>Invoice Date Text</th>
                                <th>Date Value</th>
                                <th>Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            @{
                                int counter = 1;
                            }
                            @foreach (var invoiceDate in Model.AllInvoiceDates)
                            {
                                <tr>
                                    <td>@(counter++)</td>
                                    <td><strong>@invoiceDate.SheetName</strong></td>
                                    <td><code>@invoiceDate.InvoiceDateText</code></td>
                                    <td><strong class="text-danger">@invoiceDate.DateValue</strong></td>
                                    <td><code>@invoiceDate.Location</code></td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }
    else
    {
        <div class="alert alert-warning">
            <strong>No Invoice Dates Found:</strong> The system did not find any invoice dates in the Excel file.
            Console showed: Credit Note (1), Tax Invoice (1), AOC (1), working sheet (1)
        </div>
    }

    <!-- Sheet Selection -->
    <div class="card border-0 shadow-sm">
        <div class="card-header bg-white py-3 border-bottom">
            <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="fas fa-list-check text-primary me-2"></i>Sheet Selection & Ordering
                </h5>
                <div class="d-flex align-items-center gap-2">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="selectAll" checked>
                        <label class="form-check-label small fw-bold" for="selectAll">
                            Select All
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-hover mb-0" id="sheetSelectionTable">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 60px;" class="text-center ps-4">#</th>
                            <th style="width: 60px;" class="text-center">Select</th>
                            <th>Sheet Name</th>
                            <th style="width: 120px;" class="text-center">#NAME? Errors</th>
                            <th style="width: 120px;" class="text-center">Invoice Dates</th>
                        </tr>
                    </thead>
                    <tbody id="sortable">
                        @foreach (var file in Model.FileSelections.OrderBy(f => f.SortOrder))
                        {
                            <tr data-sheet="@file.SheetName" data-order="@file.SortOrder" class="sortable-row">
                                <td class="text-center align-middle ps-4">
                                    <div class="d-flex align-items-center justify-content-center">
                                        <div class="drag-handle me-2" style="cursor: grab;">
                                            <i class="fas fa-grip-vertical text-muted"></i>
                                        </div>
                                        <span class="order-badge badge bg-primary rounded-pill">@(file.SortOrder + 1)</span>
                                    </div>
                                </td>
                                <td class="text-center align-middle">
                                    <input type="checkbox" name="selectedSheets" value="@file.SheetName"
                                    @(file.IsSelected ? "checked" : "")
                                           class="sheet-checkbox form-check-input">
                                </td>
                                <td class="align-middle">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-table text-muted me-2"></i>
                                        <strong>@file.SheetName</strong>
                                    </div>
                                </td>
                                <td class="text-center align-middle">
                                    @if (file.HasNameErrors)
                                    {
                                        <span class="badge bg-danger rounded-pill">
                                            @file.NameErrors.Count
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="badge bg-success rounded-pill">0</span>
                                    }
                                </td>
                                <td class="text-center align-middle">
                                    @if (file.HasInvoiceDates)
                                    {
                                        <span class="badge bg-success rounded-pill">
                                            @file.InvoiceDates.Count
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="badge bg-secondary rounded-pill">0</span>
                                    }
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sessionId = '@Model.SessionId';
            const convertBtn = document.getElementById('convertBtn');
            const selectAllCheckbox = document.getElementById('selectAll');
            const sheetCheckboxes = document.querySelectorAll('.sheet-checkbox');
            const selectedSheetsCount = document.getElementById('selectedSheetsCount');

            // PDF Preview Variables
            const pdfPreviewBtn = document.getElementById('pdfPreviewBtn');
            const pdfPreviewModal = new bootstrap.Modal(document.getElementById('pdfPreviewModal'));
            const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
            const pdfControls = document.getElementById('pdfControls');
            const downloadFinalPdfBtn = document.getElementById('downloadFinalPdfBtn');
            const pageNumInput = document.getElementById('pageNumInput');
            const pageCountSpan = document.getElementById('page_count');
            const currentPageInfo = document.getElementById('currentPageInfo');
            const totalPagesCount = document.getElementById('totalPagesCount');
            const totalPagesDisplay2 = document.getElementById('totalPagesDisplay2');
            const currentPageDisplay = document.getElementById('currentPageDisplay');
            const orientationDisplay = document.getElementById('orientationDisplay');
            const rotationDisplay = document.getElementById('rotationDisplay');
            const pageCountBadge = document.getElementById('pageCountBadge');
            const visiblePagesCount = document.getElementById('visiblePagesCount');
            const visiblePagesDisplay = document.getElementById('visiblePagesDisplay');
            const pageInfoBar = document.getElementById('pageInfoBar');
            const thumbnailContainer = document.getElementById('thumbnailContainer');
            const showAllPages = document.getElementById('showAllPages');
            const removeAllPages = document.getElementById('removeAllPages');
            const quickPrevPage = document.getElementById('quickPrevPage');
            const quickNextPage = document.getElementById('quickNextPage');
            const prevPage = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            const applyToAllPortrait = document.getElementById('applyToAllPortrait');
            const applyToAllLandscape = document.getElementById('applyToAllLandscape');
            const orientationSummary = document.getElementById('orientationSummary');

            let pdfDoc = null;
            let pageNum = 1;
            let pageRendering = false;
            let pageNumPending = null;
            let currentOrientations = {};
            let currentRotations = {};
            let currentPdfUrl = null;
            let pageOrder = [];
            let thumbnailSortable = null;
            let pdfData = null;
            let pdfFileName = "";

            // PDF Upload Variables
            const mergePdfBtn = document.getElementById('mergePdfBtn');
            const pdfUploadSection = document.getElementById('pdfUploadSection');
            const pdfFileInput = document.getElementById('PdfFiles');
            const pdfFileUploadArea = document.getElementById('pdfFileUploadArea');
            const uploadedFilesContainer = document.getElementById('uploadedFilesContainer');
            const uploadedFilesList = document.getElementById('uploadedFilesList');
            const pdfFileNames = document.getElementById('pdfFileNames');
            const clearUploadsBtn = document.getElementById('clearUploadsBtn');
            const mergeUploadedPdfsBtn = document.getElementById('mergeUploadedPdfsBtn');
            const mergedPdfSection = document.getElementById('mergedPdfSection');
            const mergedPdfList = document.getElementById('mergedPdfList');

            let uploadedPdfs = [];
            let mergedPdfs = [];


            function validateBeforeConversion() {
                let hasNameErrors = @Json.Serialize(Model.HasNameErrors);
                let hasInvoiceDates = @Json.Serialize(Model.HasInvoiceDates);
                let allInvoiceDates = @Json.Serialize(Model.AllInvoiceDates);

                console.log("=== VALIDATION CHECK ===");
                console.log("- Has Name Errors:", hasNameErrors);
                console.log("- Has Invoice Dates:", hasInvoiceDates);
                console.log("- All Invoice Dates:", allInvoiceDates);

                // Check for #NAME? errors
                if (hasNameErrors) {
                    showValidationError("Please fix all #NAME? errors before converting to PDF.");
                    return false;
                }

                // Check for invoice date mismatches
                if (hasInvoiceDates && allInvoiceDates && allInvoiceDates.length > 0) {
                    let hasMismatch = checkInvoiceDateMismatches(allInvoiceDates);
                    if (hasMismatch) {
                        showValidationError("Please fix Invoice Date mismatches before converting to PDF.");
                        return false;
                    }
                }

                console.log("✅ Validation passed - no errors found");
                return true;
            }

            // ✅ Check for Invoice Date mismatches - IMPROVED VERSION
            function checkInvoiceDateMismatches(invoiceDates) {
                console.log("Checking invoice date mismatches...");

                let hasMismatch = false;
                let parsedDates = [];

                // Collect all date values and parse them
                invoiceDates.forEach(invoiceDate => {
                    if (invoiceDate.dateValue && invoiceDate.dateValue.trim() !== '') {
                        const parsedDate = parseDateString(invoiceDate.dateValue.trim());
                        if (parsedDate) {
                            parsedDates.push({
                                originalText: invoiceDate.dateValue.trim(),
                                parsedDate: parsedDate,
                                sheet: invoiceDate.sheetName,
                                location: invoiceDate.location
                            });
                        }
                    }
                });

                console.log("Parsed dates found:", parsedDates);

                // Check if all parsed dates are same
                if (parsedDates.length > 1) {
                    const firstParsedDate = parsedDates[0].parsedDate;

                    // Compare using timestamp for exact match
                    const allSame = parsedDates.every(item =>
                        item.parsedDate.getTime() === firstParsedDate.getTime()
                    );

                    if (!allSame) {
                        console.log("❌ Date mismatch found!");
                        hasMismatch = true;

                        // Show detailed mismatch info
                        showDateMismatchDetailsImproved(parsedDates);
                    } else {
                        console.log("✅ All invoice dates are same (different formats, same date)");
                    }
                } else if (parsedDates.length === 1) {
                    console.log("✅ Only one invoice date found - no mismatch possible");
                } else {
                    console.log("ℹ️ No invoice date values found");
                }

                return hasMismatch;
            }

            // ✅ Parse date string in different formats
            function parseDateString(dateString) {
                console.log(`Parsing date: "${dateString}"`);

                // Try multiple date formats
                const dateFormats = [
                    // Tuesday, 2 December, 2025
                    /^([A-Za-z]+),\s*(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                    // Tuesday, December 2, 2025
                    /^([A-Za-z]+),\s*([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                    // 2 December, 2025
                    /^(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                    // December 2, 2025
                    /^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                    // 2025-12-02
                    /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
                    // 12/02/2025 or 02/12/2025
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
                    // 2-Dec-2025
                    /^(\d{1,2})-([A-Za-z]+)-(\d{4})$/i,
                    // 02 Dec 2025
                    /^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i
                ];

                for (const format of dateFormats) {
                    const match = dateString.match(format);
                    if (match) {
                        console.log(`Matched format: ${format}`);

                        let day, month, year;

                        if (format === dateFormats[0]) { // Tuesday, 2 December, 2025
                            day = parseInt(match[2]);
                            month = getMonthNumber(match[3]);
                            year = parseInt(match[4]);
                        } else if (format === dateFormats[1]) { // Tuesday, December 2, 2025
                            day = parseInt(match[3]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[4]);
                        } else if (format === dateFormats[2]) { // 2 December, 2025
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[3]) { // December 2, 2025
                            day = parseInt(match[2]);
                            month = getMonthNumber(match[1]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[4]) { // 2025-12-02
                            year = parseInt(match[1]);
                            month = parseInt(match[2]);
                            day = parseInt(match[3]);
                        } else if (format === dateFormats[5]) { // MM/DD/YYYY or DD/MM/YYYY
                            // Try both interpretations
                            const monthCandidate = parseInt(match[1]);
                            const dayCandidate = parseInt(match[2]);
                            year = parseInt(match[3]);

                            // Check which makes sense (month should be 1-12)
                            if (monthCandidate >= 1 && monthCandidate <= 12) {
                                month = monthCandidate;
                                day = dayCandidate;
                            } else {
                                month = dayCandidate;
                                day = monthCandidate;
                            }
                        } else if (format === dateFormats[6]) { // 2-Dec-2025
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        } else if (format === dateFormats[7]) { // 02 Dec 2025
                            day = parseInt(match[1]);
                            month = getMonthNumber(match[2]);
                            year = parseInt(match[3]);
                        }

                        if (month && day && year) {
                            const parsedDate = new Date(year, month - 1, day);
                            console.log(`Successfully parsed: ${parsedDate}`);
                            return parsedDate;
                        }
                    }
                }

                // Try native Date.parse as fallback
                const parsed = Date.parse(dateString);
                if (!isNaN(parsed)) {
                    console.log(`Parsed using Date.parse: ${new Date(parsed)}`);
                    return new Date(parsed);
                }

                console.log(`❌ Could not parse date: "${dateString}"`);
                return null;
            }

            // ✅ Convert month name to month number
            function getMonthNumber(monthName) {
                const months = {
                    'january': 1, 'jan': 1,
                    'february': 2, 'feb': 2,
                    'march': 3, 'mar': 3,
                    'april': 4, 'apr': 4,
                    'may': 5,
                    'june': 6, 'jun': 6,
                    'july': 7, 'jul': 7,
                    'august': 8, 'aug': 8,
                    'september': 9, 'sep': 9,
                    'october': 10, 'oct': 10,
                    'november': 11, 'nov': 11,
                    'december': 12, 'dec': 12
                };

                return months[monthName.toLowerCase()] || null;
            }

            // ✅ Show detailed date mismatch information - IMPROVED
            function showDateMismatchDetailsImproved(parsedDates) {
                let dateGroups = {};

                parsedDates.forEach(item => {
                    const dateKey = item.parsedDate.toDateString(); // e.g., "Tue Dec 02 2025"
                    if (!dateGroups[dateKey]) {
                        dateGroups[dateKey] = [];
                    }
                    dateGroups[dateKey].push({
                        sheet: item.sheet,
                        location: item.location,
                        originalText: item.originalText,
                        formattedDate: item.parsedDate.toLocaleDateString('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        })
                    });
                });

                console.log("Date Groups:", dateGroups);

                // Show user-friendly error with date groups
                if (Object.keys(dateGroups).length > 1) {
                    let errorHTML = `
                        <div class="text-start">
                            <h5 class="text-danger mb-3">❌ Invoice Date Mismatch Found</h5>
                            <p class="mb-3">Different invoice dates found in sheets:</p>
                            <div class="alert alert-warning border-0">
                    `;

                    let groupCounter = 1;
                    for (const [dateKey, sheets] of Object.entries(dateGroups)) {
                        const dateObj = new Date(dateKey);
                        const formattedDate = dateObj.toLocaleDateString('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        });

                        errorHTML += `
                            <div class="mb-3">
                                <strong>Date Group ${groupCounter}: ${formattedDate}</strong>
                                <ul class="mb-0 mt-1">
                        `;

                        sheets.forEach(sheet => {
                            errorHTML += `
                                <li>
                                    <strong>${sheet.sheet}</strong>
                                    (${sheet.location}):
                                    <code>${sheet.originalText}</code>
                                </li>
                            `;
                        });

                        errorHTML += `
                                </ul>
                            </div>
                        `;
                        groupCounter++;
                    }

                    errorHTML += `
                            </div>
                            <p class="text-muted mt-3">
                                <i class="fas fa-info-circle me-1"></i>
                                All invoice dates must have the same date value (format can be different).
                            </p>
                        </div>
                    `;

                    // Update the showValidationError to use this HTML
                    Swal.fire({
                        icon: 'error',
                        title: 'Invoice Date Mismatch',
                        html: errorHTML,
                        confirmButtonText: 'OK',
                        confirmButtonColor: '#dc3545',
                        backdrop: true,
                        allowOutsideClick: false,
                        width: '800px'
                    });
                }
            }

            // ✅ Show validation error
            function showValidationError(message) {
                Swal.fire({
                    icon: 'error',
                    title: 'Validation Failed',
                    html: `
                        <div class="text-start">
                            <h5 class="text-danger mb-3">❌ Cannot Convert to PDF</h5>
                            <p class="mb-3">${message}</p>
                            <div class="alert alert-warning border-0">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                <strong>Please fix these issues:</strong>
                                <ul class="mb-0 mt-2">
                                    ${message.includes('#NAME?') ? '<li>Fix all #NAME? formula errors in Excel file</li>' : ''}
                                    ${message.includes('Invoice Date') ? '<li>Ensure all Invoice Dates have the same value</li>' : ''}
                                </ul>
                            </div>
                        </div>
                    `,
                    confirmButtonText: 'OK',
                    confirmButtonColor: '#dc3545',
                    backdrop: true,
                    allowOutsideClick: false
                });
            }

            // PDF Upload Functionality
            mergePdfBtn.addEventListener('click', function() {
                // ✅ Validation check pehle
                if (!validateBeforeConversion()) {
                    return; // Validation fail hone par return kar do
                }

                pdfUploadSection.style.display = 'block';
                mergedPdfSection.style.display = 'block';
                this.style.display = 'none';

                // Load existing uploaded files
                loadExistingPdfFiles();
            });

            clearUploadsBtn.addEventListener('click', function() {
                if (uploadedPdfs.length === 0) {
                    showInfo('No uploaded files to clear.');
                    return;
                }

                Swal.fire({
                    title: 'Clear All Uploads?',
                    text: `This will remove ${uploadedPdfs.length} uploaded PDF file(s). This action cannot be undone.`,
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    cancelButtonColor: '#3085d6',
                    confirmButtonText: 'Yes, clear all!',
                    cancelButtonText: 'Cancel'
                }).then((result) => {
                    if (result.isConfirmed) {
                        clearAllUploadedPdfs();
                    }
                });
            });

            // Load existing PDF files from session
            async function loadExistingPdfFiles() {
                try {
                    const response = await fetch('@Url.Action("GetUploadedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId
                        })
                    });

                    const result = await response.json();
                    if (result.success && result.uploadedFiles) {
                        uploadedPdfs = result.uploadedFiles.map(f => ({
                            name: f.name,
                            path: f.path,
                            size: f.size,
                            uploadTime: new Date(f.uploadTime)
                        }));
                        updateUploadedFilesList();
                    }

                    // Load merged PDFs
                    const mergedResponse = await fetch('@Url.Action("GetMergedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId
                        })
                    });

                    const mergedResult = await mergedResponse.json();
                    if (mergedResult.success && mergedResult.mergedPdfs) {
                        mergedPdfs = mergedResult.mergedPdfs.map(m => ({
                            name: m.fileName,
                            size: m.fileSize,
                            pages: m.totalPages,
                            timestamp: new Date(m.createdAt).toLocaleString()
                        }));
                        updateMergedPdfList();
                    }
                } catch (error) {
                    console.error('Error loading existing PDFs:', error);
                }
            }

            // Clear all uploaded PDFs
            async function clearAllUploadedPdfs() {
                try {
                    const response = await fetch('@Url.Action("ClearAllUploadedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        uploadedPdfs = [];
                        updateUploadedFilesList();
                        showSuccess('All uploaded PDF files cleared successfully.');
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error clearing uploaded PDFs:', error);
                    showError('Error clearing uploaded files: ' + error.message);
                }
            }

            // File input change
            pdfFileInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                handlePdfFiles(files);
            });

            // Drag and drop functionality
            pdfFileUploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                pdfFileUploadArea.classList.add('drag-over');
                pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
            });

            pdfFileUploadArea.addEventListener('dragenter', function(e) {
                e.preventDefault();
                e.stopPropagation();
                pdfFileUploadArea.classList.add('drag-over');
                pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
            });

            pdfFileUploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();

                const relatedTarget = e.relatedTarget;
                if (!pdfFileUploadArea.contains(relatedTarget)) {
                    pdfFileUploadArea.classList.remove('drag-over');
                    pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');
                }
            });

            pdfFileUploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();

                pdfFileUploadArea.classList.remove('drag-over');
                pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');

                const files = Array.from(e.dataTransfer.files).filter(file =>
                    file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                );

                if (files.length > 0) {
                    handlePdfFiles(files);
                } else {
                    showError('Please drop PDF files only.');
                }
            });

            // File upload area click
            pdfFileUploadArea.addEventListener('click', function(e) {
                if (e.target === pdfFileUploadArea || !e.target.closest('label')) {
                    pdfFileInput.click();
                }
            });

            function handlePdfFiles(files) {
                let validFiles = [];
                let invalidFiles = [];

                files.forEach(file => {
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        if (file.size <= 50 * 1024 * 1024) { // 50MB limit
                            validFiles.push(file);
                        } else {
                            invalidFiles.push(`${file.name} (File too large)`);
                        }
                    } else {
                        invalidFiles.push(`${file.name} (Not a PDF)`);
                    }
                });

                if (invalidFiles.length > 0) {
                    showError(`Invalid files:\n${invalidFiles.join('\n')}`);
                }

                if (validFiles.length > 0) {
                    uploadPdfFiles(validFiles);
                }
            }

            async function uploadPdfFiles(files) {
                const formData = new FormData();
                files.forEach(file => {
                    formData.append('pdfFiles', file);
                });

                formData.append('sessionId', sessionId);

                try {
                    const response = await fetch('@Url.Action("UploadPdfFiles", "Home")', {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        }
                    });

                    const result = await response.json();
                    if (result.success) {
                        // ✅ FIX: Append new files to existing uploaded files
                        if (result.uploadedFiles && result.uploadedFiles.length > 0) {
                            // Convert the new files to our format
                            const newFiles = result.uploadedFiles.map(file => ({
                                name: file.name,
                                path: file.path || '',
                                size: file.size,
                                uploadTime: new Date(file.uploadTime || new Date())
                            }));

                            // ✅ IMPORTANT: Update the entire uploadedPdfs array
                            uploadedPdfs = newFiles;

                            updateUploadedFilesList();
                            showSuccess(`${files.length} PDF file(s) uploaded successfully`);
                        }
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error uploading PDF files:', error);
                    showError('Error uploading files: ' + error.message);
                }
            }

            function updateUploadedFilesList() {
                uploadedFilesContainer.innerHTML = '';

                if (uploadedPdfs.length === 0) {
                    uploadedFilesList.style.display = 'none';
                    pdfFileNames.textContent = 'No PDF files selected';
                    clearUploadsBtn.disabled = true;
                    mergeUploadedPdfsBtn.disabled = true;
                    return;
                }

                uploadedFilesList.style.display = 'block';
                pdfFileNames.textContent = `${uploadedPdfs.length} PDF file(s) selected`;
                clearUploadsBtn.disabled = false;
                mergeUploadedPdfsBtn.disabled = false;

                // ✅ Sort by upload time (newest first)
                const sortedPdfs = [...uploadedPdfs].sort((a, b) =>
                    new Date(b.uploadTime) - new Date(a.uploadTime)
                );

                sortedPdfs.forEach((pdf, index) => {
                    const fileSize = pdf.size ? (pdf.size / 1024).toFixed(2) : 'Unknown';
                    const uploadTime = pdf.uploadTime ?
                        (typeof pdf.uploadTime === 'string' ? pdf.uploadTime : pdf.uploadTime.toLocaleString()) :
                        'Just now';

                    const listItem = document.createElement('div');
                    listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                    listItem.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-file-pdf text-danger me-3 fs-5"></i>
                            <div>
                                <div class="fw-bold">${pdf.name}</div>
                                <small class="text-muted">${fileSize} KB • Uploaded: ${uploadTime}</small>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger remove-pdf-btn" data-name="${pdf.name}">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    uploadedFilesContainer.appendChild(listItem);
                });

                // Add event listeners to remove buttons
                document.querySelectorAll('.remove-pdf-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const fileName = this.getAttribute('data-name');
                        removePdfFile(fileName);
                    });
                });
            }

            async function removePdfFile(fileName) {
                try {
                    const response = await fetch('@Url.Action("RemovePdfFile", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            fileName: fileName
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        // Remove from local array
                        uploadedPdfs = uploadedPdfs.filter(p => p.name !== fileName);
                        updateUploadedFilesList();
                        showSuccess('PDF file removed');
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error removing PDF file:', error);
                    showError('Error removing file: ' + error.message);
                }
            }

            mergeUploadedPdfsBtn.addEventListener('click', async function() {
                if (uploadedPdfs.length === 0) {
                    showError('Please upload PDF files first.');
                    return;
                }

                Swal.fire({
                    title: 'Merge Uploaded PDFs?',
                    text: `This will merge ${uploadedPdfs.length} PDF file(s) into a single PDF.`,
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonColor: '#198754',
                    cancelButtonColor: '#6c757d',
                    confirmButtonText: 'Yes, merge them!',
                    cancelButtonText: 'Cancel'
                }).then(async (result) => {
                    if (result.isConfirmed) {
                        await performMergePdfs();
                    }
                });
            });

            async function performMergePdfs() {
                mergeUploadedPdfsBtn.disabled = true;
                mergeUploadedPdfsBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

                try {
                    const fileNames = uploadedPdfs.map(f => f.name);
                    const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            fileNames: fileNames
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        mergedPdfs.push({
                            name: result.fileName,
                            size: result.fileSize,
                            pages: result.totalPages,
                            timestamp: new Date().toLocaleString()
                        });

                        updateMergedPdfList();
                        showSuccess(`PDF files merged successfully (${result.totalPages} pages)`);

                        // ✅ DON'T clear uploaded files - keep them for future merges
                        // Keep upload section visible
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error merging PDFs:', error);
                    showError('Error merging PDFs: ' + error.message);
                } finally {
                    mergeUploadedPdfsBtn.disabled = false;
                    mergeUploadedPdfsBtn.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
                }
            }

            function updateMergedPdfList() {
                mergedPdfList.innerHTML = '';

                if (mergedPdfs.length === 0) {
                    mergedPdfSection.style.display = 'none';
                    return;
                }

                mergedPdfSection.style.display = 'block';

                mergedPdfs.forEach((pdf, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                    listItem.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-file-pdf text-success me-3 fs-5"></i>
                            <div>
                                <div class="fw-bold">${pdf.name}</div>
                                <div class="small text-muted">
                                    <span>${pdf.pages} pages • ${(pdf.size / 1024).toFixed(2)} KB</span>
                                    <br>
                                    <span>Created: ${pdf.timestamp}</span>
                                </div>
                            </div>
                        </div>
                        <div>
                            <button type="button" class="btn btn-sm btn-outline-primary download-merged-btn me-2" data-name="${pdf.name}">
                                <i class="fas fa-download"></i>
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-danger remove-merged-btn" data-name="${pdf.name}">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    `;
                    mergedPdfList.appendChild(listItem);
                });

                // Add event listeners
                document.querySelectorAll('.download-merged-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const fileName = this.getAttribute('data-name');
                        downloadMergedPdf(fileName);
                    });
                });

                document.querySelectorAll('.remove-merged-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const fileName = this.getAttribute('data-name');
                        removeMergedPdf(fileName);
                    });
                });
            }

            async function downloadMergedPdf(fileName) {
                try {
                    const response = await fetch('@Url.Action("DownloadMergedPdf", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            fileName: fileName
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        // Create download link
                        const link = document.createElement('a');
                        link.href = 'data:application/pdf;base64,' + result.pdfData;
                        link.download = result.fileName || 'merged.pdf';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error downloading merged PDF:', error);
                    showError('Error downloading PDF: ' + error.message);
                }
            }

            async function removeMergedPdf(fileName) {
                Swal.fire({
                    title: 'Remove Merged PDF?',
                    text: 'This will delete the merged PDF file. This action cannot be undone.',
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    cancelButtonColor: '#3085d6',
                    confirmButtonText: 'Yes, delete it!',
                    cancelButtonText: 'Cancel'
                }).then(async (result) => {
                    if (result.isConfirmed) {
                        try {
                            const response = await fetch('@Url.Action("RemoveMergedPdf", "Home")', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                },
                                body: JSON.stringify({
                                    sessionId: sessionId,
                                    fileName: fileName
                                })
                            });

                            const result = await response.json();
                            if (result.success) {
                                mergedPdfs = mergedPdfs.filter(p => p.name !== fileName);
                                updateMergedPdfList();
                                showSuccess('Merged PDF removed');
                            }
                        } catch (error) {
                            console.error('Error removing merged PDF:', error);
                            showError('Error removing PDF: ' + error.message);
                        }
                    }
                });
            }

            pdfPreviewBtn.addEventListener('click', async function() {
                // ✅ Validation check pehle
                if (!validateBeforeConversion()) {
                    return; // Validation fail hone par return kar do
                }

                if (!sessionId) {
                    showError('Session information not available.');
                    return;
                }

                const selectedSheets = getSelectedSheets();
                if (selectedSheets.length === 0) {
                    showError('Please select at least one sheet for PDF preview.');
                    return;
                }

                pdfPreviewBtn.disabled = true;
                pdfPreviewBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating PDF...';

                try {
                    // ✅ IMPORTANT: Get current page visibility, orientation and rotation
                    const pageOrderData = [];

                    if (pageOrder && pageOrder.length > 0) {
                        // Use CURRENT page order with visibility
                        pageOrder.forEach(p => {
                            pageOrderData.push({
                                OriginalPage: p.originalPage,
                                CurrentOrder: p.currentOrder,
                                Visible: p.visible, // Current visibility
                                Orientation: p.orientation || 'portrait',
                                Rotation: p.rotation || 0
                            });
                        });
                        console.log(`📊 Sending ${pageOrderData.length} pages to preview, visible: ${pageOrderData.filter(p => p.Visible).length}`);
                    } else {
                        console.log('ℹ️ No existing page order found');
                    }

                    const includeMergedPdfs = mergedPdfs && mergedPdfs.length > 0;

                    // ✅ Call NEW API that applies ONLY FitToPage
                    const result = await generatePdfPreviewWithFitToPage(
                        sessionId,
                        selectedSheets,
                        pageOrderData.length > 0 ? pageOrderData : null,
                        includeMergedPdfs);

                    if (result.success) {
                        pdfData = result.pdfData;
                        pdfFileName = result.fileName;

                        // Show modal and display PDF
                        pdfPreviewModal.show();

                        // ✅ IMPORTANT: Load PDF but keep existing pageOrder
                        // Don't reset pageOrder, orientation, rotation
                        await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName);

                        showSuccess('PDF generated with FitToPage applied!');
                    } else {
                        showError(result.message || 'Failed to generate PDF preview.');
                    }
                } catch (error) {
                    console.error('Error generating PDF preview:', error);
                    showError('Error generating PDF preview: ' + error.message);
                } finally {
                    pdfPreviewBtn.disabled = false;
                    pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager';
                }
            });


            // ✅ NEW: API call for Preview with FitToPage
            async function generatePdfPreviewWithFitToPage(sessionId, selectedSheets, pageOrderData, includeMergedPdfs = false) {
                // ✅ FIX: Handle null or undefined pageOrderData
                const formattedPageOrderData = pageOrderData
                    ? pageOrderData.map(p => ({
                        OriginalPage: p.OriginalPage || p.OriginalPage || 0,
                        CurrentOrder: p.CurrentOrder || p.CurrentOrder || 0,
                        Visible: p.Visible !== undefined ? p.Visible : (p.Visible !== undefined ? p.Visible : true),
                        Orientation: p.Orientation || p.Orientation || 'portrait',
                        Rotation: p.Rotation || p.Rotation || 0
                    }))
                    : null; // Send null if no pageOrderData

                const requestBody = {
                    sessionId: sessionId,
                    selectedSheets: selectedSheets,
                    includeMergedPdfs: includeMergedPdfs
                };

                // Only add pageOrderData if it exists
                if (formattedPageOrderData) {
                    requestBody.pageOrderData = formattedPageOrderData;
                }

                const response = await fetch('@Url.Action("GeneratePdfPreviewWithFitToPage", "Home")', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify(requestBody)
                });

                return await response.json();
            }

            // ✅ NEW: Display PDF while keeping existing settings
            async function displayPdfPreviewWithExistingSettings(pdfData, fileName) {
                console.log('📱 Loading PDF with existing page settings...');

                // Convert base64 to blob
                const byteCharacters = atob(pdfData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/pdf' });

                if (currentPdfUrl) {
                    URL.revokeObjectURL(currentPdfUrl);
                }
                currentPdfUrl = URL.createObjectURL(blob);

                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

                try {
                    const pdfDoc_ = await loadingTask.promise;
                    pdfDoc = pdfDoc_;
                    const totalPages = pdfDoc.numPages;

                    console.log(`📊 PDF loaded: ${totalPages} pages`);

                    // ✅ FIX: Always initialize pageOrder when loading new PDF
                    // Don't rely on existing pageOrder - recreate it based on loaded PDF
                    pageOrder = [];
                    currentOrientations = {};
                    currentRotations = {};

                    for (let i = 1; i <= totalPages; i++) {
                        try {
                            const page = await pdfDoc.getPage(i);
                            const viewport = page.getViewport({ scale: 1.0 });
                            const isLandscape = viewport.width > viewport.height;

                            currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                            currentRotations[i] = 0;

                            pageOrder.push({
                                originalPage: i,
                                currentOrder: i,
                                orientation: isLandscape ? 'landscape' : 'portrait',
                                rotation: 0,
                                visible: true
                            });
                        } catch (error) {
                            console.error(`Error loading page ${i}:`, error);
                            // Add default entry even if page load fails
                            pageOrder.push({
                                originalPage: i,
                                currentOrder: i,
                                orientation: 'portrait',
                                rotation: 0,
                                visible: true
                            });
                        }
                    }

                    console.log(`🆕 Initialized pageOrder with ${pageOrder.length} pages`);

                    // Update UI elements
                    pageCountSpan.textContent = totalPages;
                    totalPagesCount.textContent = totalPages;
                    totalPagesDisplay2.textContent = totalPages;
                    pageCountBadge.textContent = totalPages;
                    visiblePagesCount.textContent = totalPages;
                    visiblePagesDisplay.textContent = totalPages;
                    pageNumInput.max = totalPages;
                    pageNumInput.value = 1;
                    currentPageDisplay.textContent = '1';
                    currentPageInfo.textContent = '1';
                    rotationDisplay.textContent = '0°';

                    // Set initial orientation display
                    updateOrientationDisplay(1);
                    updateOrientationSummary();

                    pdfControls.style.display = 'block';
                    pageInfoBar.style.display = 'block';
                    downloadFinalPdfBtn.style.display = 'block';

                    pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                    pageNum = 1;
                    await renderPage(pageNum);

                    await createThumbnails();
                    initializeThumbnailSortable();

                } catch (error) {
                    console.error('Error loading PDF:', error);
                    pdfPreviewContainer.innerHTML = `
                        <div class="alert alert-danger m-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            Error loading PDF: ${error.message}
                        </div>
                    `;
                }
            }

            // All other PDF preview, rotation, orientation functions remain the same...



               



















             // (All the PDF preview, rotation, orientation, and existing functionality)


                       async function displayPdfPreview(pdfData, fileName) {
               pdfPreviewContainer.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x text-white mb-3"></i><p class="text-white">Loading PDF...</p></div>';
               thumbnailContainer.innerHTML = '';
               pageOrder = [];
               currentOrientations = {};
               currentRotations = {};

               // Convert base64 to blob
               const byteCharacters = atob(pdfData);
               const byteNumbers = new Array(byteCharacters.length);
               for (let i = 0; i < byteCharacters.length; i++) {
                   byteNumbers[i] = byteCharacters.charCodeAt(i);
               }
               const byteArray = new Uint8Array(byteNumbers);
               const blob = new Blob([byteArray], { type: 'application/pdf' });

               if (currentPdfUrl) {
                   URL.revokeObjectURL(currentPdfUrl);
               }
               currentPdfUrl = URL.createObjectURL(blob);

               pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
               const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

               try {
                   const pdfDoc_ = await loadingTask.promise;
                   pdfDoc = pdfDoc_;
                   const totalPages = pdfDoc.numPages;

                   // Initialize page data with default orientations from PDF
                   pageOrder = [];
                   for (let i = 1; i <= totalPages; i++) {
                       const page = await pdfDoc.getPage(i);
                       const viewport = page.getViewport({ scale: 1.0 });
                       const isLandscape = viewport.width > viewport.height;

                       currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                       currentRotations[i] = 0;

                       pageOrder.push({
                           originalPage: i,
                           currentOrder: i,
                           orientation: isLandscape ? 'landscape' : 'portrait',
                           rotation: 0,
                           visible: true
                       });
                   }

                   // Update UI elements
                   pageCountSpan.textContent = totalPages;
                   totalPagesCount.textContent = totalPages;
                   totalPagesDisplay2.textContent = totalPages;
                   pageCountBadge.textContent = totalPages;
                   visiblePagesCount.textContent = totalPages;
                   visiblePagesDisplay.textContent = totalPages;
                   pageNumInput.max = totalPages;
                   pageNumInput.value = 1;
                   currentPageDisplay.textContent = '1';
                   currentPageInfo.textContent = '1';
                   rotationDisplay.textContent = '0°';

                   // Set initial orientation display
                   updateOrientationDisplay(1);
                   updateOrientationSummary();

                   pdfControls.style.display = 'block';
                   pageInfoBar.style.display = 'block';
                   downloadFinalPdfBtn.style.display = 'block';

                   pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                   pageNum = 1;
                   await renderPage(pageNum);

                   await createThumbnails();
                   initializeThumbnailSortable();

               } catch (error) {
                   console.error('Error loading PDF:', error);
                   pdfPreviewContainer.innerHTML = `
                       <div class="alert alert-danger m-3">
                           <i class="fas fa-exclamation-triangle me-2"></i>
                           Error loading PDF: ${error.message}
                       </div>
                   `;
               }
           }

           async function renderPage(num) {
               pageRendering = true;

               const pageData = pageOrder.find(p => p.originalPage === num && p.visible);
               if (!pageData) {
                   const nextVisible = pageOrder.find(p => p.visible && p.originalPage > num);
                   if (nextVisible) {
                       pageNum = nextVisible.originalPage;
                       queueRenderPage(pageNum);
                       return;
                   }
               }

               try {
                   const page = await pdfDoc.getPage(num);
                   const viewport = page.getViewport({ scale: 1.0 });
                   const originalWidth = viewport.width;
                   const originalHeight = viewport.height;

                   // Get current orientation and rotation
                   const currentOrientation = currentOrientations[num] || 'portrait';
                   const currentRotation = currentRotations[num] || 0;

                   // Create canvas
                   const canvas = document.createElement('canvas');
                   const ctx = canvas.getContext('2d');

                   // Calculate scale to fit container
                   const containerWidth = pdfPreviewContainer.clientWidth - 100;
                   const containerHeight = pdfPreviewContainer.clientHeight - 100;

                   // First, calculate scale without rotation
                   let baseScaleX = containerWidth / originalWidth;
                   let baseScaleY = containerHeight / originalHeight;
                   let baseScale = Math.min(baseScaleX, baseScaleY) * 0.9; // 90% of container

                   // Adjust for rotation - when rotated, dimensions change
                   let renderWidth, renderHeight;

                   if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                       // If rotated 90° or 270°, width and height swap
                       renderWidth = originalHeight * baseScale;
                       renderHeight = originalWidth * baseScale;
                   } else {
                       // Normal orientation
                       renderWidth = originalWidth * baseScale;
                       renderHeight = originalHeight * baseScale;
                   }

                   // Now check if rotated content fits in container
                   let finalScale = baseScale;

                   if (currentRotation !== 0) {
                       // For rotation, we need to fit the bounding box of rotated content
                       const rotatedWidth = Math.abs(renderWidth * Math.cos(currentRotation * Math.PI / 180)) +
                                          Math.abs(renderHeight * Math.sin(currentRotation * Math.PI / 180));
                       const rotatedHeight = Math.abs(renderWidth * Math.sin(currentRotation * Math.PI / 180)) +
                                           Math.abs(renderHeight * Math.cos(currentRotation * Math.PI / 180));

                       const rotatedScaleX = containerWidth / rotatedWidth;
                       const rotatedScaleY = containerHeight / rotatedHeight;
                       finalScale = Math.min(rotatedScaleX, rotatedScaleY) * 0.9;
                   }

                   // Recalculate dimensions with final scale
                   if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                       renderWidth = originalHeight * finalScale;
                       renderHeight = originalWidth * finalScale;
                   } else {
                       renderWidth = originalWidth * finalScale;
                       renderHeight = originalHeight * finalScale;
                   }

                   // Set canvas dimensions - make canvas larger to accommodate rotation
                   let canvasWidth = renderWidth;
                   let canvasHeight = renderHeight;

                   if (currentRotation !== 0) {
                       // Add padding for rotation to prevent clipping
                       const padding = 50; // Extra space for rotation
                       canvasWidth = renderWidth + padding * 2;
                       canvasHeight = renderHeight + padding * 2;
                   }

                   canvas.width = canvasWidth;
                   canvas.height = canvasHeight;

                   // Fill background
                   ctx.fillStyle = 'white';
                   ctx.fillRect(0, 0, canvas.width, canvas.height);

                   // Save context state
                   ctx.save();

                   // Translate to center of canvas
                   ctx.translate(canvas.width / 2, canvas.height / 2);

                   // Apply rotation
                   ctx.rotate(currentRotation * Math.PI / 180);

                   // Translate back to draw at center
                   ctx.translate(-renderWidth / 2, -renderHeight / 2);

                   // Create render context with final scale
                   const renderContext = {
                       canvasContext: ctx,
                       viewport: page.getViewport({ scale: finalScale })
                   };

                   await page.render(renderContext).promise;

                   // Restore context
                   ctx.restore();

                   // Display the canvas
                   const container = document.getElementById('canvas-container');
                   container.innerHTML = '';

                   const wrapperDiv = document.createElement('div');
                   wrapperDiv.style.position = 'relative';
                   wrapperDiv.style.border = '2px solid ' + (currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd');
                   wrapperDiv.style.borderRadius = '8px';
                   wrapperDiv.style.backgroundColor = 'white';
                   wrapperDiv.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
                   wrapperDiv.style.padding = '15px';
                   wrapperDiv.style.overflow = 'hidden'; // Prevent content overflow

                   // Add orientation label
                   const orientationLabel = document.createElement('div');
                   orientationLabel.className = 'page-info-label orientation-label';
                   orientationLabel.innerHTML = `<i class="fas ${currentOrientation === 'landscape' ? 'fa-landscape' : 'fa-portrait'}"></i> ${currentOrientation.toUpperCase()}`;
                   orientationLabel.style.position = 'absolute';
                   orientationLabel.style.top = '5px';
                   orientationLabel.style.right = '5px';
                   orientationLabel.style.backgroundColor = currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd';
                   orientationLabel.style.color = 'white';
                   orientationLabel.style.padding = '2px 8px';
                   orientationLabel.style.borderRadius = '4px';
                   orientationLabel.style.fontSize = '12px';
                   orientationLabel.style.zIndex = '100';
                   wrapperDiv.appendChild(orientationLabel);

                   // Add rotation label
                   if (currentRotation !== 0) {
                       const rotationLabel = document.createElement('div');
                       rotationLabel.className = 'page-info-label rotation-label';
                       rotationLabel.innerHTML = `<i class="fas fa-sync-alt"></i> ${currentRotation}°`;
                       rotationLabel.style.position = 'absolute';
                       rotationLabel.style.top = '5px';
                       rotationLabel.style.left = '5px';
                       rotationLabel.style.backgroundColor = '#dc3545';
                       rotationLabel.style.color = 'white';
                       rotationLabel.style.padding = '2px 8px';
                       rotationLabel.style.borderRadius = '4px';
                       rotationLabel.style.fontSize = '12px';
                       rotationLabel.style.zIndex = '100';
                       wrapperDiv.appendChild(rotationLabel);
                   }

                   // Create inner container for canvas with proper sizing
                   const canvasContainer = document.createElement('div');
                   canvasContainer.style.width = '100%';
                   canvasContainer.style.height = '100%';
                   canvasContainer.style.display = 'flex';
                   canvasContainer.style.justifyContent = 'center';
                   canvasContainer.style.alignItems = 'center';
                   canvasContainer.style.overflow = 'hidden';

                   canvasContainer.appendChild(canvas);
                   wrapperDiv.appendChild(canvasContainer);
                   container.appendChild(wrapperDiv);

                   pageRendering = false;

                   if (pageNumPending !== null) {
                       renderPage(pageNumPending);
                       pageNumPending = null;
                   }

                   const visiblePageNumber = pageOrder.filter(p => p.visible && p.originalPage <= num).length;
                   pageNumInput.value = visiblePageNumber;
                   currentPageDisplay.textContent = visiblePageNumber;
                   currentPageInfo.textContent = visiblePageNumber;
                   updateOrientationDisplay(num);
                   updateRotationDisplay(num);
                   updateUIControls(num);

               } catch (error) {
                   console.error('Error rendering page:', error);
               }
           }

           function queueRenderPage(num) {
               if (pageRendering) {
                   pageNumPending = num;
               } else {
                   renderPage(num);
               }
           }

           function updateOrientationDisplay(pageNum) {
               const orientation = currentOrientations[pageNum] || 'portrait';
               orientationDisplay.textContent = orientation === 'portrait' ? 'Portrait' : 'Landscape';
           }

           function updateRotationDisplay(pageNum) {
               const rotation = currentRotations[pageNum] || 0;
               rotationDisplay.textContent = rotation + '°';
           }

           function updateUIControls(pageNum) {
               // Update orientation buttons
               document.querySelectorAll('.orientation-btn').forEach(btn => {
                   btn.classList.remove('active');
                   if (btn.dataset.orientation === (currentOrientations[pageNum] || 'portrait')) {
                       btn.classList.add('active');
                   }
               });

               // Update thumbnail rotation badge
               updateThumbnailRotationBadge(pageNum, currentRotations[pageNum] || 0);
           }

           // Create thumbnails
           async function createThumbnails() {
               thumbnailContainer.innerHTML = '';

               if (!pdfDoc) return;

               const visiblePages = pageOrder
                   .filter(page => page.visible)
                   .sort((a, b) => a.currentOrder - b.currentOrder);

               for (let i = 0; i < visiblePages.length; i++) {
                   const page = visiblePages[i];
                   const pageNum = page.originalPage;
                   await createThumbnailElement(pageNum, i, page.orientation, page.rotation);
               }

               updatePageStatistics();
           }

           async function createThumbnailElement(pageNum, index, orientation, rotation = 0) {
               const colDiv = document.createElement('div');
               colDiv.className = 'col-6 col-md-4';
               colDiv.setAttribute('data-page', pageNum);

               const thumbnailDiv = document.createElement('div');
               thumbnailDiv.className = 'thumbnail-item';
               thumbnailDiv.dataset.page = pageNum;
               thumbnailDiv.style.cssText = `
                   cursor: move;
                   border: 2px solid ${orientation === 'landscape' ? '#ffc107' : '#0d6efd'};
                   border-radius: 8px;
                   overflow: hidden;
                   background: white;
                   transition: all 0.2s ease;
                   margin-bottom: 10px;
                   height: 180px;
                   display: flex;
                   flex-direction: column;
                   position: relative;
               `;

               const orientationIcon = orientation === 'portrait' ? 'fa-portrait' : 'fa-landscape';
               const orientationColor = orientation === 'portrait' ? 'primary' : 'warning';

               thumbnailDiv.innerHTML = `
                   <div class="position-absolute top-0 end-0 p-1">
                       <button type="button" class="btn btn-sm btn-danger remove-page-btn"
                               data-page="${pageNum}"
                               title="Remove this page">
                           <i class="fas fa-times"></i>
                       </button>
                   </div>
                   <div class="position-absolute top-0 start-0 p-1">
                       <span class="badge bg-${orientationColor}">
                           <i class="fas ${orientationIcon}"></i>
                       </span>
                   </div>
                   <div class="thumbnail-canvas flex-grow-1 d-flex justify-content-center align-items-center p-2">
                       <div class="spinner-border spinner-border-sm" role="status">
                           <span class="visually-hidden">Loading...</span>
                       </div>
                   </div>
                   <div class="thumbnail-label bg-light p-2 text-center border-top">
                       <div class="d-flex justify-content-between align-items-center">
                           <small class="text-muted">Page ${pageNum}</small>
                           <div>
                               <small class="badge bg-${orientationColor}">
                                   <i class="fas ${orientationIcon}"></i>
                               </small>
                               <small class="badge bg-info rotation-badge ms-1">${rotation}°</small>
                           </div>
                       </div>
                       <div class="mt-1">
                           <small class="text-primary">
                               <i class="fas fa-sort me-1"></i>Order: ${index + 1}
                           </small>
                       </div>
                   </div>
               `;

               thumbnailContainer.appendChild(colDiv);
               colDiv.appendChild(thumbnailDiv);

               await loadThumbnail(pageNum, thumbnailDiv.querySelector('.thumbnail-canvas'), rotation);

               // Add event listeners
               thumbnailDiv.querySelector('.remove-page-btn').addEventListener('click', function(e) {
                   e.stopPropagation();
                   const pageToRemove = parseInt(this.getAttribute('data-page'));
                   removePage(pageToRemove);
               });

               thumbnailDiv.addEventListener('click', function(e) {
                   if (!e.target.closest('.remove-page-btn')) {
                       const pageNum = parseInt(this.dataset.page);
                       goToPage(pageNum);
                   }
               });
           }

           async function loadThumbnail(pageNum, canvasContainer, rotation = 0) {
               try {
                   const page = await pdfDoc.getPage(pageNum);
                   const viewport = page.getViewport({ scale: 0.15 });
                   const originalWidth = viewport.width;
                   const originalHeight = viewport.height;

                   // Calculate thumbnail size
                   const thumbnailSize = 100; // Fixed size for thumbnail

                   // Calculate scale to fit thumbnail
                   let scaleX = thumbnailSize / originalWidth;
                   let scaleY = thumbnailSize / originalHeight;
                   let scale = Math.min(scaleX, scaleY);

                   // Adjust for rotation
                   let canvasWidth = originalWidth * scale;
                   let canvasHeight = originalHeight * scale;

                   if (rotation === 90 || rotation === -90 || rotation === 270) {
                       // Swap dimensions for 90° rotation
                       const temp = canvasWidth;
                       canvasWidth = canvasHeight;
                       canvasHeight = temp;
                   }

                   // Add padding for rotation
                   const padding = 10;
                   const finalWidth = canvasWidth + padding * 2;
                   const finalHeight = canvasHeight + padding * 2;

                   const canvas = document.createElement('canvas');
                   const ctx = canvas.getContext('2d');

                   canvas.width = finalWidth;
                   canvas.height = finalHeight;

                   // Fill background
                   ctx.fillStyle = 'white';
                   ctx.fillRect(0, 0, canvas.width, canvas.height);

                   // Save context
                   ctx.save();

                   // Move to center
                   ctx.translate(finalWidth / 2, finalHeight / 2);

                   // Apply rotation
                   ctx.rotate(rotation * Math.PI / 180);

                   // Move back and draw
                   ctx.translate(-canvasWidth / 2, -canvasHeight / 2);

                   // Create render context
                   const renderContext = {
                       canvasContext: ctx,
                       viewport: page.getViewport({ scale: scale })
                   };

                   await page.render(renderContext).promise;

                   // Restore context
                   ctx.restore();

                   canvasContainer.innerHTML = '';
                   canvasContainer.appendChild(canvas);

               } catch (error) {
                   console.error(`Error loading thumbnail for page ${pageNum}:`, error);
                   canvasContainer.innerHTML = '<div class="text-muted small">Error loading thumbnail</div>';
               }
           }

            function applyRotationToCanvas(canvas, rotation) {
                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;

                    const rotatedCanvas = document.createElement('canvas');
                    const rotatedCtx = rotatedCanvas.getContext('2d');

                    if (rotation === 90 || rotation === -90 || rotation === 270) {
                        rotatedCanvas.width = height;
                        rotatedCanvas.height = width;
                    } else {
                        rotatedCanvas.width = width;
                        rotatedCanvas.height = height;
                    }

                    rotatedCtx.clearRect(0, 0, rotatedCanvas.width, rotatedCanvas.height);
                    rotatedCtx.save();
                    rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
                    rotatedCtx.rotate(rotation * Math.PI / 180);
                    rotatedCtx.drawImage(canvas, -width / 2, -height / 2);
                    rotatedCtx.restore();

                    canvas.width = rotatedCanvas.width;
                    canvas.height = rotatedCanvas.height;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(rotatedCanvas, 0, 0);
                }

           function initializeThumbnailSortable() {
               if (thumbnailSortable) {
                   thumbnailSortable.destroy();
               }

               thumbnailSortable = new Sortable(thumbnailContainer, {
                   animation: 150,
                   ghostClass: 'sortable-ghost',
                   chosenClass: 'sortable-chosen',
                   dragClass: 'sortable-drag',
                   filter: '.remove-page-btn',
                   onStart: function(evt) {
                       evt.item.style.opacity = '0.8';
                   },
                   onEnd: function(evt) {
                       evt.item.style.opacity = '1';

                       const items = thumbnailContainer.querySelectorAll('[data-page]');
                       const newOrder = [];

                       items.forEach((item, index) => {
                           const pageNum = parseInt(item.getAttribute('data-page'));
                           const pageData = pageOrder.find(p => p.originalPage === pageNum);
                           if (pageData) {
                               pageData.currentOrder = index + 1;
                               newOrder.push(pageData);
                           }
                       });

                       pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);
                       updateThumbnailLabels();
                       updatePageStatistics();
                       showToast('Page order updated!');
                   }
               });
           }

           function updateThumbnailLabels() {
               const thumbnails = document.querySelectorAll('.thumbnail-item');
               thumbnails.forEach((thumb, index) => {
                   const label = thumb.querySelector('.text-primary small');
                   if (label) {
                       label.innerHTML = `<i class="fas fa-sort me-1"></i>Order: ${index + 1}`;
                   }
               });
           }

           function removePage(pageNum) {
               const pageIndex = pageOrder.findIndex(p => p.originalPage === pageNum);
               if (pageIndex !== -1) {
                   pageOrder[pageIndex].visible = false;
                   pageOrder[pageIndex].currentOrder = 9999;

                   if (pageNum === pageNum) {
                       const nextVisiblePage = pageOrder.find(p => p.visible);
                       if (nextVisiblePage) {
                           goToPage(nextVisiblePage.originalPage);
                       } else {
                           pdfPreviewContainer.innerHTML = `
                               <div class="text-center">
                                   <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                   <h5 class="mb-2 text-white">No pages to display</h5>
                                   <p class="text-light">All pages have been removed</p>
                               </div>
                           `;
                       }
                   }

                   createThumbnails();
                   updatePageStatistics();
                   showToast(`Page ${pageNum} removed from download list`);
               }
           }

           function goToPage(targetPage) {
               const pageData = pageOrder.find(p => p.originalPage === targetPage);
               if (pageData && pageData.visible) {
                   pageNum = targetPage;
                   queueRenderPage(pageNum);
               }
           }

           // ORIENTATION CONTROLS
           document.querySelectorAll('.orientation-btn').forEach(btn => {
               btn.addEventListener('click', function() {
                   const orientation = this.dataset.orientation;
                   setCurrentPageOrientation(orientation);
               });
           });

           function setCurrentPageOrientation(orientation) {
               if (!pageNum) return;

               currentOrientations[pageNum] = orientation;

               const pageData = pageOrder.find(p => p.originalPage === pageNum);
               if (pageData) {
                   pageData.orientation = orientation;
               }

               updateOrientationDisplay(pageNum);

               document.querySelectorAll('.orientation-btn').forEach(btn => {
                   btn.classList.remove('active');
                   if (btn.dataset.orientation === orientation) {
                       btn.classList.add('active');
                   }
               });

               queueRenderPage(pageNum);
               updateOrientationSummary();
               showToast(`Page ${pageNum} set to ${orientation}`);
           }

           applyToAllPortrait.addEventListener('click', function() {
               if (confirm('Apply Portrait orientation to all pages?')) {
                   pageOrder.forEach(page => {
                       if (page.visible) {
                           page.orientation = 'portrait';
                           currentOrientations[page.originalPage] = 'portrait';
                       }
                   });
                   createThumbnails();
                   updateOrientationSummary();
                   queueRenderPage(pageNum);
                   showToast('Portrait orientation applied to all pages');
               }
           });

           applyToAllLandscape.addEventListener('click', function() {
               if (confirm('Apply Landscape orientation to all pages?')) {
                   pageOrder.forEach(page => {
                       if (page.visible) {
                           page.orientation = 'landscape';
                           currentOrientations[page.originalPage] = 'landscape';
                       }
                   });
                   createThumbnails();
                   updateOrientationSummary();
                   queueRenderPage(pageNum);
                   showToast('Landscape orientation applied to all pages');
               }
           });

           function updateOrientationSummary() {
               let portraitCount = 0;
               let landscapeCount = 0;

               pageOrder.forEach(page => {
                   if (page.visible) {
                       if (page.orientation === 'portrait') {
                           portraitCount++;
                       } else {
                           landscapeCount++;
                       }
                   }
               });

               orientationSummary.textContent = `Portrait: ${portraitCount}, Landscape: ${landscapeCount}`;
           }

           // ROTATION CONTROLS
           document.querySelectorAll('.rotate-btn').forEach(btn => {
               btn.addEventListener('click', function() {
                   if (this.id === 'resetRotation') {
                       resetRotation();
                   } else {
                       const rotation = parseInt(this.dataset.rotation);
                       applyRotation(rotation);
                   }
               });
           });

           function applyRotation(rotation) {
               if (!pageNum) return;

               // Initialize if not exists
               if (!currentRotations[pageNum]) {
                   currentRotations[pageNum] = 0;
               }

               // Apply rotation
               currentRotations[pageNum] = (currentRotations[pageNum] + rotation) % 360;
               if (currentRotations[pageNum] < 0) {
                   currentRotations[pageNum] += 360;
               }

               // Update page data
               const pageData = pageOrder.find(p => p.originalPage === pageNum);
               if (pageData) {
                   pageData.rotation = currentRotations[pageNum];
               }

               // Update display
               updateRotationDisplay(pageNum);
               queueRenderPage(pageNum);

               // Update thumbnail
               updateThumbnailRotationBadge(pageNum, currentRotations[pageNum]);

               showToast(`Page rotated to ${currentRotations[pageNum]}°`);
           }

           function resetRotation() {
               if (!pageNum) return;

               currentRotations[pageNum] = 0;
               const pageData = pageOrder.find(p => p.originalPage === pageNum);
               if (pageData) {
                   pageData.rotation = 0;
               }

               updateRotationDisplay(pageNum);
               queueRenderPage(pageNum);
               updateThumbnailRotationBadge(pageNum, 0);

               showToast('Rotation reset to 0°');
           }

           function updateThumbnailRotationBadge(pageNum, rotation) {
               const thumbnails = document.querySelectorAll(`[data-page="${pageNum}"] .thumbnail-item`);
               thumbnails.forEach(thumb => {
                   const rotationElement = thumb.querySelector('.rotation-badge');
                   if (rotationElement) {
                       rotationElement.textContent = rotation + '°';
                   }
               });
           }

           // PAGE NAVIGATION
           prevPage.addEventListener('click', function() {
               const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
               const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

               if (currentIndex > 0) {
                   const prevPageNum = visiblePages[currentIndex - 1].originalPage;
                   pageNum = prevPageNum;
                   queueRenderPage(pageNum);
               }
           });

           nextPage.addEventListener('click', function() {
               const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
               const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

               if (currentIndex < visiblePages.length - 1) {
                   const nextPageNum = visiblePages[currentIndex + 1].originalPage;
                   pageNum = nextPageNum;
                   queueRenderPage(pageNum);
               }
           });

           quickPrevPage.addEventListener('click', function() {
               prevPage.click();
           });

           quickNextPage.addEventListener('click', function() {
               nextPage.click();
           });

           pageNumInput.addEventListener('change', function() {
               const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
               let newIndex = parseInt(this.value) - 1;

               if (newIndex < 0) newIndex = 0;
               if (newIndex >= visiblePages.length) newIndex = visiblePages.length - 1;

               if (visiblePages[newIndex]) {
                   pageNum = visiblePages[newIndex].originalPage;
                   queueRenderPage(pageNum);
               }
           });

           showAllPages.addEventListener('click', function() {
               pageOrder.forEach(page => {
                   page.visible = true;
                   page.currentOrder = page.originalPage;
               });

               pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);

               createThumbnails();
               initializeThumbnailSortable();
               showToast('All pages restored');
           });

           removeAllPages.addEventListener('click', function() {
               if (confirm('Remove all pages from download list?')) {
                   pageOrder.forEach(page => {
                       page.visible = false;
                       page.currentOrder = 9999;
                   });

                   createThumbnails();
                   pdfPreviewContainer.innerHTML = `
                       <div class="text-center">
                           <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                           <h5 class="mb-2 text-white">All pages removed</h5>
                           <p class="text-light">Click "Show All" to restore pages</p>
                       </div>
                   `;
                   updatePageStatistics();
                   showToast('All pages removed from download list');
               }
           });

           function updatePageStatistics() {
               const visiblePages = pageOrder.filter(p => p.visible).length;
               const totalPages = pageOrder.length;

               visiblePagesCount.textContent = visiblePages;
               visiblePagesDisplay.textContent = visiblePages;
               pageCountBadge.textContent = visiblePages;

               downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages} pages)`;

               pageCountSpan.textContent = visiblePages;
               totalPagesDisplay2.textContent = visiblePages;

               updateOrientationSummary();
           }

           // DOWNLOAD PDF WITH ORIENTATIONS & ROTATIONS
           downloadFinalPdfBtn.addEventListener('click', async function() {
               if (!currentPdfUrl) {
                   showError('No PDF available to download.');
                   return;
               }

               const visiblePages = pageOrder
                   .filter(p => p.visible)
                   .sort((a, b) => a.currentOrder - b.currentOrder);

               if (visiblePages.length === 0) {
                   showError('No pages selected for download.');
                   return;
               }

               downloadFinalPdfBtn.disabled = true;
               downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

               try {
                   // Prepare page data with rotation
                   const pageOrderData = pageOrder.map(page => ({
                       OriginalPage: page.originalPage,
                       CurrentOrder: page.currentOrder,
                       Visible: page.visible,
                       Orientation: page.orientation,
                       Rotation: page.rotation
                   }));

                   // Get selected sheets
                   const selectedSheets = getSelectedSheets();

                   // Send to server for processing
                   const response = await fetch('@Url.Action("GenerateReorderedPdf", "Home")', {
                       method: 'POST',
                       headers: {
                           'Content-Type': 'application/json',
                           'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                       },
                       body: JSON.stringify({
                           sessionId: sessionId,
                           selectedSheets: selectedSheets,
                           pageOrderData: pageOrderData,
                           orientationData: currentOrientations,
                           rotationData: currentRotations
                       })
                   });

                   const result = await response.json();

                   if (result.success) {
                       // Download the PDF
                       const link = document.createElement('a');
                       link.href = 'data:application/pdf;base64,' + result.pdfData;
                       link.download = result.fileName || 'document.pdf';
                       document.body.appendChild(link);
                       link.click();
                       document.body.removeChild(link);

                       showSuccess(`Downloaded ${visiblePages.length} pages with orientations and rotations applied`);
                   } else {
                       showError(result.message || 'Failed to generate PDF');
                   }
               } catch (error) {
                   console.error('Error downloading PDF:', error);
                   showError('Error downloading PDF: ' + error.message);
               } finally {
                   downloadFinalPdfBtn.disabled = false;
                   downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
               }
           });


               // =============================================
               // HELPER FUNCTIONS
               // =============================================

               function showToast(message) {
                   const toast = document.createElement('div');
                   toast.className = 'toast align-items-center text-white bg-primary border-0';
                   toast.setAttribute('role', 'alert');
                   toast.innerHTML = `
                       <div class="d-flex">
                           <div class="toast-body">
                               <i class="fas fa-check-circle me-2"></i>
                               ${message}
                           </div>
                           <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                       </div>
                   `;

                   const toastContainer = document.querySelector('.toast-container');
                   if (!toastContainer) {
                       const container = document.createElement('div');
                       container.className = 'toast-container position-fixed top-0 end-0 p-3';
                       document.body.appendChild(container);
                       container.appendChild(toast);
                   } else {
                       toastContainer.appendChild(toast);
                   }

                   const bsToast = new bootstrap.Toast(toast);
                   bsToast.show();

                   setTimeout(() => {
                       toast.remove();
                   }, 3000);
               }

               // Existing sheet selection functionality
              

              






            // Helper Functions
            function showInfo(message) {
                Swal.fire({
                    icon: 'info',
                    title: 'Information',
                    text: message,
                    confirmButtonColor: '#0dcaf0',
                    timer: 3000
                });
            }

            function showSuccess(message) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success',
                    text: message,
                    confirmButtonColor: '#198754',
                    timer: 3000
                });
            }

            function showError(message) {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: message,
                    confirmButtonColor: '#dc3545'
                });
            }

            // Existing sheet selection functionality
            const sortableElement = document.getElementById('sortable');
            if (sortableElement) {
                const sortable = new Sortable(sortableElement, {
                    handle: '.drag-handle',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'sortable-drag',
                    onStart: function(evt) {
                        evt.item.style.backgroundColor = '#e3f2fd';
                        document.body.style.cursor = 'grabbing';
                    },
                    onEnd: function(evt) {
                        evt.item.style.backgroundColor = '';
                        document.body.style.cursor = '';
                        updateOrderNumbers();
                        updateSelectedCount();
                    }
                });
            }

            selectAllCheckbox.addEventListener('change', function() {
                const isChecked = this.checked;
                sheetCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });
                updateSelectedCount();
            });

            sheetCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateSelectedCount);
            });

            function updateOrderNumbers() {
                const rows = document.querySelectorAll('#sortable tr');
                rows.forEach((row, index) => {
                    const badge = row.querySelector('.order-badge');
                    if (badge) {
                        badge.textContent = index + 1;
                        row.setAttribute('data-order', index);
                    }
                });
            }

            function updateSelectedCount() {
                const selectedCount = document.querySelectorAll('.sheet-checkbox:checked').length;
                selectedSheetsCount.textContent = selectedCount;
                const totalCheckboxes = sheetCheckboxes.length;
                selectAllCheckbox.checked = selectedCount === totalCheckboxes;
                selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCheckboxes;
            }

            convertBtn.addEventListener('click', function() {
                // ✅ Validation check pehle
                if (!validateBeforeConversion()) {
                    return; // Validation fail hone par return kar do
                }

                const selectedSheets = getSelectedSheets();
                if (selectedSheets.length === 0) {
                    alert('Please select at least one sheet to convert.');
                    return;
                }

                submitConversionForm(selectedSheets);
            });

            function submitConversionForm(selectedSheets) {
                const btn = convertBtn;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Converting...';

                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '@Url.Action("ConvertToPdf")';

                const sessionIdInput = document.createElement('input');
                sessionIdInput.type = 'hidden';
                sessionIdInput.name = 'sessionId';
                sessionIdInput.value = sessionId;
                form.appendChild(sessionIdInput);

                selectedSheets.forEach((sheet, index) => {
                    const sheetInput = document.createElement('input');
                    sheetInput.type = 'hidden';
                    sheetInput.name = 'selectedSheets';
                    sheetInput.value = sheet;
                    form.appendChild(sheetInput);

                    const orderInput = document.createElement('input');
                    orderInput.type = 'hidden';
                    orderInput.name = 'sheetOrders';
                    orderInput.value = index;
                    form.appendChild(orderInput);
                });

                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]');
                if (antiForgeryToken) {
                    form.appendChild(antiForgeryToken.cloneNode(true));
                }

                document.body.appendChild(form);
                form.submit();
            }

            function getSelectedSheets() {
                const selectedSheets = [];
                document.querySelectorAll('.sheet-checkbox:checked').forEach(checkbox => {
                    selectedSheets.push(checkbox.value);
                });
                return selectedSheets;
            }

            updateOrderNumbers();
            updateSelectedCount();

        });
    </script>

    <style>
        .text-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .sortable-ghost {
            opacity: 0.5;
            background: #e3f2fd;
        }

        .sortable-chosen {
            background-color: #e3f2fd !important;
        }

        .sortable-drag {
            transform: rotate(5deg);
        }

        .thumbnail-item:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .thumbnail-canvas canvas {
            max-width: 100%;
            max-height: 100%;
        }

        .page-info-label {
            position: absolute;
            top: 5px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
            color: white;
        }

        .orientation-label {
            right: 5px;
            background-color: #0d6efd;
        }

        .rotation-label {
            left: 5px;
            background-color: #dc3545;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border: none;
            border-radius: 8px;
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            border: none;
            border-radius: 8px;
        }

        .card {
            border-radius: 15px;
        }

        .table th {
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
        }

        .badge {
            font-size: 0.85em;
            font-weight: 500;
        }

        .drag-handle {
            cursor: grab;
        }

            .drag-handle:active {
                cursor: grabbing;
            }

        .file-upload-area {
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background-color: transparent !important;
        }

            .file-upload-area:hover {
                border-color: #17a2b8;
                background-color: rgba(23, 162, 184, 0.05);
            }

            .file-upload-area.drag-over {
                border-color: #17a2b8 !important;
                background-color: rgba(23, 162, 184, 0.15) !important;
                transform: scale(1.02);
            }

        .border-dashed {
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
        }

        .list-group-item {
            border-left: 0;
            border-right: 0;
        }

            .list-group-item:first-child {
                border-top: 0;
            }

            .list-group-item:last-child {
                border-bottom: 0;
            }
    </style>
}
 *@


@* @model ExcelToPdfConverter.Models.PreviewModel *@

@* @{ *@
@*     ViewData["Title"] = "Preview - " + Model.OriginalFileName; *@
@* } *@

@* @Html.AntiForgeryToken() *@

@* <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> *@
@* <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script> *@
@* <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script> *@
@* <link href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" rel="stylesheet"> *@
@* <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script> *@

@* <div class="container-fluid px-4"> *@
@*     <!-- Header --> *@
@*     <div class="d-flex justify-content-between align-items-center py-4 mb-4 border-bottom"> *@
@*         <div> *@
@*             <nav aria-label="breadcrumb"> *@
@*                 <ol class="breadcrumb mb-2"> *@
@*                     <li class="breadcrumb-item"><a href="@Url.Action("Index")" class="text-decoration-none">Home</a></li> *@
@*                     <li class="breadcrumb-item active">Preview</li> *@
@*                 </ol> *@
@*             </nav> *@
@*             <h1 class="h3 mb-1 text-gradient">File Preview</h1> *@
@*             <p class="text-muted mb-0">Review and select sheets for PDF conversion</p> *@
@*         </div> *@
@*         <div class="d-flex gap-2"> *@
@*             <a href="@Url.Action("Index")" class="btn btn-outline-secondary"> *@
@*                 <i class="fas fa-arrow-left me-2"></i>Back *@
@*             </a> *@
@*             <!-- New Merge PDF Button --> *@
@*             <button type="button" id="mergePdfBtn" class="btn btn-info px-4"> *@
@*                 <i class="fas fa-file-pdf me-2"></i>Merge PDF Files *@
@*             </button> *@
@*             <button type="button" id="pdfPreviewBtn" class="btn btn-primary px-4"> *@
@*                 <i class="fas fa-eye me-2"></i>PDF Preview Manager *@
@*             </button> *@
@*             <button id="convertBtn" class="btn btn-success px-4"> *@
@*                 <i class="fas fa-file-pdf me-2"></i>Convert & Download *@
@*             </button> *@
@*         </div> *@
@*     </div> *@

@*     <!-- PDF Upload Section (Initially hidden) --> *@
@*     <div id="pdfUploadSection" class="card border-0 shadow-sm mb-4" style="display: none;"> *@
@*         <div class="card-header bg-info text-white"> *@
@*             <h5 class="mb-0"> *@
@*                 <i class="fas fa-file-upload me-2"></i>Upload PDF Files for Merging *@
@*             </h5> *@
@*         </div> *@
@*         <div class="card-body"> *@
@*             <div class="alert alert-info border-0"> *@
@*                 <i class="fas fa-info-circle me-2"></i> *@
@*                 Upload PDF files to merge with your converted Excel sheets. You can upload multiple files at once. *@
@*             </div> *@

@*             <!-- File Upload Area --> *@
@*             <div class="file-upload-area border-dashed rounded-3 p-4 text-center mb-3" id="pdfFileUploadArea"> *@
@*                 <i class="fas fa-file-pdf text-info mb-3" style="font-size: 3rem;"></i> *@
@*                 <h5 class="mb-3">Drag & Drop your PDF files here</h5> *@
@*                 <p class="text-muted mb-3">or click to browse multiple files</p> *@

@*                 <div class="mb-3"> *@
@*                     <input type="file" class="form-control d-none" name="PdfFiles" id="PdfFiles" *@
@*                            accept=".pdf" multiple> *@
@*                     <label for="PdfFiles" class="btn btn-info btn-lg px-4" id="pdfFileLabel"> *@
@*                         <i class="fas fa-folder-open me-2"></i>Choose PDF Files *@
@*                     </label> *@
@*                 </div> *@

@*                 <div id="pdfFileNames" class="text-muted small mt-2"></div> *@
@*                 <div class="form-text">Supported format: .pdf • Maximum file size: 50MB per file</div> *@
@*             </div> *@

@*             <!-- Uploaded Files List --> *@
@*             <div id="uploadedFilesList" class="mt-3" style="display: none;"> *@
@*                 <h6 class="mb-3">Uploaded Files:</h6> *@
@*                 <div id="uploadedFilesContainer" class="list-group"></div> *@
@*             </div> *@

@*             <!-- Action Buttons --> *@
@*             <div class="d-flex gap-2 mt-4"> *@
@*                 <button type="button" id="cancelUploadBtn" class="btn btn-outline-secondary flex-grow-1"> *@
@*                     <i class="fas fa-times me-2"></i>Cancel *@
@*                 </button> *@
@*                 <button type="button" id="mergeUploadedPdfsBtn" class="btn btn-success flex-grow-1"> *@
@*                     <i class="fas fa-merge me-2"></i>Merge Uploaded PDFs *@
@*                 </button> *@
@*             </div> *@
@*         </div> *@
@*     </div> *@

@*     <!-- Merged PDF Files List (Initially hidden) --> *@
@*     <div id="mergedPdfSection" class="card border-0 shadow-sm mb-4" style="display: none;"> *@
@*         <div class="card-header bg-success text-white"> *@
@*             <h5 class="mb-0"> *@
@*                 <i class="fas fa-check-circle me-2"></i>Merged PDF Files *@
@*             </h5> *@
@*         </div> *@
@*         <div class="card-body"> *@
@*             <div id="mergedPdfList" class="list-group"> *@
@*                 <!-- Merged PDF files will appear here --> *@
@*             </div> *@
@*         </div> *@
@*     </div> *@

@*     <!-- PDF Preview Modal --> *@
@*     <div class="modal fade" id="pdfPreviewModal" tabindex="-1" aria-labelledby="pdfPreviewModalLabel" aria-hidden="true"> *@
@*         <div class="modal-dialog modal-fullscreen"> *@
@*             <div class="modal-content"> *@
@*                 <div class="modal-header bg-primary text-white"> *@
@*                     <h5 class="modal-title" id="pdfPreviewModalLabel"> *@
@*                         <i class="fas fa-file-pdf me-2"></i>PDF Page Manager *@
@*                     </h5> *@
@*                     <div class="d-flex align-items-center gap-2"> *@
@*                         <span class="badge bg-light text-dark me-2"> *@
@*                             <span id="pageCountBadge">0</span> pages *@
@*                         </span> *@
@*                         <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal"> *@
@*                             <i class="fas fa-times"></i> *@
@*                         </button> *@
@*                     </div> *@
@*                 </div> *@
@*                 <div class="modal-body p-0 d-flex" style="height: calc(100vh - 120px);"> *@
@*                     <!-- PDF Preview Area --> *@
@*                     <div class="flex-grow-1 d-flex flex-column" style="width: 60%; background-color: #525659;"> *@
@*                         <div id="pdfPreviewContainer" class="flex-grow-1 d-flex justify-content-center align-items-center"> *@
@*                             <div class="text-center"> *@
@*                                 <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i> *@
@*                                 <h5 class="mb-2 text-white">PDF Preview Area</h5> *@
@*                                 <p class="text-light mb-0">Preview will appear here</p> *@
@*                             </div> *@
@*                         </div> *@
@*                         <div class="border-top bg-dark text-white p-2" style="display: none;" id="pageInfoBar"> *@
@*                             <div class="row align-items-center"> *@
@*                                 <div class="col-md-8"> *@
@*                                     <div class="d-flex align-items-center"> *@
@*                                         <i class="fas fa-info-circle me-2"></i> *@
@*                                         <small> *@
@*                                             Page <span id="currentPageDisplay">1</span> of <span id="totalPagesDisplay2">0</span> • *@
@*                                             Orientation: <span id="orientationDisplay">Portrait</span> • *@
@*                                             Rotation: <span id="rotationDisplay">0°</span> *@
@*                                         </small> *@
@*                                     </div> *@
@*                                 </div> *@
@*                                 <div class="col-md-4 text-end"> *@
@*                                     <div class="btn-group btn-group-sm"> *@
@*                                         <button type="button" class="btn btn-outline-light" id="quickPrevPage"> *@
@*                                             <i class="fas fa-chevron-left"></i> *@
@*                                         </button> *@
@*                                         <button type="button" class="btn btn-outline-light" id="quickNextPage"> *@
@*                                             <i class="fas fa-chevron-right"></i> *@
@*                                         </button> *@
@*                                     </div> *@
@*                                 </div> *@
@*                             </div> *@
@*                         </div> *@
@*                     </div> *@

@*                     <!-- Controls Sidebar --> *@
@*                     <div class="controls-sidebar border-start" style="width: 40%; background: #ffffff; overflow-y: auto;"> *@
@*                         <div id="pdfControls" style="display: none;"> *@
@*                             <!-- Page Controls --> *@
@*                             <div class="p-3 border-bottom bg-light"> *@
@*                                 <h6 class="mb-3"> *@
@*                                     <i class="fas fa-cogs me-2"></i>Page Controls *@
@*                                 </h6> *@
@*                                 <div class="row g-3"> *@
@*                                     <div class="col-8"> *@
@*                                         <div class="d-flex align-items-center"> *@
@*                                             <button id="prevPage" class="btn btn-outline-primary btn-sm me-2"> *@
@*                                                 <i class="fas fa-chevron-left"></i> Prev *@
@*                                             </button> *@
@*                                             <div class="input-group input-group-sm flex-grow-1 me-2"> *@
@*                                                 <input type="number" id="pageNumInput" class="form-control text-center" min="1" value="1"> *@
@*                                                 <span class="input-group-text">/ <span id="page_count">1</span></span> *@
@*                                             </div> *@
@*                                             <button id="nextPage" class="btn btn-outline-primary btn-sm"> *@
@*                                                 Next <i class="fas fa-chevron-right"></i> *@
@*                                             </button> *@
@*                                         </div> *@
@*                                     </div> *@
@*                                     <div class="col-4 text-end"> *@
@*                                         <div class="text-muted small">Page</div> *@
@*                                         <div class="fw-bold" id="currentPageInfo">1</div> *@
@*                                     </div> *@
@*                                 </div> *@
@*                             </div> *@

@*                             <!-- Orientation & Rotation Controls --> *@
@*                             <div class="p-3 border-bottom"> *@
@*                                 <h6 class="mb-3"> *@
@*                                     <i class="fas fa-compress-alt me-2"></i>Page Orientation & Rotation *@
@*                                 </h6> *@
@*                                 <div class="alert alert-info border-0 small mb-3"> *@
@*                                     <i class="fas fa-info-circle me-1"></i> *@
@*                                     Set orientation for current page • Content will rotate with page *@
@*                                 </div> *@
@*                                 <div class="btn-group btn-group-sm w-100 mb-2"> *@
@*                                     <button type="button" class="btn btn-outline-success orientation-btn active flex-grow-1" *@
@*                                             data-orientation="portrait"> *@
@*                                         <i class="fas fa-portrait me-1"></i>Portrait *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-warning orientation-btn flex-grow-1" *@
@*                                             data-orientation="landscape"> *@
@*                                         <i class="fas fa-landscape me-1"></i>Landscape *@
@*                                     </button> *@
@*                                 </div> *@
@*                                 <div class="btn-group btn-group-sm w-100 mb-2"> *@
@*                                     <button type="button" class="btn btn-outline-warning rotate-btn flex-grow-1" data-rotation="-90"> *@
@*                                         <i class="fas fa-undo me-1"></i>Rotate Left *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="90"> *@
@*                                         <i class="fas fa-redo me-1"></i>Rotate Right *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="180"> *@
@*                                         <i class="fas fa-sync-alt me-1"></i>Flip *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-secondary rotate-btn flex-grow-1" id="resetRotation"> *@
@*                                         <i class="fas fa-history me-1"></i>Reset *@
@*                                     </button> *@
@*                                 </div> *@
@*                                 <div class="d-flex gap-2"> *@
@*                                     <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllPortrait"> *@
@*                                         <i class="fas fa-copy me-1"></i>Apply Portrait to All *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllLandscape"> *@
@*                                         <i class="fas fa-copy me-1"></i>Apply Landscape to All *@
@*                                     </button> *@
@*                                 </div> *@
@*                             </div> *@

@*                             <!-- Page Thumbnails --> *@
@*                             <div class="p-3"> *@
@*                                 <div class="d-flex justify-content-between align-items-center mb-3"> *@
@*                                     <h6 class="mb-0"> *@
@*                                         <i class="fas fa-images me-2"></i>Page Thumbnails *@
@*                                         <small class="text-muted">(Drag to reorder)</small> *@
@*                                     </h6> *@
@*                                     <div> *@
@*                                         <span class="badge bg-primary" id="visiblePagesCount">0</span> *@
@*                                     </div> *@
@*                                 </div> *@
@*                                 <div class="alert alert-info border-0 small mb-3"> *@
@*                                     <i class="fas fa-info-circle me-1"></i> *@
@*                                     Drag thumbnails to reorder pages • Click × to remove pages *@
@*                                 </div> *@
@*                                 <div id="thumbnailContainer" class="row g-2 mb-3" style="max-height: 400px; overflow-y: auto;"></div> *@
@*                                 <div class="d-flex gap-2"> *@
@*                                     <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="showAllPages"> *@
@*                                         <i class="fas fa-eye me-1"></i>Show All *@
@*                                     </button> *@
@*                                     <button type="button" class="btn btn-outline-danger btn-sm flex-grow-1" id="removeAllPages"> *@
@*                                         <i class="fas fa-trash me-1"></i>Remove All *@
@*                                     </button> *@
@*                                 </div> *@
@*                             </div> *@
@*                         </div> *@
@*                     </div> *@
@*                 </div> *@
@*                 <div class="modal-footer"> *@
@*                     <div class="w-100 d-flex justify-content-between align-items-center"> *@
@*                         <div class="text-muted small"> *@
@*                             <div class="d-flex gap-3"> *@
@*                                 <span> *@
@*                                     <i class="fas fa-copy me-1"></i> *@
@*                                     Total Pages: <span id="totalPagesCount">0</span> *@
@*                                 </span> *@
@*                                 <span> *@
@*                                     <i class="fas fa-eye me-1"></i> *@
@*                                     Visible: <span id="visiblePagesDisplay">0</span> *@
@*                                 </span> *@
@*                                 <span> *@
@*                                     <i class="fas fa-compress-alt me-1"></i> *@
@*                                     <span id="orientationSummary">Portrait: 0, Landscape: 0</span> *@
@*                                 </span> *@
@*                             </div> *@
@*                         </div> *@
@*                         <div class="d-flex"> *@
@*                             <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal"> *@
@*                                 <i class="fas fa-times me-1"></i>Close *@
@*                             </button> *@
@*                             <button type="button" id="downloadFinalPdfBtn" class="btn btn-success"> *@
@*                                 <i class="fas fa-download me-1"></i>Download PDF *@
@*                             </button> *@
@*                         </div> *@
@*                     </div> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*     </div> *@

@*     <!-- Summary Cards --> *@
@*     <div class="row g-4 mb-4"> *@
@*         <div class="col-md-3"> *@
@*             <div class="card border-0 shadow-sm h-100"> *@
@*                 <div class="card-body text-center p-4"> *@
@*                     <div class="text-primary mb-3"> *@
@*                         <i class="fas fa-layer-group fs-1"></i> *@
@*                     </div> *@
@*                     <h3 class="fw-bold text-dark mb-1">@Model.FileSelections.Count</h3> *@
@*                     <p class="text-muted mb-0">Total Sheets</p> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*         <div class="col-md-3"> *@
@*             <div class="card border-0 shadow-sm h-100"> *@
@*                 <div class="card-body text-center p-4"> *@
@*                     <div class="text-danger mb-3"> *@
@*                         <i class="fas fa-exclamation-triangle fs-1"></i> *@
@*                     </div> *@
@*                     <h3 class="fw-bold text-dark mb-1">@Model.AllNameErrors.Count</h3> *@
@*                     <p class="text-muted mb-0">#NAME? Errors</p> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*         <div class="col-md-3"> *@
@*             <div class="card border-0 shadow-sm h-100"> *@
@*                 <div class="card-body text-center p-4"> *@
@*                     <div class="text-success mb-3"> *@
@*                         <i class="fas fa-calendar-check fs-1"></i> *@
@*                     </div> *@
@*                     <h3 class="fw-bold text-dark mb-1">@Model.AllInvoiceDates.Count</h3> *@
@*                     <p class="text-muted mb-0">Invoice Dates</p> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*         <div class="col-md-3"> *@
@*             <div class="card border-0 shadow-sm h-100"> *@
@*                 <div class="card-body text-center p-4"> *@
@*                     <div class="text-success mb-3"> *@
@*                         <i class="fas fa-check-circle fs-1"></i> *@
@*                     </div> *@
@*                     <h3 class="fw-bold text-dark mb-1" id="selectedSheetsCount">0</h3> *@
@*                     <p class="text-muted mb-0">Sheets Selected</p> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*     </div> *@


@*     <!-- Separate Error Sections --> *@
@*     @if (Model.HasNameErrors) *@
@*     { *@
@*         <div class="card border-0 shadow-sm mb-4"> *@
@*             <div class="card-header bg-danger text-white"> *@
@*                 <h5 class="mb-0"> *@
@*                     <i class="fas fa-exclamation-triangle me-2"></i>#NAME? Errors Found *@
@*                 </h5> *@
@*             </div> *@
@*             <div class="card-body"> *@
@*                 <div class="table-responsive"> *@
@*                     <table class="table table-bordered table-hover"> *@
@*                         <thead class="table-light"> *@
@*                             <tr> *@
@*                                 <th>Sheet Name</th> *@
@*                                 <th>Location</th> *@
@*                                 <th>Cell Reference</th> *@
@*                             </tr> *@
@*                         </thead> *@
@*                         <tbody> *@
@*                             @foreach (var error in Model.AllNameErrors) *@
@*                             { *@
@*                                 <tr> *@
@*                                     <td><strong>@error.SheetName</strong></td> *@
@*                                     <td>@error.FullLocation</td> *@
@*                                     <td><code>@error.Location</code></td> *@
@*                                 </tr> *@
@*                             } *@
@*                         </tbody> *@
@*                     </table> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*     } *@

@*     @if (Model.HasInvoiceDates) *@
@*     { *@
@*         <div class="card border-0 shadow-sm mb-4"> *@
@*             <div class="card-header  bg-danger text-white"> *@
@*                 <h5 class="mb-0"> *@
@*                     <i class="fas fa-calendar-check me-2"></i>Invoice Dates Found (@Model.AllInvoiceDates.Count) *@
@*                 </h5> *@
@*             </div> *@
@*             <div class="card-body"> *@
@*                 <div class="alert alert-info"> *@
@*                     <strong>Debug Info:</strong> Found @Model.AllInvoiceDates.Count invoice dates across all sheets. *@
@*                 </div> *@
@*                 <div class="table-responsive"> *@
@*                     <table class="table table-bordered table-hover"> *@
@*                         <thead class="table-light"> *@
@*                             <tr> *@
@*                                 <th>#</th> *@
@*                                 <th>Sheet Name</th> *@
@*                                 <th>Invoice Date Text</th> *@
@*                                 <th>Date Value</th> *@
@*                                 <th>Location</th> *@
@*                             </tr> *@
@*                         </thead> *@
@*                         <tbody> *@
@*                             @{ *@
@*                                 int counter = 1; *@
@*                             } *@
@*                             @foreach (var invoiceDate in Model.AllInvoiceDates) *@
@*                             { *@
@*                                 <tr> *@
@*                                     <td>@(counter++)</td> *@
@*                                     <td><strong>@invoiceDate.SheetName</strong></td> *@
@*                                     <td><code>@invoiceDate.InvoiceDateText</code></td> *@
@*                                     <td><strong class="text-danger">@invoiceDate.DateValue</strong></td> *@
@*                                     <td><code>@invoiceDate.Location</code></td> *@
@*                                 </tr> *@
@*                             } *@
@*                         </tbody> *@
@*                     </table> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*     } *@
@*     else *@
@*     { *@
@*         <div class="alert alert-warning"> *@
@*             <strong>No Invoice Dates Found:</strong> The system did not find any invoice dates in the Excel file. *@
@*             Console showed: Credit Note (1), Tax Invoice (1), AOC (1), working sheet (1) *@
@*         </div> *@
@*     } *@

@*     <!-- Sheet Selection --> *@
@*     <div class="card border-0 shadow-sm"> *@
@*         <div class="card-header bg-white py-3 border-bottom"> *@
@*             <div class="d-flex justify-content-between align-items-center"> *@
@*                 <h5 class="mb-0"> *@
@*                     <i class="fas fa-list-check text-primary me-2"></i>Sheet Selection & Ordering *@
@*                 </h5> *@
@*                 <div class="d-flex align-items-center gap-2"> *@
@*                     <div class="form-check"> *@
@*                         <input class="form-check-input" type="checkbox" id="selectAll" checked> *@
@*                         <label class="form-check-label small fw-bold" for="selectAll"> *@
@*                             Select All *@
@*                         </label> *@
@*                     </div> *@
@*                 </div> *@
@*             </div> *@
@*         </div> *@
@*         <div class="card-body p-0"> *@
@*             <div class="table-responsive"> *@
@*                 <table class="table table-hover mb-0" id="sheetSelectionTable"> *@
@*                     <thead class="table-light"> *@
@*                         <tr> *@
@*                             <th style="width: 60px;" class="text-center ps-4">#</th> *@
@*                             <th style="width: 60px;" class="text-center">Select</th> *@
@*                             <th>Sheet Name</th> *@
@*                             <th style="width: 120px;" class="text-center">#NAME? Errors</th> *@
@*                             <th style="width: 120px;" class="text-center">Invoice Dates</th> *@
@*                         </tr> *@
@*                     </thead> *@
@*                     <tbody id="sortable"> *@
@*                         @foreach (var file in Model.FileSelections.OrderBy(f => f.SortOrder)) *@
@*                         { *@
@*                             <tr data-sheet="@file.SheetName" data-order="@file.SortOrder" class="sortable-row"> *@
@*                                 <td class="text-center align-middle ps-4"> *@
@*                                     <div class="d-flex align-items-center justify-content-center"> *@
@*                                         <div class="drag-handle me-2" style="cursor: grab;"> *@
@*                                             <i class="fas fa-grip-vertical text-muted"></i> *@
@*                                         </div> *@
@*                                         <span class="order-badge badge bg-primary rounded-pill">@(file.SortOrder + 1)</span> *@
@*                                     </div> *@
@*                                 </td> *@
@*                                 <td class="text-center align-middle"> *@
@*                                     <input type="checkbox" name="selectedSheets" value="@file.SheetName" *@
@*                                     @(file.IsSelected ? "checked" : "") *@
@*                                            class="sheet-checkbox form-check-input"> *@
@*                                 </td> *@
@*                                 <td class="align-middle"> *@
@*                                     <div class="d-flex align-items-center"> *@
@*                                         <i class="fas fa-table text-muted me-2"></i> *@
@*                                         <strong>@file.SheetName</strong> *@
@*                                     </div> *@
@*                                 </td> *@
@*                                 <td class="text-center align-middle"> *@
@*                                     @if (file.HasNameErrors) *@
@*                                     { *@
@*                                         <span class="badge bg-danger rounded-pill"> *@
@*                                             @file.NameErrors.Count *@
@*                                         </span> *@
@*                                     } *@
@*                                     else *@
@*                                     { *@
@*                                         <span class="badge bg-success rounded-pill">0</span> *@
@*                                     } *@
@*                                 </td> *@
@*                                 <td class="text-center align-middle"> *@
@*                                     @if (file.HasInvoiceDates) *@
@*                                     { *@
@*                                         <span class="badge bg-success rounded-pill"> *@
@*                                             @file.InvoiceDates.Count *@
@*                                         </span> *@
@*                                     } *@
@*                                     else *@
@*                                     { *@
@*                                         <span class="badge bg-secondary rounded-pill">0</span> *@
@*                                     } *@
@*                                 </td> *@
@*                             </tr> *@
@*                         } *@
@*                     </tbody> *@
@*                 </table> *@
@*             </div> *@
@*         </div> *@
@*     </div> *@
@* </div> *@

@* @section Scripts { *@
@*     <script> *@
@*            document.addEventListener('DOMContentLoaded', function() { *@
@*                const sessionId = '@Model.SessionId'; *@
@*                const convertBtn = document.getElementById('convertBtn'); *@
@*                const selectAllCheckbox = document.getElementById('selectAll'); *@
@*                const sheetCheckboxes = document.querySelectorAll('.sheet-checkbox'); *@
@*                const selectedSheetsCount = document.getElementById('selectedSheetsCount'); *@

@*                // PDF Preview Variables *@
@*                const pdfPreviewBtn = document.getElementById('pdfPreviewBtn'); *@
@*                const pdfPreviewModal = new bootstrap.Modal(document.getElementById('pdfPreviewModal')); *@
@*                const pdfPreviewContainer = document.getElementById('pdfPreviewContainer'); *@
@*                const pdfControls = document.getElementById('pdfControls'); *@
@*                const downloadFinalPdfBtn = document.getElementById('downloadFinalPdfBtn'); *@
@*                const pageNumInput = document.getElementById('pageNumInput'); *@
@*                const pageCountSpan = document.getElementById('page_count'); *@
@*                const currentPageInfo = document.getElementById('currentPageInfo'); *@
@*                const totalPagesCount = document.getElementById('totalPagesCount'); *@
@*                const totalPagesDisplay2 = document.getElementById('totalPagesDisplay2'); *@
@*                const currentPageDisplay = document.getElementById('currentPageDisplay'); *@
@*                const orientationDisplay = document.getElementById('orientationDisplay'); *@
@*                const rotationDisplay = document.getElementById('rotationDisplay'); *@
@*                const pageCountBadge = document.getElementById('pageCountBadge'); *@
@*                const visiblePagesCount = document.getElementById('visiblePagesCount'); *@
@*                const visiblePagesDisplay = document.getElementById('visiblePagesDisplay'); *@
@*                const pageInfoBar = document.getElementById('pageInfoBar'); *@
@*                const thumbnailContainer = document.getElementById('thumbnailContainer'); *@
@*                const showAllPages = document.getElementById('showAllPages'); *@
@*                const removeAllPages = document.getElementById('removeAllPages'); *@
@*                const quickPrevPage = document.getElementById('quickPrevPage'); *@
@*                const quickNextPage = document.getElementById('quickNextPage'); *@
@*                const prevPage = document.getElementById('prevPage'); *@
@*                const nextPage = document.getElementById('nextPage'); *@
@*                const applyToAllPortrait = document.getElementById('applyToAllPortrait'); *@
@*                const applyToAllLandscape = document.getElementById('applyToAllLandscape'); *@
@*                const orientationSummary = document.getElementById('orientationSummary'); *@

@*                let pdfDoc = null; *@
@*                let pageNum = 1; *@
@*                let pageRendering = false; *@
@*                let pageNumPending = null; *@
@*                let currentOrientations = {}; *@
@*                let currentRotations = {}; *@
@*                let currentPdfUrl = null; *@
@*                let pageOrder = []; *@
@*                let thumbnailSortable = null; *@
@*                let pdfData = null; *@
@*                let pdfFileName = ""; *@

@*                // PDF Upload Variables *@
@*                const mergePdfBtn = document.getElementById('mergePdfBtn'); *@
@*                const pdfUploadSection = document.getElementById('pdfUploadSection'); *@
@*                const pdfFileInput = document.getElementById('PdfFiles'); *@
@*                const pdfFileUploadArea = document.getElementById('pdfFileUploadArea'); *@
@*                const uploadedFilesContainer = document.getElementById('uploadedFilesContainer'); *@
@*                const uploadedFilesList = document.getElementById('uploadedFilesList'); *@
@*                const pdfFileNames = document.getElementById('pdfFileNames'); *@
@*                const cancelUploadBtn = document.getElementById('cancelUploadBtn'); *@
@*                const mergeUploadedPdfsBtn = document.getElementById('mergeUploadedPdfsBtn'); *@
@*                const mergedPdfSection = document.getElementById('mergedPdfSection'); *@
@*                const mergedPdfList = document.getElementById('mergedPdfList'); *@

@*                let uploadedPdfs = []; *@
@*                let mergedPdfs = []; *@


@*                function validateBeforeConversion() { *@
@*     // ✅ TESTING KE LIYE: Agar aap validation bypass karna chahte hain, to *@
@*     // niche wali line ko true return karein aur comment remove karein *@
@*     // return true; // UNCOMMENT KAREIN TESTING KE LIYE *@

@*     let hasNameErrors = @Json.Serialize(Model.HasNameErrors); *@
@*     let hasInvoiceDates = @Json.Serialize(Model.HasInvoiceDates); *@
@*     let allInvoiceDates = @Json.Serialize(Model.AllInvoiceDates); *@

@*     console.log("=== VALIDATION CHECK ==="); *@
@*     console.log("- Has Name Errors:", hasNameErrors); *@
@*     console.log("- Has Invoice Dates:", hasInvoiceDates); *@
@*     console.log("- All Invoice Dates:", allInvoiceDates); *@

@*     // Check for #NAME? errors *@
@*     if (hasNameErrors) { *@
@*         showValidationError("Please fix all #NAME? errors before converting to PDF."); *@
@*         return false; *@
@*     } *@

@*     // Check for invoice date mismatches *@
@*     if (hasInvoiceDates && allInvoiceDates && allInvoiceDates.length > 0) { *@
@*         let hasMismatch = checkInvoiceDateMismatches(allInvoiceDates); *@
@*         if (hasMismatch) { *@
@*             showValidationError("Please fix Invoice Date mismatches before converting to PDF."); *@
@*             return false; *@
@*         } *@
@*     } *@

@*     console.log("✅ Validation passed - no errors found"); *@
@*     return true; *@
@* } *@

@* // ✅ Check for Invoice Date mismatches - IMPROVED VERSION *@
@* function checkInvoiceDateMismatches(invoiceDates) { *@
@*     console.log("Checking invoice date mismatches..."); *@

@*     let hasMismatch = false; *@
@*     let parsedDates = []; *@

@*     // Collect all date values and parse them *@
@*     invoiceDates.forEach(invoiceDate => { *@
@*         if (invoiceDate.dateValue && invoiceDate.dateValue.trim() !== '') { *@
@*             const parsedDate = parseDateString(invoiceDate.dateValue.trim()); *@
@*             if (parsedDate) { *@
@*                 parsedDates.push({ *@
@*                     originalText: invoiceDate.dateValue.trim(), *@
@*                     parsedDate: parsedDate, *@
@*                     sheet: invoiceDate.sheetName, *@
@*                     location: invoiceDate.location *@
@*                 }); *@
@*             } *@
@*         } *@
@*     }); *@

@*     console.log("Parsed dates found:", parsedDates); *@

@*     // Check if all parsed dates are same *@
@*     if (parsedDates.length > 1) { *@
@*         const firstParsedDate = parsedDates[0].parsedDate; *@
        
@*         // Compare using timestamp for exact match *@
@*         const allSame = parsedDates.every(item =>  *@
@*             item.parsedDate.getTime() === firstParsedDate.getTime() *@
@*         ); *@

@*         if (!allSame) { *@
@*             console.log("❌ Date mismatch found!"); *@
@*             hasMismatch = true; *@

@*             // Show detailed mismatch info *@
@*             showDateMismatchDetailsImproved(parsedDates); *@
@*         } else { *@
@*             console.log("✅ All invoice dates are same (different formats, same date)"); *@
@*         } *@
@*     } else if (parsedDates.length === 1) { *@
@*         console.log("✅ Only one invoice date found - no mismatch possible"); *@
@*     } else { *@
@*         console.log("ℹ️ No invoice date values found"); *@
@*     } *@

@*     return hasMismatch; *@
@* } *@

@* // ✅ Parse date string in different formats *@
@* function parseDateString(dateString) { *@
@*     console.log(`Parsing date: "${dateString}"`); *@
    
@*     // Try multiple date formats *@
@*     const dateFormats = [ *@
@*         // Tuesday, 2 December, 2025 *@
@*         /^([A-Za-z]+),\s*(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i, *@
@*         // Tuesday, December 2, 2025 *@
@*         /^([A-Za-z]+),\s*([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i, *@
@*         // 2 December, 2025 *@
@*         /^(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i, *@
@*         // December 2, 2025 *@
@*         /^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i, *@
@*         // 2025-12-02 *@
@*         /^(\d{4})-(\d{1,2})-(\d{1,2})$/, *@
@*         // 12/02/2025 or 02/12/2025 *@
@*         /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, *@
@*         // 2-Dec-2025 *@
@*         /^(\d{1,2})-([A-Za-z]+)-(\d{4})$/i, *@
@*         // 02 Dec 2025 *@
@*         /^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i *@
@*     ]; *@

@*     for (const format of dateFormats) { *@
@*         const match = dateString.match(format); *@
@*         if (match) { *@
@*             console.log(`Matched format: ${format}`); *@
            
@*             let day, month, year; *@
            
@*             if (format === dateFormats[0]) { // Tuesday, 2 December, 2025 *@
@*                 day = parseInt(match[2]); *@
@*                 month = getMonthNumber(match[3]); *@
@*                 year = parseInt(match[4]); *@
@*             } else if (format === dateFormats[1]) { // Tuesday, December 2, 2025 *@
@*                 day = parseInt(match[3]); *@
@*                 month = getMonthNumber(match[2]); *@
@*                 year = parseInt(match[4]); *@
@*             } else if (format === dateFormats[2]) { // 2 December, 2025 *@
@*                 day = parseInt(match[1]); *@
@*                 month = getMonthNumber(match[2]); *@
@*                 year = parseInt(match[3]); *@
@*             } else if (format === dateFormats[3]) { // December 2, 2025 *@
@*                 day = parseInt(match[2]); *@
@*                 month = getMonthNumber(match[1]); *@
@*                 year = parseInt(match[3]); *@
@*             } else if (format === dateFormats[4]) { // 2025-12-02 *@
@*                 year = parseInt(match[1]); *@
@*                 month = parseInt(match[2]); *@
@*                 day = parseInt(match[3]); *@
@*             } else if (format === dateFormats[5]) { // MM/DD/YYYY or DD/MM/YYYY *@
@*                 // Try both interpretations *@
@*                 const monthCandidate = parseInt(match[1]); *@
@*                 const dayCandidate = parseInt(match[2]); *@
@*                 year = parseInt(match[3]); *@
                
@*                 // Check which makes sense (month should be 1-12) *@
@*                 if (monthCandidate >= 1 && monthCandidate <= 12) { *@
@*                     month = monthCandidate; *@
@*                     day = dayCandidate; *@
@*                 } else { *@
@*                     month = dayCandidate; *@
@*                     day = monthCandidate; *@
@*                 } *@
@*             } else if (format === dateFormats[6]) { // 2-Dec-2025 *@
@*                 day = parseInt(match[1]); *@
@*                 month = getMonthNumber(match[2]); *@
@*                 year = parseInt(match[3]); *@
@*             } else if (format === dateFormats[7]) { // 02 Dec 2025 *@
@*                 day = parseInt(match[1]); *@
@*                 month = getMonthNumber(match[2]); *@
@*                 year = parseInt(match[3]); *@
@*             } *@
            
@*             if (month && day && year) { *@
@*                 const parsedDate = new Date(year, month - 1, day); *@
@*                 console.log(`Successfully parsed: ${parsedDate}`); *@
@*                 return parsedDate; *@
@*             } *@
@*         } *@
@*     } *@
    
@*     // Try native Date.parse as fallback *@
@*     const parsed = Date.parse(dateString); *@
@*     if (!isNaN(parsed)) { *@
@*         console.log(`Parsed using Date.parse: ${new Date(parsed)}`); *@
@*         return new Date(parsed); *@
@*     } *@
    
@*     console.log(`❌ Could not parse date: "${dateString}"`); *@
@*     return null; *@
@* } *@

@* // ✅ Convert month name to month number *@
@* function getMonthNumber(monthName) { *@
@*     const months = { *@
@*         'january': 1, 'jan': 1, *@
@*         'february': 2, 'feb': 2, *@
@*         'march': 3, 'mar': 3, *@
@*         'april': 4, 'apr': 4, *@
@*         'may': 5, *@
@*         'june': 6, 'jun': 6, *@
@*         'july': 7, 'jul': 7, *@
@*         'august': 8, 'aug': 8, *@
@*         'september': 9, 'sep': 9, *@
@*         'october': 10, 'oct': 10, *@
@*         'november': 11, 'nov': 11, *@
@*         'december': 12, 'dec': 12 *@
@*     }; *@
    
@*     return months[monthName.toLowerCase()] || null; *@
@* } *@

@* // ✅ Show detailed date mismatch information - IMPROVED *@
@* function showDateMismatchDetailsImproved(parsedDates) { *@
@*     let dateGroups = {}; *@
    
@*     parsedDates.forEach(item => { *@
@*         const dateKey = item.parsedDate.toDateString(); // e.g., "Tue Dec 02 2025" *@
@*         if (!dateGroups[dateKey]) { *@
@*             dateGroups[dateKey] = []; *@
@*         } *@
@*         dateGroups[dateKey].push({ *@
@*             sheet: item.sheet, *@
@*             location: item.location, *@
@*             originalText: item.originalText, *@
@*             formattedDate: item.parsedDate.toLocaleDateString('en-US', {  *@
@*                 weekday: 'long',  *@
@*                 year: 'numeric',  *@
@*                 month: 'long',  *@
@*                 day: 'numeric'  *@
@*             }) *@
@*         }); *@
@*     }); *@
    
@*     console.log("Date Groups:", dateGroups); *@
    
@*     // Show user-friendly error with date groups *@
@*     if (Object.keys(dateGroups).length > 1) { *@
@*         let errorHTML = ` *@
@*             <div class="text-start"> *@
@*                 <h5 class="text-danger mb-3">❌ Invoice Date Mismatch Found</h5> *@
@*                 <p class="mb-3">Different invoice dates found in sheets:</p> *@
@*                 <div class="alert alert-warning border-0"> *@
@*         `; *@
        
@*         let groupCounter = 1; *@
@*         for (const [dateKey, sheets] of Object.entries(dateGroups)) { *@
@*             const dateObj = new Date(dateKey); *@
@*             const formattedDate = dateObj.toLocaleDateString('en-US', {  *@
@*                 weekday: 'long',  *@
@*                 year: 'numeric',  *@
@*                 month: 'long',  *@
@*                 day: 'numeric'  *@
@*             }); *@
            
@*             errorHTML += ` *@
@*                 <div class="mb-3"> *@
@*                     <strong>Date Group ${groupCounter}: ${formattedDate}</strong> *@
@*                     <ul class="mb-0 mt-1"> *@
@*             `; *@
            
@*             sheets.forEach(sheet => { *@
@*                 errorHTML += ` *@
@*                     <li> *@
@*                         <strong>${sheet.sheet}</strong>  *@
@*                         (${sheet.location}):  *@
@*                         <code>${sheet.originalText}</code> *@
@*                     </li> *@
@*                 `; *@
@*             }); *@
            
@*             errorHTML += ` *@
@*                     </ul> *@
@*                 </div> *@
@*             `; *@
@*             groupCounter++; *@
@*         } *@
        
@*         errorHTML += ` *@
@*                 </div> *@
@*                 <p class="text-muted mt-3"> *@
@*                     <i class="fas fa-info-circle me-1"></i> *@
@*                     All invoice dates must have the same date value (format can be different). *@
@*                 </p> *@
@*             </div> *@
@*         `; *@
        
@*         // Update the showValidationError to use this HTML *@
@*         Swal.fire({ *@
@*             icon: 'error', *@
@*             title: 'Invoice Date Mismatch', *@
@*             html: errorHTML, *@
@*             confirmButtonText: 'OK', *@
@*             confirmButtonColor: '#dc3545', *@
@*             backdrop: true, *@
@*             allowOutsideClick: false, *@
@*             width: '800px' *@
@*         }); *@
@*     } *@
@* } *@

@* // ✅ Show validation error *@
@* function showValidationError(message) { *@
@*     Swal.fire({ *@
@*         icon: 'error', *@
@*         title: 'Validation Failed', *@
@*         html: ` *@
@*             <div class="text-start"> *@
@*                 <h5 class="text-danger mb-3">❌ Cannot Convert to PDF</h5> *@
@*                 <p class="mb-3">${message}</p> *@
@*                 <div class="alert alert-warning border-0"> *@
@*                     <i class="fas fa-exclamation-triangle me-2"></i> *@
@*                     <strong>Please fix these issues:</strong> *@
@*                     <ul class="mb-0 mt-2"> *@
@*                         ${message.includes('#NAME?') ? '<li>Fix all #NAME? formula errors in Excel file</li>' : ''} *@
@*                         ${message.includes('Invoice Date') ? '<li>Ensure all Invoice Dates have the same value</li>' : ''} *@
@*                     </ul> *@
@*                 </div> *@
@*             </div> *@
@*         `, *@
@*         confirmButtonText: 'OK', *@
@*         confirmButtonColor: '#dc3545', *@
@*         backdrop: true, *@
@*         allowOutsideClick: false *@
@*     }); *@
@* } *@

@*                // PDF Upload Functionality *@
@*                mergePdfBtn.addEventListener('click', function() { *@
@*                    // ✅ Validation check pehle *@
@*     if (!validateBeforeConversion()) { *@
@*         return; // Validation fail hone par return kar do *@
@*     } *@

@*                    pdfUploadSection.style.display = 'block'; *@
@*                    mergedPdfSection.style.display = 'block'; *@
@*                    this.style.display = 'none'; *@
@*                    updateMergedPdfList(); *@
@*                }); *@

@*                cancelUploadBtn.addEventListener('click', function() { *@
@*                    pdfUploadSection.style.display = 'none'; *@
@*                    mergePdfBtn.style.display = 'block'; *@
@*                }); *@

@*                // File input change *@
@*                pdfFileInput.addEventListener('change', function(e) { *@
@*                    const files = Array.from(e.target.files); *@
@*                    handlePdfFiles(files); *@
@*                }); *@

@*                // Drag and drop functionality *@
@*                pdfFileUploadArea.addEventListener('dragover', function(e) { *@
@*                    e.preventDefault(); *@
@*                    e.stopPropagation(); *@
@*                    pdfFileUploadArea.classList.add('drag-over'); *@
@*                    pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10'); *@
@*                }); *@

@*                pdfFileUploadArea.addEventListener('dragenter', function(e) { *@
@*                    e.preventDefault(); *@
@*                    e.stopPropagation(); *@
@*                    pdfFileUploadArea.classList.add('drag-over'); *@
@*                    pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10'); *@
@*                }); *@

@*                pdfFileUploadArea.addEventListener('dragleave', function(e) { *@
@*                    e.preventDefault(); *@
@*                    e.stopPropagation(); *@

@*                    const relatedTarget = e.relatedTarget; *@
@*                    if (!pdfFileUploadArea.contains(relatedTarget)) { *@
@*                        pdfFileUploadArea.classList.remove('drag-over'); *@
@*                        pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10'); *@
@*                    } *@
@*                }); *@

@*                pdfFileUploadArea.addEventListener('drop', function(e) { *@
@*                    e.preventDefault(); *@
@*                    e.stopPropagation(); *@

@*                    pdfFileUploadArea.classList.remove('drag-over'); *@
@*                    pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10'); *@

@*                    const files = Array.from(e.dataTransfer.files).filter(file => *@
@*                        file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf') *@
@*                    ); *@

@*                    if (files.length > 0) { *@
@*                        handlePdfFiles(files); *@
@*                    } else { *@
@*                        showError('Please drop PDF files only.'); *@
@*                    } *@
@*                }); *@

@*                // File upload area click *@
@*                pdfFileUploadArea.addEventListener('click', function(e) { *@
@*                    if (e.target === pdfFileUploadArea || !e.target.closest('label')) { *@
@*                        pdfFileInput.click(); *@
@*                    } *@
@*                }); *@

@*                function handlePdfFiles(files) { *@
@*                    let validFiles = []; *@
@*                    let invalidFiles = []; *@

@*                    files.forEach(file => { *@
@*                        if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) { *@
@*                            if (file.size <= 50 * 1024 * 1024) { // 50MB limit *@
@*                                validFiles.push(file); *@
@*                            } else { *@
@*                                invalidFiles.push(`${file.name} (File too large)`); *@
@*                            } *@
@*                        } else { *@
@*                            invalidFiles.push(`${file.name} (Not a PDF)`); *@
@*                        } *@
@*                    }); *@

@*                    if (invalidFiles.length > 0) { *@
@*                        showError(`Invalid files:\n${invalidFiles.join('\n')}`); *@
@*                    } *@

@*                    if (validFiles.length > 0) { *@
@*                        uploadPdfFiles(validFiles); *@
@*                    } *@
@*                } *@

@*                async function uploadPdfFiles(files) { *@
@*                    const formData = new FormData(); *@
@*                    files.forEach(file => { *@
@*                        formData.append('pdfFiles', file); *@
@*                    }); *@

@*                    formData.append('sessionId', sessionId); *@

@*                    try { *@
@*                        const response = await fetch('@Url.Action("UploadPdfFiles", "Home")', { *@
@*                            method: 'POST', *@
@*                            body: formData, *@
@*                            headers: { *@
@*                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                            } *@
@*                        }); *@

@*                        const result = await response.json(); *@
@*                        if (result.success) { *@
@*                            uploadedPdfs = result.uploadedFiles; *@
@*                            updateUploadedFilesList(); *@
@*                            showSuccess(`${files.length} PDF file(s) uploaded successfully`); *@
@*                        } else { *@
@*                            showError(result.message); *@
@*                        } *@
@*                    } catch (error) { *@
@*                        console.error('Error uploading PDF files:', error); *@
@*                        showError('Error uploading files: ' + error.message); *@
@*                    } *@
@*                } *@

@*                function updateUploadedFilesList() { *@
@*                    uploadedFilesContainer.innerHTML = ''; *@

@*                    if (uploadedPdfs.length === 0) { *@
@*                        uploadedFilesList.style.display = 'none'; *@
@*                        return; *@
@*                    } *@

@*                    uploadedFilesList.style.display = 'block'; *@
@*                    pdfFileNames.textContent = `${uploadedPdfs.length} PDF file(s) selected`; *@

@*                    uploadedPdfs.forEach((pdf, index) => { *@
@*                        const listItem = document.createElement('div'); *@
@*                        listItem.className = 'list-group-item d-flex justify-content-between align-items-center'; *@
@*                        listItem.innerHTML = ` *@
@*                            <div class="d-flex align-items-center"> *@
@*                                <i class="fas fa-file-pdf text-danger me-3 fs-5"></i> *@
@*                                <div> *@
@*                                    <div class="fw-bold">${pdf.name}</div> *@
@*                                    <small class="text-muted">${(pdf.size / 1024).toFixed(2)} KB</small> *@
@*                                </div> *@
@*                            </div> *@
@*                            <button type="button" class="btn btn-sm btn-outline-danger remove-pdf-btn" data-index="${index}"> *@
@*                                <i class="fas fa-times"></i> *@
@*                            </button> *@
@*                        `; *@
@*                        uploadedFilesContainer.appendChild(listItem); *@
@*                    }); *@

@*                    // Add event listeners to remove buttons *@
@*                    document.querySelectorAll('.remove-pdf-btn').forEach(btn => { *@
@*                        btn.addEventListener('click', function() { *@
@*                            const index = parseInt(this.getAttribute('data-index')); *@
@*                            removePdfFile(index); *@
@*                        }); *@
@*                    }); *@
@*                } *@

@*                function removePdfFile(index) { *@
@*                    if (index >= 0 && index < uploadedPdfs.length) { *@
@*                        // Send request to remove file from server *@
@*                        fetch('@Url.Action("RemovePdfFile", "Home")', { *@
@*                            method: 'POST', *@
@*                            headers: { *@
@*                                'Content-Type': 'application/json', *@
@*                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                            }, *@
@*                            body: JSON.stringify({ *@
@*                                sessionId: sessionId, *@
@*                                fileName: uploadedPdfs[index].name *@
@*                            }) *@
@*                        }).then(response => response.json()) *@
@*                          .then(result => { *@
@*                              if (result.success) { *@
@*                                  uploadedPdfs.splice(index, 1); *@
@*                                  updateUploadedFilesList(); *@
@*                                  showSuccess('PDF file removed'); *@
@*                              } *@
@*                          }); *@
@*                    } *@
@*                } *@

@*                mergeUploadedPdfsBtn.addEventListener('click', async function() { *@
@*                    if (uploadedPdfs.length === 0) { *@
@*                        showError('Please upload PDF files first.'); *@
@*                        return; *@
@*                    } *@

@*                    this.disabled = true; *@
@*                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...'; *@

@*                    try { *@
@*                        const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', { *@
@*                            method: 'POST', *@
@*                            headers: { *@
@*                                'Content-Type': 'application/json', *@
@*                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                            }, *@
@*                            body: JSON.stringify({ *@
@*                                sessionId: sessionId *@
@*                            }) *@
@*                        }); *@

@*                        const result = await response.json(); *@
@*                        if (result.success) { *@
@*                            mergedPdfs.push({ *@
@*                                name: result.fileName, *@
@*                                size: result.fileSize, *@
@*                                pages: result.totalPages, *@
@*                                timestamp: new Date().toLocaleString() *@
@*                            }); *@

@*                            updateMergedPdfList(); *@
@*                            showSuccess(`PDF files merged successfully (${result.totalPages} pages)`); *@

@*                            // Hide upload section *@
@*                            pdfUploadSection.style.display = 'none'; *@
@*                        } else { *@
@*                            showError(result.message); *@
@*                        } *@
@*                    } catch (error) { *@
@*                        console.error('Error merging PDFs:', error); *@
@*                        showError('Error merging PDFs: ' + error.message); *@
@*                    } finally { *@
@*                        this.disabled = false; *@
@*                        this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs'; *@
@*                    } *@
@*                }); *@

@*                function updateMergedPdfList() { *@
@*                    mergedPdfList.innerHTML = ''; *@

@*                    if (mergedPdfs.length === 0) { *@
@*                        mergedPdfSection.style.display = 'none'; *@
@*                        return; *@
@*                    } *@

@*                    mergedPdfSection.style.display = 'block'; *@

@*                    mergedPdfs.forEach((pdf, index) => { *@
@*                        const listItem = document.createElement('div'); *@
@*                        listItem.className = 'list-group-item d-flex justify-content-between align-items-center'; *@
@*                        listItem.innerHTML = ` *@
@*                            <div class="d-flex align-items-center"> *@
@*                                <i class="fas fa-file-pdf text-success me-3 fs-5"></i> *@
@*                                <div> *@
@*                                    <div class="fw-bold">${pdf.name}</div> *@
@*                                    <div class="small text-muted"> *@
@*                                        <span>${pdf.pages} pages • ${(pdf.size / 1024).toFixed(2)} KB</span> *@
@*                                        <br> *@
@*                                        <span>Created: ${pdf.timestamp}</span> *@
@*                                    </div> *@
@*                                </div> *@
@*                            </div> *@
@*                            <div> *@
@*                                <button type="button" class="btn btn-sm btn-outline-primary download-merged-btn me-2" data-index="${index}"> *@
@*                                    <i class="fas fa-download"></i> *@
@*                                </button> *@
@*                                <button type="button" class="btn btn-sm btn-outline-danger remove-merged-btn" data-index="${index}"> *@
@*                                    <i class="fas fa-times"></i> *@
@*                                </button> *@
@*                            </div> *@
@*                        `; *@
@*                        mergedPdfList.appendChild(listItem); *@
@*                    }); *@

@*                    // Add event listeners *@
@*                    document.querySelectorAll('.download-merged-btn').forEach(btn => { *@
@*                        btn.addEventListener('click', function() { *@
@*                            const index = parseInt(this.getAttribute('data-index')); *@
@*                            downloadMergedPdf(index); *@
@*                        }); *@
@*                    }); *@

@*                    document.querySelectorAll('.remove-merged-btn').forEach(btn => { *@
@*                        btn.addEventListener('click', function() { *@
@*                            const index = parseInt(this.getAttribute('data-index')); *@
@*                            removeMergedPdf(index); *@
@*                        }); *@
@*                    }); *@
@*                } *@

@*                async function downloadMergedPdf(index) { *@
@*                    if (index >= 0 && index < mergedPdfs.length) { *@
@*                        try { *@
@*                            const response = await fetch('@Url.Action("DownloadMergedPdf", "Home")', { *@
@*                                method: 'POST', *@
@*                                headers: { *@
@*                                    'Content-Type': 'application/json', *@
@*                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                                }, *@
@*                                body: JSON.stringify({ *@
@*                                    sessionId: sessionId, *@
@*                                    fileName: mergedPdfs[index].name *@
@*                                }) *@
@*                            }); *@

@*                            const result = await response.json(); *@
@*                            if (result.success) { *@
@*                                // Create download link *@
@*                                const link = document.createElement('a'); *@
@*                                link.href = 'data:application/pdf;base64,' + result.pdfData; *@
@*                                link.download = result.fileName; *@
@*                                document.body.appendChild(link); *@
@*                                link.click(); *@
@*                                document.body.removeChild(link); *@
@*                            } *@
@*                        } catch (error) { *@
@*                            console.error('Error downloading merged PDF:', error); *@
@*                            showError('Error downloading PDF: ' + error.message); *@
@*                        } *@
@*                    } *@
@*                } *@

@*                async function removeMergedPdf(index) { *@
@*                    if (index >= 0 && index < mergedPdfs.length) { *@
@*                        try { *@
@*                            const response = await fetch('@Url.Action("RemoveMergedPdf", "Home")', { *@
@*                                method: 'POST', *@
@*                                headers: { *@
@*                                    'Content-Type': 'application/json', *@
@*                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                                }, *@
@*                                body: JSON.stringify({ *@
@*                                    sessionId: sessionId, *@
@*                                    fileName: mergedPdfs[index].name *@
@*                                }) *@
@*                            }); *@

@*                            const result = await response.json(); *@
@*                            if (result.success) { *@
@*                                mergedPdfs.splice(index, 1); *@
@*                                updateMergedPdfList(); *@
@*                                showSuccess('Merged PDF removed'); *@
@*                            } *@
@*                        } catch (error) { *@
@*                            console.error('Error removing merged PDF:', error); *@
@*                        } *@
@*                    } *@
@*                } *@


@*                pdfPreviewBtn.addEventListener('click', async function() { *@
@*                      // ✅ Validation check pehle *@
@*     if (!validateBeforeConversion()) { *@
@*         return; // Validation fail hone par return kar do *@
@*     } *@

@*     if (!sessionId) { *@
@*         showError('Session information not available.'); *@
@*         return; *@
@*     } *@

@*     const selectedSheets = getSelectedSheets(); *@
@*     if (selectedSheets.length === 0) { *@
@*         showError('Please select at least one sheet for PDF preview.'); *@
@*         return; *@
@*     } *@

@*     pdfPreviewBtn.disabled = true; *@
@*     pdfPreviewBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating PDF...'; *@

@*     try { *@
@*         // ✅ IMPORTANT: Get current page visibility, orientation and rotation *@
@*         const pageOrderData = []; *@
        
@*         if (pageOrder && pageOrder.length > 0) { *@
@*             // Use CURRENT page order with visibility *@
@*             pageOrder.forEach(p => { *@
@*                 pageOrderData.push({ *@
@*                     OriginalPage: p.originalPage, *@
@*                     CurrentOrder: p.currentOrder, *@
@*                     Visible: p.visible, // Current visibility *@
@*                     Orientation: p.orientation || 'portrait', *@
@*                     Rotation: p.rotation || 0 *@
@*                 }); *@
@*             }); *@
@*             console.log(`📊 Sending ${pageOrderData.length} pages to preview, visible: ${pageOrderData.filter(p => p.Visible).length}`); *@
@*         } else { *@
@*             console.log('ℹ️ No existing page order found'); *@
@*         } *@

@*                    const includeMergedPdfs = mergedPdfs && mergedPdfs.length > 0; *@
        
@*         // ✅ Call NEW API that applies ONLY FitToPage *@
@*         const result = await generatePdfPreviewWithFitToPage( *@
@*             sessionId,  *@
@*             selectedSheets, *@
@*                     pageOrderData.length > 0 ? pageOrderData : null, *@
@*             includeMergedPdfs); *@
            
@*         if (result.success) { *@
@*             pdfData = result.pdfData; *@
@*             pdfFileName = result.fileName; *@
            
@*             // Show modal and display PDF *@
@*             pdfPreviewModal.show(); *@
            
@*             // ✅ IMPORTANT: Load PDF but keep existing pageOrder *@
@*             // Don't reset pageOrder, orientation, rotation *@
@*             await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName); *@
            
@*             showSuccess('PDF generated with FitToPage applied!'); *@
@*         } else { *@
@*             showError(result.message || 'Failed to generate PDF preview.'); *@
@*         } *@
@*     } catch (error) { *@
@*         console.error('Error generating PDF preview:', error); *@
@*         showError('Error generating PDF preview: ' + error.message); *@
@*     } finally { *@
@*         pdfPreviewBtn.disabled = false; *@
@*         pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager'; *@
@*     } *@
@* }); *@


@* // ✅ NEW: API call for Preview with FitToPage *@
@* async function generatePdfPreviewWithFitToPage(sessionId, selectedSheets, pageOrderData, includeMergedPdfs = false) { *@
@*     // ✅ FIX: Handle null or undefined pageOrderData *@
@*     const formattedPageOrderData = pageOrderData  *@
@*         ? pageOrderData.map(p => ({ *@
@*             OriginalPage: p.originalPage || p.OriginalPage || 0, *@
@*             CurrentOrder: p.currentOrder || p.CurrentOrder || 0, *@
@*             Visible: p.visible !== undefined ? p.visible : (p.Visible !== undefined ? p.Visible : true), *@
@*             Orientation: p.orientation || p.Orientation || 'portrait', *@
@*             Rotation: p.rotation || p.Rotation || 0 *@
@*         })) *@
@*         : null; // Send null if no pageOrderData *@

@*     const requestBody = { *@
@*         sessionId: sessionId, *@
@*         selectedSheets: selectedSheets, *@
@*         includeMergedPdfs: includeMergedPdfs *@
@*     }; *@

@*     // Only add pageOrderData if it exists *@
@*     if (formattedPageOrderData) { *@
@*         requestBody.pageOrderData = formattedPageOrderData; *@
@*     } *@

@*     const response = await fetch('@Url.Action("GeneratePdfPreviewWithFitToPage", "Home")', { *@
@*         method: 'POST', *@
@*         headers: { *@
@*             'Content-Type': 'application/json', *@
@*             'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*         }, *@
@*         body: JSON.stringify(requestBody) *@
@*     }); *@

@*     return await response.json(); *@
@* } *@


@*         // ✅ NEW: Display PDF while keeping existing settings *@
@*         async function displayPdfPreviewWithExistingSettings(pdfData, fileName) { *@
@*             console.log('📱 Loading PDF with existing page settings...'); *@

@*             // Convert base64 to blob *@
@*             const byteCharacters = atob(pdfData); *@
@*             const byteNumbers = new Array(byteCharacters.length); *@
@*             for (let i = 0; i < byteCharacters.length; i++) { *@
@*                 byteNumbers[i] = byteCharacters.charCodeAt(i); *@
@*             } *@
@*             const byteArray = new Uint8Array(byteNumbers); *@
@*             const blob = new Blob([byteArray], { type: 'application/pdf' }); *@

@*             if (currentPdfUrl) { *@
@*                 URL.revokeObjectURL(currentPdfUrl); *@
@*             } *@
@*             currentPdfUrl = URL.createObjectURL(blob); *@

@*             pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; *@
@*             const loadingTask = pdfjsLib.getDocument(currentPdfUrl); *@

@*             try { *@
@*                 const pdfDoc_ = await loadingTask.promise; *@
@*                 pdfDoc = pdfDoc_; *@
@*                 const totalPages = pdfDoc.numPages; *@

@*                 console.log(`📊 PDF loaded: ${totalPages} pages`); *@

@*                 // ✅ FIX: Always initialize pageOrder when loading new PDF *@
@*                 // Don't rely on existing pageOrder - recreate it based on loaded PDF *@
@*                 pageOrder = []; *@
@*                 currentOrientations = {}; *@
@*                 currentRotations = {}; *@

@*                 for (let i = 1; i <= totalPages; i++) { *@
@*                     try { *@
@*                         const page = await pdfDoc.getPage(i); *@
@*                         const viewport = page.getViewport({ scale: 1.0 }); *@
@*                         const isLandscape = viewport.width > viewport.height; *@

@*                         currentOrientations[i] = isLandscape ? 'landscape' : 'portrait'; *@
@*                         currentRotations[i] = 0; *@

@*                         pageOrder.push({ *@
@*                             originalPage: i, *@
@*                             currentOrder: i, *@
@*                             orientation: isLandscape ? 'landscape' : 'portrait', *@
@*                             rotation: 0, *@
@*                             visible: true *@
@*                         }); *@
@*                     } catch (error) { *@
@*                         console.error(`Error loading page ${i}:`, error); *@
@*                         // Add default entry even if page load fails *@
@*                         pageOrder.push({ *@
@*                             originalPage: i, *@
@*                             currentOrder: i, *@
@*                             orientation: 'portrait', *@
@*                             rotation: 0, *@
@*                             visible: true *@
@*                         }); *@
@*                     } *@
@*                 } *@

@*                 console.log(`🆕 Initialized pageOrder with ${pageOrder.length} pages`); *@

@*                 // Update UI elements *@

@*                            // Update UI elements *@
@*                            pageCountSpan.textContent = totalPages; *@
@*                            totalPagesCount.textContent = totalPages; *@
@*                            totalPagesDisplay2.textContent = totalPages; *@
@*                            pageCountBadge.textContent = totalPages; *@
@*                            visiblePagesCount.textContent = totalPages; *@
@*                            visiblePagesDisplay.textContent = totalPages; *@
@*                            pageNumInput.max = totalPages; *@
@*                            pageNumInput.value = 1; *@
@*                            currentPageDisplay.textContent = '1'; *@
@*                            currentPageInfo.textContent = '1'; *@
@*                            rotationDisplay.textContent = '0°'; *@

@*                            // Set initial orientation display *@
@*                            updateOrientationDisplay(1); *@
@*                            updateOrientationSummary(); *@

@*                            pdfControls.style.display = 'block'; *@
@*                            pageInfoBar.style.display = 'block'; *@
@*                            downloadFinalPdfBtn.style.display = 'block'; *@

@*                            pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>'; *@

@*                            pageNum = 1; *@
@*                            await renderPage(pageNum); *@

@*                            await createThumbnails(); *@
@*                            initializeThumbnailSortable(); *@

@*                        } catch (error) { *@
@*                            console.error('Error loading PDF:', error); *@
@*                            pdfPreviewContainer.innerHTML = ` *@
@*                                <div class="alert alert-danger m-3"> *@
@*                                    <i class="fas fa-exclamation-triangle me-2"></i> *@
@*                                    Error loading PDF: ${error.message} *@
@*                                </div> *@
@*                            `; *@
@*                        } *@
@*         } *@

@*                // (All the PDF preview, rotation, orientation, and existing functionality) *@


@*                        async function displayPdfPreview(pdfData, fileName) { *@
@*                pdfPreviewContainer.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x text-white mb-3"></i><p class="text-white">Loading PDF...</p></div>'; *@
@*                thumbnailContainer.innerHTML = ''; *@
@*                pageOrder = []; *@
@*                currentOrientations = {}; *@
@*                currentRotations = {}; *@

@*                // Convert base64 to blob *@
@*                const byteCharacters = atob(pdfData); *@
@*                const byteNumbers = new Array(byteCharacters.length); *@
@*                for (let i = 0; i < byteCharacters.length; i++) { *@
@*                    byteNumbers[i] = byteCharacters.charCodeAt(i); *@
@*                } *@
@*                const byteArray = new Uint8Array(byteNumbers); *@
@*                const blob = new Blob([byteArray], { type: 'application/pdf' }); *@

@*                if (currentPdfUrl) { *@
@*                    URL.revokeObjectURL(currentPdfUrl); *@
@*                } *@
@*                currentPdfUrl = URL.createObjectURL(blob); *@

@*                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; *@
@*                const loadingTask = pdfjsLib.getDocument(currentPdfUrl); *@

@*                try { *@
@*                    const pdfDoc_ = await loadingTask.promise; *@
@*                    pdfDoc = pdfDoc_; *@
@*                    const totalPages = pdfDoc.numPages; *@

@*                    // Initialize page data with default orientations from PDF *@
@*                    pageOrder = []; *@
@*                    for (let i = 1; i <= totalPages; i++) { *@
@*                        const page = await pdfDoc.getPage(i); *@
@*                        const viewport = page.getViewport({ scale: 1.0 }); *@
@*                        const isLandscape = viewport.width > viewport.height; *@

@*                        currentOrientations[i] = isLandscape ? 'landscape' : 'portrait'; *@
@*                        currentRotations[i] = 0; *@

@*                        pageOrder.push({ *@
@*                            originalPage: i, *@
@*                            currentOrder: i, *@
@*                            orientation: isLandscape ? 'landscape' : 'portrait', *@
@*                            rotation: 0, *@
@*                            visible: true *@
@*                        }); *@
@*                    } *@

@*                    // Update UI elements *@
@*                    pageCountSpan.textContent = totalPages; *@
@*                    totalPagesCount.textContent = totalPages; *@
@*                    totalPagesDisplay2.textContent = totalPages; *@
@*                    pageCountBadge.textContent = totalPages; *@
@*                    visiblePagesCount.textContent = totalPages; *@
@*                    visiblePagesDisplay.textContent = totalPages; *@
@*                    pageNumInput.max = totalPages; *@
@*                    pageNumInput.value = 1; *@
@*                    currentPageDisplay.textContent = '1'; *@
@*                    currentPageInfo.textContent = '1'; *@
@*                    rotationDisplay.textContent = '0°'; *@

@*                    // Set initial orientation display *@
@*                    updateOrientationDisplay(1); *@
@*                    updateOrientationSummary(); *@

@*                    pdfControls.style.display = 'block'; *@
@*                    pageInfoBar.style.display = 'block'; *@
@*                    downloadFinalPdfBtn.style.display = 'block'; *@

@*                    pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>'; *@

@*                    pageNum = 1; *@
@*                    await renderPage(pageNum); *@

@*                    await createThumbnails(); *@
@*                    initializeThumbnailSortable(); *@

@*                } catch (error) { *@
@*                    console.error('Error loading PDF:', error); *@
@*                    pdfPreviewContainer.innerHTML = ` *@
@*                        <div class="alert alert-danger m-3"> *@
@*                            <i class="fas fa-exclamation-triangle me-2"></i> *@
@*                            Error loading PDF: ${error.message} *@
@*                        </div> *@
@*                    `; *@
@*                } *@
@*            } *@

@*            async function renderPage(num) { *@
@*                pageRendering = true; *@

@*                const pageData = pageOrder.find(p => p.originalPage === num && p.visible); *@
@*                if (!pageData) { *@
@*                    const nextVisible = pageOrder.find(p => p.visible && p.originalPage > num); *@
@*                    if (nextVisible) { *@
@*                        pageNum = nextVisible.originalPage; *@
@*                        queueRenderPage(pageNum); *@
@*                        return; *@
@*                    } *@
@*                } *@

@*                try { *@
@*                    const page = await pdfDoc.getPage(num); *@
@*                    const viewport = page.getViewport({ scale: 1.0 }); *@
@*                    const originalWidth = viewport.width; *@
@*                    const originalHeight = viewport.height; *@

@*                    // Get current orientation and rotation *@
@*                    const currentOrientation = currentOrientations[num] || 'portrait'; *@
@*                    const currentRotation = currentRotations[num] || 0; *@

@*                    // Create canvas *@
@*                    const canvas = document.createElement('canvas'); *@
@*                    const ctx = canvas.getContext('2d'); *@

@*                    // Calculate scale to fit container *@
@*                    const containerWidth = pdfPreviewContainer.clientWidth - 100; *@
@*                    const containerHeight = pdfPreviewContainer.clientHeight - 100; *@

@*                    // First, calculate scale without rotation *@
@*                    let baseScaleX = containerWidth / originalWidth; *@
@*                    let baseScaleY = containerHeight / originalHeight; *@
@*                    let baseScale = Math.min(baseScaleX, baseScaleY) * 0.9; // 90% of container *@

@*                    // Adjust for rotation - when rotated, dimensions change *@
@*                    let renderWidth, renderHeight; *@

@*                    if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) { *@
@*                        // If rotated 90° or 270°, width and height swap *@
@*                        renderWidth = originalHeight * baseScale; *@
@*                        renderHeight = originalWidth * baseScale; *@
@*                    } else { *@
@*                        // Normal orientation *@
@*                        renderWidth = originalWidth * baseScale; *@
@*                        renderHeight = originalHeight * baseScale; *@
@*                    } *@

@*                    // Now check if rotated content fits in container *@
@*                    let finalScale = baseScale; *@

@*                    if (currentRotation !== 0) { *@
@*                        // For rotation, we need to fit the bounding box of rotated content *@
@*                        const rotatedWidth = Math.abs(renderWidth * Math.cos(currentRotation * Math.PI / 180)) + *@
@*                                           Math.abs(renderHeight * Math.sin(currentRotation * Math.PI / 180)); *@
@*                        const rotatedHeight = Math.abs(renderWidth * Math.sin(currentRotation * Math.PI / 180)) + *@
@*                                            Math.abs(renderHeight * Math.cos(currentRotation * Math.PI / 180)); *@

@*                        const rotatedScaleX = containerWidth / rotatedWidth; *@
@*                        const rotatedScaleY = containerHeight / rotatedHeight; *@
@*                        finalScale = Math.min(rotatedScaleX, rotatedScaleY) * 0.9; *@
@*                    } *@

@*                    // Recalculate dimensions with final scale *@
@*                    if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) { *@
@*                        renderWidth = originalHeight * finalScale; *@
@*                        renderHeight = originalWidth * finalScale; *@
@*                    } else { *@
@*                        renderWidth = originalWidth * finalScale; *@
@*                        renderHeight = originalHeight * finalScale; *@
@*                    } *@

@*                    // Set canvas dimensions - make canvas larger to accommodate rotation *@
@*                    let canvasWidth = renderWidth; *@
@*                    let canvasHeight = renderHeight; *@

@*                    if (currentRotation !== 0) { *@
@*                        // Add padding for rotation to prevent clipping *@
@*                        const padding = 50; // Extra space for rotation *@
@*                        canvasWidth = renderWidth + padding * 2; *@
@*                        canvasHeight = renderHeight + padding * 2; *@
@*                    } *@

@*                    canvas.width = canvasWidth; *@
@*                    canvas.height = canvasHeight; *@

@*                    // Fill background *@
@*                    ctx.fillStyle = 'white'; *@
@*                    ctx.fillRect(0, 0, canvas.width, canvas.height); *@

@*                    // Save context state *@
@*                    ctx.save(); *@

@*                    // Translate to center of canvas *@
@*                    ctx.translate(canvas.width / 2, canvas.height / 2); *@

@*                    // Apply rotation *@
@*                    ctx.rotate(currentRotation * Math.PI / 180); *@

@*                    // Translate back to draw at center *@
@*                    ctx.translate(-renderWidth / 2, -renderHeight / 2); *@

@*                    // Create render context with final scale *@
@*                    const renderContext = { *@
@*                        canvasContext: ctx, *@
@*                        viewport: page.getViewport({ scale: finalScale }) *@
@*                    }; *@

@*                    await page.render(renderContext).promise; *@

@*                    // Restore context *@
@*                    ctx.restore(); *@

@*                    // Display the canvas *@
@*                    const container = document.getElementById('canvas-container'); *@
@*                    container.innerHTML = ''; *@

@*                    const wrapperDiv = document.createElement('div'); *@
@*                    wrapperDiv.style.position = 'relative'; *@
@*                    wrapperDiv.style.border = '2px solid ' + (currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd'); *@
@*                    wrapperDiv.style.borderRadius = '8px'; *@
@*                    wrapperDiv.style.backgroundColor = 'white'; *@
@*                    wrapperDiv.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)'; *@
@*                    wrapperDiv.style.padding = '15px'; *@
@*                    wrapperDiv.style.overflow = 'hidden'; // Prevent content overflow *@

@*                    // Add orientation label *@
@*                    const orientationLabel = document.createElement('div'); *@
@*                    orientationLabel.className = 'page-info-label orientation-label'; *@
@*                    orientationLabel.innerHTML = `<i class="fas ${currentOrientation === 'landscape' ? 'fa-landscape' : 'fa-portrait'}"></i> ${currentOrientation.toUpperCase()}`; *@
@*                    orientationLabel.style.position = 'absolute'; *@
@*                    orientationLabel.style.top = '5px'; *@
@*                    orientationLabel.style.right = '5px'; *@
@*                    orientationLabel.style.backgroundColor = currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd'; *@
@*                    orientationLabel.style.color = 'white'; *@
@*                    orientationLabel.style.padding = '2px 8px'; *@
@*                    orientationLabel.style.borderRadius = '4px'; *@
@*                    orientationLabel.style.fontSize = '12px'; *@
@*                    orientationLabel.style.zIndex = '100'; *@
@*                    wrapperDiv.appendChild(orientationLabel); *@

@*                    // Add rotation label *@
@*                    if (currentRotation !== 0) { *@
@*                        const rotationLabel = document.createElement('div'); *@
@*                        rotationLabel.className = 'page-info-label rotation-label'; *@
@*                        rotationLabel.innerHTML = `<i class="fas fa-sync-alt"></i> ${currentRotation}°`; *@
@*                        rotationLabel.style.position = 'absolute'; *@
@*                        rotationLabel.style.top = '5px'; *@
@*                        rotationLabel.style.left = '5px'; *@
@*                        rotationLabel.style.backgroundColor = '#dc3545'; *@
@*                        rotationLabel.style.color = 'white'; *@
@*                        rotationLabel.style.padding = '2px 8px'; *@
@*                        rotationLabel.style.borderRadius = '4px'; *@
@*                        rotationLabel.style.fontSize = '12px'; *@
@*                        rotationLabel.style.zIndex = '100'; *@
@*                        wrapperDiv.appendChild(rotationLabel); *@
@*                    } *@

@*                    // Create inner container for canvas with proper sizing *@
@*                    const canvasContainer = document.createElement('div'); *@
@*                    canvasContainer.style.width = '100%'; *@
@*                    canvasContainer.style.height = '100%'; *@
@*                    canvasContainer.style.display = 'flex'; *@
@*                    canvasContainer.style.justifyContent = 'center'; *@
@*                    canvasContainer.style.alignItems = 'center'; *@
@*                    canvasContainer.style.overflow = 'hidden'; *@

@*                    canvasContainer.appendChild(canvas); *@
@*                    wrapperDiv.appendChild(canvasContainer); *@
@*                    container.appendChild(wrapperDiv); *@

@*                    pageRendering = false; *@

@*                    if (pageNumPending !== null) { *@
@*                        renderPage(pageNumPending); *@
@*                        pageNumPending = null; *@
@*                    } *@

@*                    const visiblePageNumber = pageOrder.filter(p => p.visible && p.originalPage <= num).length; *@
@*                    pageNumInput.value = visiblePageNumber; *@
@*                    currentPageDisplay.textContent = visiblePageNumber; *@
@*                    currentPageInfo.textContent = visiblePageNumber; *@
@*                    updateOrientationDisplay(num); *@
@*                    updateRotationDisplay(num); *@
@*                    updateUIControls(num); *@

@*                } catch (error) { *@
@*                    console.error('Error rendering page:', error); *@
@*                } *@
@*            } *@

@*            function queueRenderPage(num) { *@
@*                if (pageRendering) { *@
@*                    pageNumPending = num; *@
@*                } else { *@
@*                    renderPage(num); *@
@*                } *@
@*            } *@

@*            function updateOrientationDisplay(pageNum) { *@
@*                const orientation = currentOrientations[pageNum] || 'portrait'; *@
@*                orientationDisplay.textContent = orientation === 'portrait' ? 'Portrait' : 'Landscape'; *@
@*            } *@

@*            function updateRotationDisplay(pageNum) { *@
@*                const rotation = currentRotations[pageNum] || 0; *@
@*                rotationDisplay.textContent = rotation + '°'; *@
@*            } *@

@*            function updateUIControls(pageNum) { *@
@*                // Update orientation buttons *@
@*                document.querySelectorAll('.orientation-btn').forEach(btn => { *@
@*                    btn.classList.remove('active'); *@
@*                    if (btn.dataset.orientation === (currentOrientations[pageNum] || 'portrait')) { *@
@*                        btn.classList.add('active'); *@
@*                    } *@
@*                }); *@

@*                // Update thumbnail rotation badge *@
@*                updateThumbnailRotationBadge(pageNum, currentRotations[pageNum] || 0); *@
@*            } *@

@*            // Create thumbnails *@
@*            async function createThumbnails() { *@
@*                thumbnailContainer.innerHTML = ''; *@

@*                if (!pdfDoc) return; *@

@*                const visiblePages = pageOrder *@
@*                    .filter(page => page.visible) *@
@*                    .sort((a, b) => a.currentOrder - b.currentOrder); *@

@*                for (let i = 0; i < visiblePages.length; i++) { *@
@*                    const page = visiblePages[i]; *@
@*                    const pageNum = page.originalPage; *@
@*                    await createThumbnailElement(pageNum, i, page.orientation, page.rotation); *@
@*                } *@

@*                updatePageStatistics(); *@
@*            } *@

@*            async function createThumbnailElement(pageNum, index, orientation, rotation = 0) { *@
@*                const colDiv = document.createElement('div'); *@
@*                colDiv.className = 'col-6 col-md-4'; *@
@*                colDiv.setAttribute('data-page', pageNum); *@

@*                const thumbnailDiv = document.createElement('div'); *@
@*                thumbnailDiv.className = 'thumbnail-item'; *@
@*                thumbnailDiv.dataset.page = pageNum; *@
@*                thumbnailDiv.style.cssText = ` *@
@*                    cursor: move; *@
@*                    border: 2px solid ${orientation === 'landscape' ? '#ffc107' : '#0d6efd'}; *@
@*                    border-radius: 8px; *@
@*                    overflow: hidden; *@
@*                    background: white; *@
@*                    transition: all 0.2s ease; *@
@*                    margin-bottom: 10px; *@
@*                    height: 180px; *@
@*                    display: flex; *@
@*                    flex-direction: column; *@
@*                    position: relative; *@
@*                `; *@

@*                const orientationIcon = orientation === 'portrait' ? 'fa-portrait' : 'fa-landscape'; *@
@*                const orientationColor = orientation === 'portrait' ? 'primary' : 'warning'; *@

@*                thumbnailDiv.innerHTML = ` *@
@*                    <div class="position-absolute top-0 end-0 p-1"> *@
@*                        <button type="button" class="btn btn-sm btn-danger remove-page-btn" *@
@*                                data-page="${pageNum}" *@
@*                                title="Remove this page"> *@
@*                            <i class="fas fa-times"></i> *@
@*                        </button> *@
@*                    </div> *@
@*                    <div class="position-absolute top-0 start-0 p-1"> *@
@*                        <span class="badge bg-${orientationColor}"> *@
@*                            <i class="fas ${orientationIcon}"></i> *@
@*                        </span> *@
@*                    </div> *@
@*                    <div class="thumbnail-canvas flex-grow-1 d-flex justify-content-center align-items-center p-2"> *@
@*                        <div class="spinner-border spinner-border-sm" role="status"> *@
@*                            <span class="visually-hidden">Loading...</span> *@
@*                        </div> *@
@*                    </div> *@
@*                    <div class="thumbnail-label bg-light p-2 text-center border-top"> *@
@*                        <div class="d-flex justify-content-between align-items-center"> *@
@*                            <small class="text-muted">Page ${pageNum}</small> *@
@*                            <div> *@
@*                                <small class="badge bg-${orientationColor}"> *@
@*                                    <i class="fas ${orientationIcon}"></i> *@
@*                                </small> *@
@*                                <small class="badge bg-info rotation-badge ms-1">${rotation}°</small> *@
@*                            </div> *@
@*                        </div> *@
@*                        <div class="mt-1"> *@
@*                            <small class="text-primary"> *@
@*                                <i class="fas fa-sort me-1"></i>Order: ${index + 1} *@
@*                            </small> *@
@*                        </div> *@
@*                    </div> *@
@*                `; *@

@*                thumbnailContainer.appendChild(colDiv); *@
@*                colDiv.appendChild(thumbnailDiv); *@

@*                await loadThumbnail(pageNum, thumbnailDiv.querySelector('.thumbnail-canvas'), rotation); *@

@*                // Add event listeners *@
@*                thumbnailDiv.querySelector('.remove-page-btn').addEventListener('click', function(e) { *@
@*                    e.stopPropagation(); *@
@*                    const pageToRemove = parseInt(this.getAttribute('data-page')); *@
@*                    removePage(pageToRemove); *@
@*                }); *@

@*                thumbnailDiv.addEventListener('click', function(e) { *@
@*                    if (!e.target.closest('.remove-page-btn')) { *@
@*                        const pageNum = parseInt(this.dataset.page); *@
@*                        goToPage(pageNum); *@
@*                    } *@
@*                }); *@
@*            } *@

@*            async function loadThumbnail(pageNum, canvasContainer, rotation = 0) { *@
@*                try { *@
@*                    const page = await pdfDoc.getPage(pageNum); *@
@*                    const viewport = page.getViewport({ scale: 0.15 }); *@
@*                    const originalWidth = viewport.width; *@
@*                    const originalHeight = viewport.height; *@

@*                    // Calculate thumbnail size *@
@*                    const thumbnailSize = 100; // Fixed size for thumbnail *@

@*                    // Calculate scale to fit thumbnail *@
@*                    let scaleX = thumbnailSize / originalWidth; *@
@*                    let scaleY = thumbnailSize / originalHeight; *@
@*                    let scale = Math.min(scaleX, scaleY); *@

@*                    // Adjust for rotation *@
@*                    let canvasWidth = originalWidth * scale; *@
@*                    let canvasHeight = originalHeight * scale; *@

@*                    if (rotation === 90 || rotation === -90 || rotation === 270) { *@
@*                        // Swap dimensions for 90° rotation *@
@*                        const temp = canvasWidth; *@
@*                        canvasWidth = canvasHeight; *@
@*                        canvasHeight = temp; *@
@*                    } *@

@*                    // Add padding for rotation *@
@*                    const padding = 10; *@
@*                    const finalWidth = canvasWidth + padding * 2; *@
@*                    const finalHeight = canvasHeight + padding * 2; *@

@*                    const canvas = document.createElement('canvas'); *@
@*                    const ctx = canvas.getContext('2d'); *@

@*                    canvas.width = finalWidth; *@
@*                    canvas.height = finalHeight; *@

@*                    // Fill background *@
@*                    ctx.fillStyle = 'white'; *@
@*                    ctx.fillRect(0, 0, canvas.width, canvas.height); *@

@*                    // Save context *@
@*                    ctx.save(); *@

@*                    // Move to center *@
@*                    ctx.translate(finalWidth / 2, finalHeight / 2); *@

@*                    // Apply rotation *@
@*                    ctx.rotate(rotation * Math.PI / 180); *@

@*                    // Move back and draw *@
@*                    ctx.translate(-canvasWidth / 2, -canvasHeight / 2); *@

@*                    // Create render context *@
@*                    const renderContext = { *@
@*                        canvasContext: ctx, *@
@*                        viewport: page.getViewport({ scale: scale }) *@
@*                    }; *@

@*                    await page.render(renderContext).promise; *@

@*                    // Restore context *@
@*                    ctx.restore(); *@

@*                    canvasContainer.innerHTML = ''; *@
@*                    canvasContainer.appendChild(canvas); *@

@*                } catch (error) { *@
@*                    console.error(`Error loading thumbnail for page ${pageNum}:`, error); *@
@*                    canvasContainer.innerHTML = '<div class="text-muted small">Error loading thumbnail</div>'; *@
@*                } *@
@*            } *@

@*             function applyRotationToCanvas(canvas, rotation) { *@
@*                     const ctx = canvas.getContext('2d'); *@
@*                     const width = canvas.width; *@
@*                     const height = canvas.height; *@

@*                     const rotatedCanvas = document.createElement('canvas'); *@
@*                     const rotatedCtx = rotatedCanvas.getContext('2d'); *@

@*                     if (rotation === 90 || rotation === -90 || rotation === 270) { *@
@*                         rotatedCanvas.width = height; *@
@*                         rotatedCanvas.height = width; *@
@*                     } else { *@
@*                         rotatedCanvas.width = width; *@
@*                         rotatedCanvas.height = height; *@
@*                     } *@

@*                     rotatedCtx.clearRect(0, 0, rotatedCanvas.width, rotatedCanvas.height); *@
@*                     rotatedCtx.save(); *@
@*                     rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2); *@
@*                     rotatedCtx.rotate(rotation * Math.PI / 180); *@
@*                     rotatedCtx.drawImage(canvas, -width / 2, -height / 2); *@
@*                     rotatedCtx.restore(); *@

@*                     canvas.width = rotatedCanvas.width; *@
@*                     canvas.height = rotatedCanvas.height; *@
@*                     ctx.clearRect(0, 0, canvas.width, canvas.height); *@
@*                     ctx.drawImage(rotatedCanvas, 0, 0); *@
@*                 } *@

@*            function initializeThumbnailSortable() { *@
@*                if (thumbnailSortable) { *@
@*                    thumbnailSortable.destroy(); *@
@*                } *@

@*                thumbnailSortable = new Sortable(thumbnailContainer, { *@
@*                    animation: 150, *@
@*                    ghostClass: 'sortable-ghost', *@
@*                    chosenClass: 'sortable-chosen', *@
@*                    dragClass: 'sortable-drag', *@
@*                    filter: '.remove-page-btn', *@
@*                    onStart: function(evt) { *@
@*                        evt.item.style.opacity = '0.8'; *@
@*                    }, *@
@*                    onEnd: function(evt) { *@
@*                        evt.item.style.opacity = '1'; *@

@*                        const items = thumbnailContainer.querySelectorAll('[data-page]'); *@
@*                        const newOrder = []; *@

@*                        items.forEach((item, index) => { *@
@*                            const pageNum = parseInt(item.getAttribute('data-page')); *@
@*                            const pageData = pageOrder.find(p => p.originalPage === pageNum); *@
@*                            if (pageData) { *@
@*                                pageData.currentOrder = index + 1; *@
@*                                newOrder.push(pageData); *@
@*                            } *@
@*                        }); *@

@*                        pageOrder.sort((a, b) => a.currentOrder - b.currentOrder); *@
@*                        updateThumbnailLabels(); *@
@*                        updatePageStatistics(); *@
@*                        showToast('Page order updated!'); *@
@*                    } *@
@*                }); *@
@*            } *@

@*            function updateThumbnailLabels() { *@
@*                const thumbnails = document.querySelectorAll('.thumbnail-item'); *@
@*                thumbnails.forEach((thumb, index) => { *@
@*                    const label = thumb.querySelector('.text-primary small'); *@
@*                    if (label) { *@
@*                        label.innerHTML = `<i class="fas fa-sort me-1"></i>Order: ${index + 1}`; *@
@*                    } *@
@*                }); *@
@*            } *@

@*            function removePage(pageNum) { *@
@*                const pageIndex = pageOrder.findIndex(p => p.originalPage === pageNum); *@
@*                if (pageIndex !== -1) { *@
@*                    pageOrder[pageIndex].visible = false; *@
@*                    pageOrder[pageIndex].currentOrder = 9999; *@

@*                    if (pageNum === pageNum) { *@
@*                        const nextVisiblePage = pageOrder.find(p => p.visible); *@
@*                        if (nextVisiblePage) { *@
@*                            goToPage(nextVisiblePage.originalPage); *@
@*                        } else { *@
@*                            pdfPreviewContainer.innerHTML = ` *@
@*                                <div class="text-center"> *@
@*                                    <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i> *@
@*                                    <h5 class="mb-2 text-white">No pages to display</h5> *@
@*                                    <p class="text-light">All pages have been removed</p> *@
@*                                </div> *@
@*                            `; *@
@*                        } *@
@*                    } *@

@*                    createThumbnails(); *@
@*                    updatePageStatistics(); *@
@*                    showToast(`Page ${pageNum} removed from download list`); *@
@*                } *@
@*            } *@

@*            function goToPage(targetPage) { *@
@*                const pageData = pageOrder.find(p => p.originalPage === targetPage); *@
@*                if (pageData && pageData.visible) { *@
@*                    pageNum = targetPage; *@
@*                    queueRenderPage(pageNum); *@
@*                } *@
@*            } *@

@*            // ORIENTATION CONTROLS *@
@*            document.querySelectorAll('.orientation-btn').forEach(btn => { *@
@*                btn.addEventListener('click', function() { *@
@*                    const orientation = this.dataset.orientation; *@
@*                    setCurrentPageOrientation(orientation); *@
@*                }); *@
@*            }); *@

@*            function setCurrentPageOrientation(orientation) { *@
@*                if (!pageNum) return; *@

@*                currentOrientations[pageNum] = orientation; *@

@*                const pageData = pageOrder.find(p => p.originalPage === pageNum); *@
@*                if (pageData) { *@
@*                    pageData.orientation = orientation; *@
@*                } *@

@*                updateOrientationDisplay(pageNum); *@

@*                document.querySelectorAll('.orientation-btn').forEach(btn => { *@
@*                    btn.classList.remove('active'); *@
@*                    if (btn.dataset.orientation === orientation) { *@
@*                        btn.classList.add('active'); *@
@*                    } *@
@*                }); *@

@*                queueRenderPage(pageNum); *@
@*                updateOrientationSummary(); *@
@*                showToast(`Page ${pageNum} set to ${orientation}`); *@
@*            } *@

@*            applyToAllPortrait.addEventListener('click', function() { *@
@*                if (confirm('Apply Portrait orientation to all pages?')) { *@
@*                    pageOrder.forEach(page => { *@
@*                        if (page.visible) { *@
@*                            page.orientation = 'portrait'; *@
@*                            currentOrientations[page.originalPage] = 'portrait'; *@
@*                        } *@
@*                    }); *@
@*                    createThumbnails(); *@
@*                    updateOrientationSummary(); *@
@*                    queueRenderPage(pageNum); *@
@*                    showToast('Portrait orientation applied to all pages'); *@
@*                } *@
@*            }); *@

@*            applyToAllLandscape.addEventListener('click', function() { *@
@*                if (confirm('Apply Landscape orientation to all pages?')) { *@
@*                    pageOrder.forEach(page => { *@
@*                        if (page.visible) { *@
@*                            page.orientation = 'landscape'; *@
@*                            currentOrientations[page.originalPage] = 'landscape'; *@
@*                        } *@
@*                    }); *@
@*                    createThumbnails(); *@
@*                    updateOrientationSummary(); *@
@*                    queueRenderPage(pageNum); *@
@*                    showToast('Landscape orientation applied to all pages'); *@
@*                } *@
@*            }); *@

@*            function updateOrientationSummary() { *@
@*                let portraitCount = 0; *@
@*                let landscapeCount = 0; *@

@*                pageOrder.forEach(page => { *@
@*                    if (page.visible) { *@
@*                        if (page.orientation === 'portrait') { *@
@*                            portraitCount++; *@
@*                        } else { *@
@*                            landscapeCount++; *@
@*                        } *@
@*                    } *@
@*                }); *@

@*                orientationSummary.textContent = `Portrait: ${portraitCount}, Landscape: ${landscapeCount}`; *@
@*            } *@

@*            // ROTATION CONTROLS *@
@*            document.querySelectorAll('.rotate-btn').forEach(btn => { *@
@*                btn.addEventListener('click', function() { *@
@*                    if (this.id === 'resetRotation') { *@
@*                        resetRotation(); *@
@*                    } else { *@
@*                        const rotation = parseInt(this.dataset.rotation); *@
@*                        applyRotation(rotation); *@
@*                    } *@
@*                }); *@
@*            }); *@

@*            function applyRotation(rotation) { *@
@*                if (!pageNum) return; *@

@*                // Initialize if not exists *@
@*                if (!currentRotations[pageNum]) { *@
@*                    currentRotations[pageNum] = 0; *@
@*                } *@

@*                // Apply rotation *@
@*                currentRotations[pageNum] = (currentRotations[pageNum] + rotation) % 360; *@
@*                if (currentRotations[pageNum] < 0) { *@
@*                    currentRotations[pageNum] += 360; *@
@*                } *@

@*                // Update page data *@
@*                const pageData = pageOrder.find(p => p.originalPage === pageNum); *@
@*                if (pageData) { *@
@*                    pageData.rotation = currentRotations[pageNum]; *@
@*                } *@

@*                // Update display *@
@*                updateRotationDisplay(pageNum); *@
@*                queueRenderPage(pageNum); *@

@*                // Update thumbnail *@
@*                updateThumbnailRotationBadge(pageNum, currentRotations[pageNum]); *@

@*                showToast(`Page rotated to ${currentRotations[pageNum]}°`); *@
@*            } *@

@*            function resetRotation() { *@
@*                if (!pageNum) return; *@

@*                currentRotations[pageNum] = 0; *@
@*                const pageData = pageOrder.find(p => p.originalPage === pageNum); *@
@*                if (pageData) { *@
@*                    pageData.rotation = 0; *@
@*                } *@

@*                updateRotationDisplay(pageNum); *@
@*                queueRenderPage(pageNum); *@
@*                updateThumbnailRotationBadge(pageNum, 0); *@

@*                showToast('Rotation reset to 0°'); *@
@*            } *@

@*            function updateThumbnailRotationBadge(pageNum, rotation) { *@
@*                const thumbnails = document.querySelectorAll(`[data-page="${pageNum}"] .thumbnail-item`); *@
@*                thumbnails.forEach(thumb => { *@
@*                    const rotationElement = thumb.querySelector('.rotation-badge'); *@
@*                    if (rotationElement) { *@
@*                        rotationElement.textContent = rotation + '°'; *@
@*                    } *@
@*                }); *@
@*            } *@

@*            // PAGE NAVIGATION *@
@*            prevPage.addEventListener('click', function() { *@
@*                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder); *@
@*                const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum); *@

@*                if (currentIndex > 0) { *@
@*                    const prevPageNum = visiblePages[currentIndex - 1].originalPage; *@
@*                    pageNum = prevPageNum; *@
@*                    queueRenderPage(pageNum); *@
@*                } *@
@*            }); *@

@*            nextPage.addEventListener('click', function() { *@
@*                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder); *@
@*                const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum); *@

@*                if (currentIndex < visiblePages.length - 1) { *@
@*                    const nextPageNum = visiblePages[currentIndex + 1].originalPage; *@
@*                    pageNum = nextPageNum; *@
@*                    queueRenderPage(pageNum); *@
@*                } *@
@*            }); *@

@*            quickPrevPage.addEventListener('click', function() { *@
@*                prevPage.click(); *@
@*            }); *@

@*            quickNextPage.addEventListener('click', function() { *@
@*                nextPage.click(); *@
@*            }); *@

@*            pageNumInput.addEventListener('change', function() { *@
@*                const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder); *@
@*                let newIndex = parseInt(this.value) - 1; *@

@*                if (newIndex < 0) newIndex = 0; *@
@*                if (newIndex >= visiblePages.length) newIndex = visiblePages.length - 1; *@

@*                if (visiblePages[newIndex]) { *@
@*                    pageNum = visiblePages[newIndex].originalPage; *@
@*                    queueRenderPage(pageNum); *@
@*                } *@
@*            }); *@

@*            showAllPages.addEventListener('click', function() { *@
@*                pageOrder.forEach(page => { *@
@*                    page.visible = true; *@
@*                    page.currentOrder = page.originalPage; *@
@*                }); *@

@*                pageOrder.sort((a, b) => a.currentOrder - b.currentOrder); *@

@*                createThumbnails(); *@
@*                initializeThumbnailSortable(); *@
@*                showToast('All pages restored'); *@
@*            }); *@

@*            removeAllPages.addEventListener('click', function() { *@
@*                if (confirm('Remove all pages from download list?')) { *@
@*                    pageOrder.forEach(page => { *@
@*                        page.visible = false; *@
@*                        page.currentOrder = 9999; *@
@*                    }); *@

@*                    createThumbnails(); *@
@*                    pdfPreviewContainer.innerHTML = ` *@
@*                        <div class="text-center"> *@
@*                            <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i> *@
@*                            <h5 class="mb-2 text-white">All pages removed</h5> *@
@*                            <p class="text-light">Click "Show All" to restore pages</p> *@
@*                        </div> *@
@*                    `; *@
@*                    updatePageStatistics(); *@
@*                    showToast('All pages removed from download list'); *@
@*                } *@
@*            }); *@

@*            function updatePageStatistics() { *@
@*                const visiblePages = pageOrder.filter(p => p.visible).length; *@
@*                const totalPages = pageOrder.length; *@

@*                visiblePagesCount.textContent = visiblePages; *@
@*                visiblePagesDisplay.textContent = visiblePages; *@
@*                pageCountBadge.textContent = visiblePages; *@

@*                downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages} pages)`; *@

@*                pageCountSpan.textContent = visiblePages; *@
@*                totalPagesDisplay2.textContent = visiblePages; *@

@*                updateOrientationSummary(); *@
@*            } *@

@*            // DOWNLOAD PDF WITH ORIENTATIONS & ROTATIONS *@
@*            downloadFinalPdfBtn.addEventListener('click', async function() { *@
@*                if (!currentPdfUrl) { *@
@*                    showError('No PDF available to download.'); *@
@*                    return; *@
@*                } *@

@*                const visiblePages = pageOrder *@
@*                    .filter(p => p.visible) *@
@*                    .sort((a, b) => a.currentOrder - b.currentOrder); *@

@*                if (visiblePages.length === 0) { *@
@*                    showError('No pages selected for download.'); *@
@*                    return; *@
@*                } *@

@*                downloadFinalPdfBtn.disabled = true; *@
@*                downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...'; *@

@*                try { *@
@*                    // Prepare page data with rotation *@
@*                    const pageOrderData = pageOrder.map(page => ({ *@
@*                        OriginalPage: page.originalPage, *@
@*                        CurrentOrder: page.currentOrder, *@
@*                        Visible: page.visible, *@
@*                        Orientation: page.orientation, *@
@*                        Rotation: page.rotation *@
@*                    })); *@

@*                    // Get selected sheets *@
@*                    const selectedSheets = getSelectedSheets(); *@

@*                    // Send to server for processing *@
@*                    const response = await fetch('@Url.Action("GenerateReorderedPdf", "Home")', { *@
@*                        method: 'POST', *@
@*                        headers: { *@
@*                            'Content-Type': 'application/json', *@
@*                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value *@
@*                        }, *@
@*                        body: JSON.stringify({ *@
@*                            sessionId: sessionId, *@
@*                            selectedSheets: selectedSheets, *@
@*                            pageOrderData: pageOrderData, *@
@*                            orientationData: currentOrientations, *@
@*                            rotationData: currentRotations *@
@*                        }) *@
@*                    }); *@

@*                    const result = await response.json(); *@

@*                    if (result.success) { *@
@*                        // Download the PDF *@
@*                        const link = document.createElement('a'); *@
@*                        link.href = 'data:application/pdf;base64,' + result.pdfData; *@
@*                        link.download = result.fileName || 'document.pdf'; *@
@*                        document.body.appendChild(link); *@
@*                        link.click(); *@
@*                        document.body.removeChild(link); *@

@*                        showSuccess(`Downloaded ${visiblePages.length} pages with orientations and rotations applied`); *@
@*                    } else { *@
@*                        showError(result.message || 'Failed to generate PDF'); *@
@*                    } *@
@*                } catch (error) { *@
@*                    console.error('Error downloading PDF:', error); *@
@*                    showError('Error downloading PDF: ' + error.message); *@
@*                } finally { *@
@*                    downloadFinalPdfBtn.disabled = false; *@
@*                    downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`; *@
@*                } *@
@*            }); *@


@*                // ============================================= *@
@*                // HELPER FUNCTIONS *@
@*                // ============================================= *@

@*                function showToast(message) { *@
@*                    const toast = document.createElement('div'); *@
@*                    toast.className = 'toast align-items-center text-white bg-primary border-0'; *@
@*                    toast.setAttribute('role', 'alert'); *@
@*                    toast.innerHTML = ` *@
@*                        <div class="d-flex"> *@
@*                            <div class="toast-body"> *@
@*                                <i class="fas fa-check-circle me-2"></i> *@
@*                                ${message} *@
@*                            </div> *@
@*                            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button> *@
@*                        </div> *@
@*                    `; *@

@*                    const toastContainer = document.querySelector('.toast-container'); *@
@*                    if (!toastContainer) { *@
@*                        const container = document.createElement('div'); *@
@*                        container.className = 'toast-container position-fixed top-0 end-0 p-3'; *@
@*                        document.body.appendChild(container); *@
@*                        container.appendChild(toast); *@
@*                    } else { *@
@*                        toastContainer.appendChild(toast); *@
@*                    } *@

@*                    const bsToast = new bootstrap.Toast(toast); *@
@*                    bsToast.show(); *@

@*                    setTimeout(() => { *@
@*                        toast.remove(); *@
@*                    }, 3000); *@
@*                } *@

@*                function getSelectedSheets() { *@
@*                    const selectedSheets = []; *@
@*                    document.querySelectorAll('.sheet-checkbox:checked').forEach(checkbox => { *@
@*                        selectedSheets.push(checkbox.value); *@
@*                    }); *@
@*                    return selectedSheets; *@
@*                } *@

@*                // Existing sheet selection functionality *@
@*                const sortableElement = document.getElementById('sortable'); *@
@*                if (sortableElement) { *@
@*                    const sortable = new Sortable(sortableElement, { *@
@*                        handle: '.drag-handle', *@
@*                        animation: 150, *@
@*                        ghostClass: 'sortable-ghost', *@
@*                        chosenClass: 'sortable-chosen', *@
@*                        dragClass: 'sortable-drag', *@
@*                        onStart: function(evt) { *@
@*                            evt.item.style.backgroundColor = '#e3f2fd'; *@
@*                            document.body.style.cursor = 'grabbing'; *@
@*                        }, *@
@*                        onEnd: function(evt) { *@
@*                            evt.item.style.backgroundColor = ''; *@
@*                            document.body.style.cursor = ''; *@
@*                            updateOrderNumbers(); *@
@*                            updateSelectedCount(); *@
@*                        } *@
@*                    }); *@
@*                } *@

@*                selectAllCheckbox.addEventListener('change', function() { *@
@*                    const isChecked = this.checked; *@
@*                    sheetCheckboxes.forEach(checkbox => { *@
@*                        checkbox.checked = isChecked; *@
@*                    }); *@
@*                    updateSelectedCount(); *@
@*                }); *@

@*                sheetCheckboxes.forEach(checkbox => { *@
@*                    checkbox.addEventListener('change', updateSelectedCount); *@
@*                }); *@

@*                function updateOrderNumbers() { *@
@*                    const rows = document.querySelectorAll('#sortable tr'); *@
@*                    rows.forEach((row, index) => { *@
@*                        const badge = row.querySelector('.order-badge'); *@
@*                        if (badge) { *@
@*                            badge.textContent = index + 1; *@
@*                            row.setAttribute('data-order', index); *@
@*                        } *@
@*                    }); *@
@*                } *@

@*                function updateSelectedCount() { *@
@*                    const selectedCount = document.querySelectorAll('.sheet-checkbox:checked').length; *@
@*                    selectedSheetsCount.textContent = selectedCount; *@
@*                    const totalCheckboxes = sheetCheckboxes.length; *@
@*                    selectAllCheckbox.checked = selectedCount === totalCheckboxes; *@
@*                    selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCheckboxes; *@
@*                } *@

@*                convertBtn.addEventListener('click', function() { *@
@*                            // ✅ Validation check pehle *@
@*             if (!validateBeforeConversion()) { *@
@*                 return; // Validation fail hone par return kar do *@
@*             } *@

@*                    const selectedSheets = getSelectedSheets(); *@
@*                    if (selectedSheets.length === 0) { *@
@*                        alert('Please select at least one sheet to convert.'); *@
@*                        return; *@
@*                    } *@

@*                    submitConversionForm(selectedSheets); *@
@*                }); *@

@*                function submitConversionForm(selectedSheets) { *@
@*                    const btn = convertBtn; *@
@*                    btn.disabled = true; *@
@*                    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Converting...'; *@

@*                    const form = document.createElement('form'); *@
@*                    form.method = 'POST'; *@
@*                    form.action = '@Url.Action("ConvertToPdf")'; *@

@*                    const sessionIdInput = document.createElement('input'); *@
@*                    sessionIdInput.type = 'hidden'; *@
@*                    sessionIdInput.name = 'sessionId'; *@
@*                    sessionIdInput.value = sessionId; *@
@*                    form.appendChild(sessionIdInput); *@

@*                    selectedSheets.forEach((sheet, index) => { *@
@*                        const sheetInput = document.createElement('input'); *@
@*                        sheetInput.type = 'hidden'; *@
@*                        sheetInput.name = 'selectedSheets'; *@
@*                        sheetInput.value = sheet; *@
@*                        form.appendChild(sheetInput); *@

@*                        const orderInput = document.createElement('input'); *@
@*                        orderInput.type = 'hidden'; *@
@*                        orderInput.name = 'sheetOrders'; *@
@*                        orderInput.value = index; *@
@*                        form.appendChild(orderInput); *@
@*                    }); *@

@*                    const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]'); *@
@*                    if (antiForgeryToken) { *@
@*                        form.appendChild(antiForgeryToken.cloneNode(true)); *@
@*                    } *@

@*                    document.body.appendChild(form); *@
@*                    form.submit(); *@
@*                } *@

@*                function showError(message) { *@
@*                    Swal.fire({ *@
@*                        icon: 'error', *@
@*                        title: 'Error', *@
@*                        text: message, *@
@*                        confirmButtonColor: '#dc3545' *@
@*                    }); *@
@*                } *@

@*                function showSuccess(message) { *@
@*                    Swal.fire({ *@
@*                        icon: 'success', *@
@*                        title: 'Success', *@
@*                        text: message, *@
@*                        confirmButtonColor: '#198754', *@
@*                        timer: 3000 *@
@*                    }); *@
@*                } *@

@*                updateOrderNumbers(); *@
@*                updateSelectedCount(); *@

@*         }); *@
@*     </script> *@

@*     <style> *@
@*         .text-gradient { *@
@*             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); *@
@*             -webkit-background-clip: text; *@
@*             -webkit-text-fill-color: transparent; *@
@*             background-clip: text; *@
@*         } *@

@*         .sortable-ghost { *@
@*             opacity: 0.5; *@
@*             background: #e3f2fd; *@
@*         } *@

@*         .sortable-chosen { *@
@*             background-color: #e3f2fd !important; *@
@*         } *@

@*         .sortable-drag { *@
@*             transform: rotate(5deg); *@
@*         } *@

@*         .thumbnail-item:hover { *@
@*             transform: scale(1.02); *@
@*             box-shadow: 0 4px 15px rgba(0,0,0,0.1); *@
@*         } *@

@*         .thumbnail-canvas canvas { *@
@*             max-width: 100%; *@
@*             max-height: 100%; *@
@*         } *@

@*         .page-info-label { *@
@*             position: absolute; *@
@*             top: 5px; *@
@*             padding: 2px 8px; *@
@*             border-radius: 4px; *@
@*             font-size: 12px; *@
@*             z-index: 10; *@
@*             color: white; *@
@*         } *@

@*         .orientation-label { *@
@*             right: 5px; *@
@*             background-color: #0d6efd; *@
@*         } *@

@*         .rotation-label { *@
@*             left: 5px; *@
@*             background-color: #dc3545; *@
@*         } *@

@*         .btn-primary { *@
@*             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); *@
@*             border: none; *@
@*             border-radius: 8px; *@
@*         } *@

@*         .btn-success { *@
@*             background: linear-gradient(135deg, #28a745 0%, #20c997 100%); *@
@*             border: none; *@
@*             border-radius: 8px; *@
@*         } *@

@*         .btn-info { *@
@*             background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); *@
@*             border: none; *@
@*             border-radius: 8px; *@
@*         } *@

@*         .card { *@
@*             border-radius: 15px; *@
@*         } *@

@*         .table th { *@
@*             font-weight: 600; *@
@*             border-bottom: 2px solid #dee2e6; *@
@*         } *@

@*         .badge { *@
@*             font-size: 0.85em; *@
@*             font-weight: 500; *@
@*         } *@

@*         .drag-handle { *@
@*             cursor: grab; *@
@*         } *@

@*             .drag-handle:active { *@
@*                 cursor: grabbing; *@
@*             } *@

@*         .file-upload-area { *@
@*             cursor: pointer; *@
@*             transition: all 0.3s ease; *@
@*             position: relative; *@
@*             background-color: transparent !important; *@
@*         } *@

@*             .file-upload-area:hover { *@
@*                 border-color: #17a2b8; *@
@*                 background-color: rgba(23, 162, 184, 0.05); *@
@*             } *@

@*             .file-upload-area.drag-over { *@
@*                 border-color: #17a2b8 !important; *@
@*                 background-color: rgba(23, 162, 184, 0.15) !important; *@
@*                 transform: scale(1.02); *@
@*             } *@

@*         .border-dashed { *@
@*             border: 2px dashed #dee2e6; *@
@*             transition: all 0.3s ease; *@
@*         } *@

@*         .list-group-item { *@
@*             border-left: 0; *@
@*             border-right: 0; *@
@*         } *@

@*             .list-group-item:first-child { *@
@*                 border-top: 0; *@
@*             } *@

@*             .list-group-item:last-child { *@
@*                 border-bottom: 0; *@
@*             } *@
@*     </style> *@
@* } *@
