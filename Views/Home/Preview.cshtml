@model ExcelToPdfConverter.Models.PreviewModel

@{
    ViewData["Title"] = "Preview - " + Model.OriginalFileName;
}

@Html.AntiForgeryToken()

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

<div class="container-fluid px-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center py-4 mb-4 border-bottom">
        <div>
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb mb-2">
                    <li class="breadcrumb-item"><a href="@Url.Action("Index")" class="text-decoration-none">Home</a></li>
                    <li class="breadcrumb-item active">Preview</li>
                </ol>
            </nav>
            <h1 class="h3 mb-1 text-gradient">File Preview</h1>
            <p class="text-muted mb-0">Review and select sheets for PDF conversion</p>
        </div>
        <div class="d-flex gap-2">
            <a href="@Url.Action("Index")" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back
            </a>
            <!-- New Merge PDF Button -->
            <button type="button" id="mergePdfBtn" class="btn btn-info px-4">
                <i class="fas fa-file-pdf me-2"></i>Merge PDF Files
            </button>
            <button type="button" id="pdfPreviewBtn" class="btn btn-primary px-4">
                <i class="fas fa-eye me-2"></i>PDF Preview Manager
            </button>
            @* <button id="convertBtn" class="btn btn-success px-4"> *@
            @*     <i class="fas fa-file-pdf me-2"></i>Convert & Download *@
            @* </button> *@
        </div>
    </div>

    <!-- PDF Upload Section (Initially hidden) -->
    <div id="pdfUploadSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-info text-white">
            <h5 class="mb-0">
                <i class="fas fa-file-upload me-2"></i>Upload PDF Files for Merging
            </h5>
        </div>
        <div class="card-body">
            <div class="alert alert-info border-0">
                <i class="fas fa-info-circle me-2"></i>
                Upload PDF files to merge with your converted Excel sheets. You can upload multiple files at once.
            </div>

            <!-- File Upload Area -->
            <div class="file-upload-area border-dashed rounded-3 p-4 text-center mb-3" id="pdfFileUploadArea">
                <i class="fas fa-file-pdf text-info mb-3" style="font-size: 3rem;"></i>
                <h5 class="mb-3">Drag & Drop your PDF files here</h5>
                <p class="text-muted mb-3">or click to browse multiple files</p>

                <div class="mb-3">
                    <input type="file" class="form-control d-none" name="PdfFiles" id="PdfFiles"
                           accept=".pdf" multiple>
                    <label for="PdfFiles" class="btn btn-info btn-lg px-4" id="pdfFileLabel">
                        <i class="fas fa-folder-open me-2"></i>Choose PDF Files
                    </label>
                </div>

                <div id="pdfFileNames" class="text-muted small mt-2"></div>
                <div class="form-text">Supported format: .pdf • Maximum file size: 50MB per file</div>
            </div>

            <!-- Uploaded Files List -->
            <div id="uploadedFilesList" class="mt-3" style="display: none;">
                <h6 class="mb-3">Uploaded Files:</h6>
                <div id="uploadedFilesContainer" class="list-group"></div>
            </div>

            <!-- Action Buttons -->
            <div class="d-flex gap-2 mt-4">
                <button type="button" id="cancelUploadBtn" class="btn btn-outline-secondary flex-grow-1">
                    <i class="fas fa-times me-2"></i>Cancel
                </button>
                <button type="button" id="addMorePdfsBtn" class="btn btn-primary flex-grow-1">
                    <i class="fas fa-plus me-2"></i>Add More PDFs
                </button>
                <button type="button" id="mergeUploadedPdfsBtn" class="btn btn-success flex-grow-1">
                    <i class="fas fa-merge me-2"></i>Merge Uploaded PDFs
                </button>
            </div>
        </div>
    </div>

    <!-- Merged PDF Files List (Initially hidden) -->
    <div id="mergedPdfSection" class="card border-0 shadow-sm mb-4" style="display: none;">
        <div class="card-header bg-success text-white">
            <h5 class="mb-0">
                <i class="fas fa-check-circle me-2"></i>Merged PDF Files
            </h5>
        </div>
        <div class="card-body">
            <div id="mergedPdfList" class="list-group">
                <!-- Merged PDF files will appear here -->
            </div>
        </div>
    </div>

    <!-- PDF Preview Modal -->
    <div class="modal fade" id="pdfPreviewModal" tabindex="-1" aria-labelledby="pdfPreviewModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title" id="pdfPreviewModalLabel">
                        <i class="fas fa-file-pdf me-2"></i>PDF Page Manager
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge bg-light text-dark me-2">
                            <span id="pageCountBadge">0</span> pages
                        </span>
                        <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="modal-body p-0 d-flex" style="height: calc(100vh - 120px);">
                    <!-- PDF Preview Area -->
                    <div class="flex-grow-1 d-flex flex-column" style="width: 60%; background-color: #525659;">
                        <div id="pdfPreviewContainer" class="flex-grow-1 d-flex justify-content-center align-items-center">
                            <div class="text-center">
                                <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                <h5 class="mb-2 text-white">PDF Preview Area</h5>
                                <p class="text-light mb-0">Preview will appear here</p>
                            </div>
                        </div>
                        <div class="border-top bg-dark text-white p-2" style="display: none;" id="pageInfoBar">
                            <div class="row align-items-center">
                                <div class="col-md-8">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-info-circle me-2"></i>
                                        <small>
                                            Page <span id="currentPageDisplay">1</span> of <span id="totalPagesDisplay2">0</span> •
                                            Orientation: <span id="orientationDisplay">Portrait</span> •
                                            Rotation: <span id="rotationDisplay">0°</span>
                                        </small>
                                    </div>
                                </div>
                                <div class="col-md-4 text-end">
                                    <div class="btn-group btn-group-sm">
                                        <button type="button" class="btn btn-outline-light" id="quickPrevPage">
                                            <i class="fas fa-chevron-left"></i>
                                        </button>
                                        <button type="button" class="btn btn-outline-light" id="quickNextPage">
                                            <i class="fas fa-chevron-right"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Controls Sidebar -->
                    <div class="controls-sidebar border-start" style="width: 40%; background: #ffffff; overflow-y: auto;">
                        <div id="pdfControls" style="display: none;">
                            <!-- Page Controls -->
                            <div class="p-3 border-bottom bg-light">
                                <h6 class="mb-3">
                                    <i class="fas fa-cogs me-2"></i>Page Controls
                                </h6>
                                <div class="row g-3">
                                    <div class="col-8">
                                        <div class="d-flex align-items-center">
                                            <button id="prevPage" class="btn btn-outline-primary btn-sm me-2">
                                                <i class="fas fa-chevron-left"></i> Prev
                                            </button>
                                            <div class="input-group input-group-sm flex-grow-1 me-2">
                                                <input type="number" id="pageNumInput" class="form-control text-center" min="1" value="1">
                                                <span class="input-group-text">/ <span id="page_count">1</span></span>
                                            </div>
                                            <button id="nextPage" class="btn btn-outline-primary btn-sm">
                                                Next <i class="fas fa-chevron-right"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="col-4 text-end">
                                        <div class="text-muted small">Page</div>
                                        <div class="fw-bold" id="currentPageInfo">1</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Orientation & Rotation Controls -->
                            <div class="p-3 border-bottom">
                                <h6 class="mb-3">
                                    <i class="fas fa-compress-alt me-2"></i>Page Orientation & Rotation
                                </h6>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Set orientation for current page • Content will rotate with page
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-success orientation-btn active flex-grow-1"
                                            data-orientation="portrait">
                                        <i class="fas fa-portrait me-1"></i>Portrait
                                    </button>
                                    <button type="button" class="btn btn-outline-warning orientation-btn flex-grow-1"
                                            data-orientation="landscape">
                                        <i class="fas fa-landscape me-1"></i>Landscape
                                    </button>
                                </div>
                                <div class="btn-group btn-group-sm w-100 mb-2">
                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="90">
                                        <i class="fas fa-redo me-1"></i>Rotate Left
                                    </button>

                                    <button type="button" class="btn btn-outline-warning rotate-btn flex-grow-1" data-rotation="-90">
                                        <i class="fas fa-undo me-1"></i>Rotate Right
                                    </button>

                                    <button type="button" class="btn btn-outline-danger rotate-btn flex-grow-1" data-rotation="180">
                                        <i class="fas fa-sync-alt me-1"></i>Flip
                                    </button>

                                    <button type="button" class="btn btn-outline-secondary rotate-btn flex-grow-1" id="resetRotation">
                                        <i class="fas fa-history me-1"></i>Reset
                                    </button>
                                </div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllPortrait">
                                        <i class="fas fa-copy me-1"></i>Apply Portrait to All
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="applyToAllLandscape">
                                        <i class="fas fa-copy me-1"></i>Apply Landscape to All
                                    </button>
                                </div>
                            </div>

                            <!-- Page Thumbnails -->
                            <div class="p-3">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0">
                                        <i class="fas fa-images me-2"></i>Page Thumbnails
                                        <small class="text-muted">(Drag to reorder)</small>
                                    </h6>
                                    <div>
                                        <span class="badge bg-primary" id="visiblePagesCount">0</span>
                                    </div>
                                </div>
                                <div class="alert alert-info border-0 small mb-3">
                                    <i class="fas fa-info-circle me-1"></i>
                                    Drag thumbnails to reorder pages • Click × to remove pages
                                </div>
                                <div id="thumbnailContainer" class="row g-2 mb-3" style="max-height: 400px; overflow-y: auto;"></div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-outline-secondary btn-sm flex-grow-1" id="showAllPages">
                                        <i class="fas fa-eye me-1"></i>Show All
                                    </button>
                                    <button type="button" class="btn btn-outline-danger btn-sm flex-grow-1" id="removeAllPages">
                                        <i class="fas fa-trash me-1"></i>Remove All
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <div class="w-100 d-flex justify-content-between align-items-center">
                        <div class="text-muted small">
                            <div class="d-flex gap-3">
                                <span>
                                    <i class="fas fa-copy me-1"></i>
                                    Total Pages: <span id="totalPagesCount">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-eye me-1"></i>
                                    Visible: <span id="visiblePagesDisplay">0</span>
                                </span>
                                <span>
                                    <i class="fas fa-compress-alt me-1"></i>
                                    <span id="orientationSummary">Portrait: 0, Landscape: 0</span>
                                </span>
                            </div>
                        </div>
                        <div class="d-flex">
                            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">
                                <i class="fas fa-times me-1"></i>Close
                            </button>
                            <button type="button" id="downloadFinalPdfBtn" class="btn btn-success">
                                <i class="fas fa-download me-1"></i>Download PDF
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Cards -->
    <div class="row g-4 mb-4">
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-primary mb-3">
                        <i class="fas fa-layer-group fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.FileSelections.Count</h3>
                    <p class="text-muted mb-0">Total Sheets</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-danger mb-3">
                        <i class="fas fa-exclamation-triangle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllNameErrors.Count</h3>
                    <p class="text-muted mb-0">#NAME? Errors</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-calendar-check fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.AllInvoiceDates.Count</h3>
                    <p class="text-muted mb-0">Invoice Dates</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-success mb-3">
                        <i class="fas fa-check-circle fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1" id="selectedSheetsCount">0</h3>
                    <p class="text-muted mb-0">Sheets Selected</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Invoice Numbers Summary Card -->
    <div class="row g-4 mb-4">
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-warning mb-3">
                        <i class="fas fa-file-invoice-dollar fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.InvoiceNumbers.Count</h3>
                    <p class="text-muted mb-0">Invoice Numbers</p>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card border-0 shadow-sm h-100">
                <div class="card-body text-center p-4">
                    <div class="text-info mb-3">
                        <i class="fas fa-calendar-alt fs-1"></i>
                    </div>
                    <h3 class="fw-bold text-dark mb-1">@Model.DateRanges.Count</h3>
                    <p class="text-muted mb-0">Date Ranges</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Separate Error Sections -->
    @if (Model.HasNameErrors)
    {
            <div class="card border-0 shadow-sm mb-4">
                <div class="card-header bg-danger text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-exclamation-triangle me-2"></i>#NAME? Errors Found
                    </h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>Sheet Name</th>
                                    <th>Location</th>
                                    <th>Cell Reference</th>
                                </tr>
                            </thead>
                            <tbody>
                            @foreach (var error in Model.AllNameErrors)
                            {
                                        <tr>
                                            <td><strong>@error.SheetName</strong></td>
                                            <td>@error.FullLocation</td>
                                            <td><code>@error.Location</code></td>
                                        </tr>
                            }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
    }

    @if (Model.HasInvoiceDates)
    {
            <div class="card border-0 shadow-sm mb-4">
                <div class="card-header  bg-danger text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-calendar-check me-2"></i>Invoice Dates Found (@Model.AllInvoiceDates.Count)
                    </h5>
                </div>
                <div class="card-body">
                    <div class="alert alert-info">
                        <strong>Debug Info:</strong> Found @Model.AllInvoiceDates.Count invoice dates across all sheets.
                    </div>
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>#</th>
                                    <th>Sheet Name</th>
                                    <th>Invoice Date Text</th>
                                    <th>Date Value</th>
                                    <th>Location</th>
                                </tr>
                            </thead>
                            <tbody>
                            @{
                                int counter = 1;
                            }
                            @foreach (var invoiceDate in Model.AllInvoiceDates)
                            {
                                        <tr>
                                            <td>@(counter++)</td>
                                            <td><strong>@invoiceDate.SheetName</strong></td>
                                            <td><code>@invoiceDate.InvoiceDateText</code></td>
                                            <td><strong class="text-danger">@invoiceDate.DateValue</strong></td>
                                            <td><code>@invoiceDate.Location</code></td>
                                        </tr>
                            }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
    }
    else
    {
            <div class="alert alert-warning">
                <strong>No Invoice Dates Found:</strong> The system did not find any invoice dates in the Excel file.
                Console showed: Credit Note (1), Tax Invoice (1), AOC (1), working sheet (1)
            </div>
    }

    <!-- Invoice Numbers Section -->
    @if (Model.InvoiceNumbers.Count > 0)
    {
            <div class="card border-0 shadow-sm mb-4">
                <div class="card-header bg-warning text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-file-invoice-dollar me-2"></i>Invoice Numbers Found (@Model.InvoiceNumbers.Count)
                    </h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>#</th>
                                    <th>Sheet Name</th>
                                    <th>Invoice Number</th>
                                    <th>Location</th>
                                </tr>
                            </thead>
                            <tbody>
                            @{
                                int invCounter = 1;
                            }
                            @foreach (var invoiceNumber in Model.InvoiceNumbers)
                            {
                                        <tr>
                                            <td>@(invCounter++)</td>
                                            <td><strong>@invoiceNumber.SheetName</strong></td>
                                            <td><code class="text-warning">@invoiceNumber.Number</code></td>
                                            <td><code>@invoiceNumber.Location</code></td>
                                        </tr>
                            }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
    }

    <!-- Date Ranges Section -->
    @if (Model.DateRanges.Count > 0)
    {
            <div class="card border-0 shadow-sm mb-4">
                <div class="card-header bg-info text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-calendar-alt me-2"></i>Date Ranges Found (@Model.DateRanges.Count)
                    </h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>#</th>
                                    <th>Sheet Name</th>
                                    <th>Date Range Text</th>
                                    <th>Location</th>
                                </tr>
                            </thead>
                            <tbody>
                            @{
                                int dateCounter = 1;
                            }
                            @foreach (var dateRange in Model.DateRanges)
                            {
                                        <tr>
                                            <td>@(dateCounter++)</td>
                                            <td><strong>@dateRange.SheetName</strong></td>
                                            <td><code class="text-info">@dateRange.DateRangeText</code></td>
                                            <td><code>@dateRange.Location</code></td>
                                        </tr>
                            }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
    }

    <!-- Sheet Selection -->
    <div class="card border-0 shadow-sm">
        <div class="card-header bg-white py-3 border-bottom">
            <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="fas fa-list-check text-primary me-2"></i>Sheet Selection & Ordering
                </h5>
                <div class="d-flex align-items-center gap-2">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="selectAll" checked>
                        <label class="form-check-label small fw-bold" for="selectAll">
                            Select All
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-hover mb-0" id="sheetSelectionTable">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 60px;" class="text-center ps-4">#</th>
                            <th style="width: 60px;" class="text-center">Select</th>
                            <th>Sheet Name</th>
                            <th style="width: 120px;" class="text-center">#NAME? Errors</th>
                            <th style="width: 120px;" class="text-center">Invoice Dates</th>
                            <th style="width: 120px;" class="text-center">Invoice Numbers</th>
                            <th style="width: 120px;" class="text-center">Date Ranges</th>
                        </tr>
                    </thead>
                    <tbody id="sortable">
                        @foreach (var file in Model.FileSelections.OrderBy(f => f.SortOrder))
                        {
                                <tr data-sheet="@file.SheetName" data-order="@file.SortOrder" class="sortable-row">
                                    <td class="text-center align-middle ps-4">
                                        <div class="d-flex align-items-center justify-content-center">
                                        @* <div class="drag-handle me-2" style="cursor: grab;">
                                            <i class="fas fa-grip-vertical text-muted"></i>
                                        </div> *@
                                            <span class="order-badge badge bg-primary rounded-pill">@(file.SortOrder + 1)</span>
                                        </div>
                                    </td>
                                    <td class="text-center align-middle">
                                        <input type="checkbox" name="selectedSheets" value="@file.SheetName"
                                    @(file.IsSelected ? "checked" : "")
                                               class="sheet-checkbox form-check-input">
                                    </td>
                                    <td class="align-middle">
                                        <div class="d-flex align-items-center">
                                            <i class="fas fa-table text-muted me-2"></i>
                                            <strong>@file.SheetName</strong>
                                        </div>
                                    </td>
                                    <td class="text-center align-middle">
                                    @if (file.HasNameErrors)
                                    {
                                                <span class="badge bg-danger rounded-pill">
                                            @file.NameErrors.Count
                                                </span>
                                    }
                                    else
                                    {
                                                <span class="badge bg-success rounded-pill">0</span>
                                    }
                                    </td>
                                    <td class="text-center align-middle">
                                    @if (file.HasInvoiceDates)
                                    {
                                                <span class="badge bg-success rounded-pill">
                                            @file.InvoiceDates.Count
                                                </span>
                                    }
                                    else
                                    {
                                                <span class="badge bg-secondary rounded-pill">0</span>
                                    }
                                    </td>
                                    <td class="text-center align-middle">
                                    @{
                                        var sheetInvoiceNumbers = Model.InvoiceNumbers.Where(n => n.SheetName == file.SheetName).Count();
                                    }
                                    @if (sheetInvoiceNumbers > 0)
                                    {
                                                <span class="badge bg-warning rounded-pill">
                                            @sheetInvoiceNumbers
                                                </span>
                                    }
                                    else
                                    {
                                                <span class="badge bg-secondary rounded-pill">0</span>
                                    }
                                    </td>
                                    <td class="text-center align-middle">
                                    @{
                                        var sheetDateRanges = Model.DateRanges.Where(d => d.SheetName == file.SheetName).Count();
                                    }
                                    @if (sheetDateRanges > 0)
                                    {
                                                <span class="badge bg-info rounded-pill">
                                            @sheetDateRanges
                                                </span>
                                    }
                                    else
                                    {
                                                <span class="badge bg-secondary rounded-pill">0</span>
                                    }
                                    </td>
                                </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

@section Scripts {
        <script>
                    document.addEventListener('DOMContentLoaded', function() {
                        const sessionId = '@Model.SessionId';
                        const convertBtn = document.getElementById('convertBtn');
                        const selectAllCheckbox = document.getElementById('selectAll');
                        const sheetCheckboxes = document.querySelectorAll('.sheet-checkbox');
                        // const selectedSheetsCount = document.getElementById('selectedSheetsCount');
                           const initiallySelectedCount = @Model.FileSelections.Count(f => f.IsSelected);
        selectedSheetsCount.textContent = initiallySelectedCount;
                        // PDF Preview Variables
                        const pdfPreviewBtn = document.getElementById('pdfPreviewBtn');
                        const pdfPreviewModal = new bootstrap.Modal(document.getElementById('pdfPreviewModal'));
                        const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
                        const pdfControls = document.getElementById('pdfControls');
                        const downloadFinalPdfBtn = document.getElementById('downloadFinalPdfBtn');
                        const pageNumInput = document.getElementById('pageNumInput');
                        const pageCountSpan = document.getElementById('page_count');
                        const currentPageInfo = document.getElementById('currentPageInfo');
                        const totalPagesCount = document.getElementById('totalPagesCount');
                        const totalPagesDisplay2 = document.getElementById('totalPagesDisplay2');
                        const currentPageDisplay = document.getElementById('currentPageDisplay');
                        const orientationDisplay = document.getElementById('orientationDisplay');
                        const rotationDisplay = document.getElementById('rotationDisplay');
                        const pageCountBadge = document.getElementById('pageCountBadge');
                        const visiblePagesCount = document.getElementById('visiblePagesCount');
                        const visiblePagesDisplay = document.getElementById('visiblePagesDisplay');
                        const pageInfoBar = document.getElementById('pageInfoBar');
                        const thumbnailContainer = document.getElementById('thumbnailContainer');
                        const showAllPages = document.getElementById('showAllPages');
                        const removeAllPages = document.getElementById('removeAllPages');
                        const quickPrevPage = document.getElementById('quickPrevPage');
                        const quickNextPage = document.getElementById('quickNextPage');
                        const prevPage = document.getElementById('prevPage');
                        const nextPage = document.getElementById('nextPage');
                        const applyToAllPortrait = document.getElementById('applyToAllPortrait');
                        const applyToAllLandscape = document.getElementById('applyToAllLandscape');
                        const orientationSummary = document.getElementById('orientationSummary');

                        let pdfDoc = null;
                        let pageNum = 1;
                        let pageRendering = false;
                        let pageNumPending = null;
                        let currentOrientations = {};
                        let currentRotations = {};
                        let currentPdfUrl = null;
                        let pageOrder = [];
                        let thumbnailSortable = null;
                        let pdfData = null;
                        let pdfFileName = "";

                        // PDF Upload Variables
                        const mergePdfBtn = document.getElementById('mergePdfBtn');
                        const pdfUploadSection = document.getElementById('pdfUploadSection');
                        const pdfFileInput = document.getElementById('PdfFiles');
                        const pdfFileUploadArea = document.getElementById('pdfFileUploadArea');
                        const uploadedFilesContainer = document.getElementById('uploadedFilesContainer');
                        const uploadedFilesList = document.getElementById('uploadedFilesList');
                        const pdfFileNames = document.getElementById('pdfFileNames');
                        const cancelUploadBtn = document.getElementById('cancelUploadBtn');
                        const mergeUploadedPdfsBtn = document.getElementById('mergeUploadedPdfsBtn');
                        const addMorePdfsBtn = document.getElementById('addMorePdfsBtn');
                        const mergedPdfSection = document.getElementById('mergedPdfSection');
                        const mergedPdfList = document.getElementById('mergedPdfList');

                        let uploadedPdfs = [];
                        let mergedPdfs = [];

                        // मुख्य validation function

                                function validateBeforeConversion() {
                let hasNameErrors = @Json.Serialize(Model.HasNameErrors);
                let hasInvoiceDates = @Json.Serialize(Model.HasInvoiceDates);
                let allInvoiceDates = @Json.Serialize(Model.AllInvoiceDates);
                let allInvoiceNumbers = @Json.Serialize(Model.InvoiceNumbers);
                let allDateRanges = @Json.Serialize(Model.DateRanges);

                console.log("=== VALIDATION CHECK START ===");
                console.log("- Has Name Errors:", hasNameErrors);
                console.log("- Has Invoice Dates:", hasInvoiceDates);
                console.log("- All Invoice Dates:", allInvoiceDates);
                console.log("- All Invoice Numbers:", allInvoiceNumbers);
                console.log("- All Date Ranges:", allDateRanges);

                // Get selected sheets
                const selectedSheets = getSelectedSheets();
                console.log("Selected sheets for validation:", selectedSheets);

                if (selectedSheets.length === 0) {
                    showValidationError("Please select at least one sheet to convert.");
                    return false;
                }

                   // Credit Note sheet को validation से exclude करें
        const sheetsToValidate = selectedSheets.filter(sheetName => 
            !sheetName.toLowerCase().includes('credit note')
        );



                // पहला validation: #NAME? errors check (only in selected sheets)
                let selectedSheetsNameErrors = [];
                if (hasNameErrors && allInvoiceDates && allInvoiceDates.length > 0) {
                    // Filter name errors for selected sheets only
                    selectedSheetsNameErrors = allInvoiceDates.filter(error =>
                                sheetsToValidate.includes(error.sheetName)
                    );
                }

                if (selectedSheetsNameErrors.length > 0) {
                    showValidationError("Please fix all #NAME? errors in selected sheets before converting to PDF.");
                    return false;
                }

                // दूसरा validation: Invoice Date mismatches check (only in selected sheets)
                if (hasInvoiceDates && allInvoiceDates && allInvoiceDates.length > 0) {
                    // Filter invoice dates for selected sheets only
                    let selectedSheetsInvoiceDates = allInvoiceDates.filter(date =>
                                sheetsToValidate.includes(date.sheetName)
                    );

                    if (selectedSheetsInvoiceDates.length > 0) {
                        let hasMismatch = checkInvoiceDateMismatches(selectedSheetsInvoiceDates);
                        if (hasMismatch) {
                            showValidationError("Please fix Invoice Date mismatches in selected sheets before converting to PDF.");
                            return false;
                        }
                    }
                }

                // तीसरा validation: Invoice Number validation (only in selected sheets)
                if (allInvoiceNumbers && allInvoiceNumbers.length > 0) {
                    // Filter invoice numbers for selected sheets only
                    let selectedSheetsInvoiceNumbers = allInvoiceNumbers.filter(inv =>
                                sheetsToValidate.includes(inv.sheetName)
                    );

                    if (selectedSheetsInvoiceNumbers.length > 0) {
                        let invoiceNumberValidation = checkInvoiceNumberValidation(selectedSheetsInvoiceNumbers);
                        if (!invoiceNumberValidation.isValid) {
                            showInvoiceNumberValidationError(invoiceNumberValidation);
                            return false;
                        }
                    }
                }

            // चौथा validation: Date Range validation (only in selected sheets)
            if (allDateRanges && allDateRanges.length > 0) {
                // Filter date ranges for selected sheets only
                let selectedSheetsDateRanges = allDateRanges.filter(range =>
                            sheetsToValidate.includes(range.sheetName)
                );

                console.log("Date ranges for selected sheets:", selectedSheetsDateRanges);

                if (selectedSheetsDateRanges.length > 0) {
                    let dateRangeValidation = checkDateRangeValidation(selectedSheetsDateRanges);
                    if (!dateRangeValidation.isValid) {
                        showDateRangeValidationError(dateRangeValidation);
                        return false;
                    }
                } else {
                    console.log("ℹ️ No date ranges in selected sheets - skipping date range validation");
                }
            }

                console.log("✅ All validations passed for selected sheets");
                return true;
            }

            // Updated validation functions to work with filtered data
            function checkInvoiceDateMismatches(invoiceDates) {
                console.log("Checking invoice date mismatches for selected sheets...");
                console.log("Invoice dates to check:", invoiceDates);

                let hasMismatch = false;
                let parsedDates = [];

                invoiceDates.forEach(invoiceDate => {
                    if (invoiceDate.dateValue && invoiceDate.dateValue.trim() !== '') {
                        const parsedDate = parseDateString(invoiceDate.dateValue.trim());
                        if (parsedDate) {
                            parsedDates.push({
                                originalText: invoiceDate.dateValue.trim(),
                                parsedDate: parsedDate,
                                sheet: invoiceDate.sheetName,
                                location: invoiceDate.location
                            });
                        }
                    }
                });

                console.log("Parsed dates found in selected sheets:", parsedDates);

                if (parsedDates.length > 1) {
                    const firstParsedDate = parsedDates[0].parsedDate;

                    const allSame = parsedDates.every(item =>
                        item.parsedDate.getTime() === firstParsedDate.getTime()
                    );

                    if (!allSame) {
                        console.log("❌ Date mismatch found in selected sheets!");
                        hasMismatch = true;
                        showDateMismatchDetailsImproved(parsedDates);
                    } else {
                        console.log("✅ All invoice dates are same in selected sheets");
                    }
                } else if (parsedDates.length === 1) {
                    console.log("✅ Only one invoice date found in selected sheets - no mismatch possible");
                } else {
                    console.log("ℹ️ No invoice date values found in selected sheets");
                }

                return hasMismatch;
            }

            function checkInvoiceNumberValidation(invoiceNumbers) {
                console.log("=== INVOICE NUMBER VALIDATION (Selected Sheets) ===");

                console.log("Invoice numbers in selected sheets:", invoiceNumbers);

                let result = {
                    isValid: true,
                    invoiceNumbers: [],
                    mismatches: []
                };

                if (invoiceNumbers && invoiceNumbers.length > 0) {
                    // सभी invoice numbers collect करें
                    let allNumbers = [];
                    invoiceNumbers.forEach(item => {
                        if (item.number && item.number.trim() !== '') {
                            allNumbers.push({
                                sheet: item.sheetName,
                                location: item.location,
                                number: item.number.trim(),
                                labelText: item.labelText || "Invoice Number"
                            });
                        }
                    });

                    console.log("All invoice numbers in selected sheets:", allNumbers);

                    if (allNumbers.length > 0) {
                        // पहला invoice number reference के लिए
                        const firstNumber = allNumbers[0].number;
                        result.invoiceNumbers = allNumbers;

                        // Check if all invoice numbers match
                        const allSame = allNumbers.every(item =>
                            item.number === firstNumber
                        );

                        if (!allSame) {
                            result.isValid = false;

                            // Group by invoice number to show mismatches
                            let numberGroups = {};
                            allNumbers.forEach(item => {
                                if (!numberGroups[item.number]) {
                                    numberGroups[item.number] = [];
                                }
                                numberGroups[item.number].push({
                                    sheet: item.sheet,
                                    location: item.location
                                });
                            });

                            // Convert to array format
                            result.mismatches = Object.keys(numberGroups).map(number => ({
                                number: number,
                                sheets: numberGroups[number]
                            }));
                        } else {
                            console.log("✅ All invoice numbers match in selected sheets:", firstNumber);
                        }
                    }
                } else {
                    console.log("No invoice numbers found in selected sheets");
                }

                console.log("Invoice Number Validation Result for selected sheets:", result);
                return result;
            }

            // Date Range validation function (updated to show selected sheets info)
                    function checkDateRangeValidation(selectedSheetsDateRanges) {
                console.log("=== DATE RANGE VALIDATION (Selected Sheets) ===");

                console.log("Date ranges count in selected sheets:", selectedSheetsDateRanges.length);
                console.log("Date ranges details for selected sheets:", selectedSheetsDateRanges);

                let result = {
                    isValid: true,
                    dateRanges: [],
                    mismatches: []
                };

                if (selectedSheetsDateRanges && selectedSheetsDateRanges.length > 0) {
                    // सभी date ranges collect करें (सिर्फ selected sheets के)
                    let allRanges = [];
                    selectedSheetsDateRanges.forEach(item => {
                        if (item.dateRangeText && item.dateRangeText.trim() !== '') {
                            allRanges.push({
                                sheet: item.sheetName,
                                location: item.location,
                                dateRangeText: item.dateRangeText.trim(),
                                parsedFrom: parseDateFromRange(item.dateRangeText),
                                parsedTo: parseDateToRange(item.dateRangeText)
                            });
                        }
                    });

                    console.log("All date ranges parsed in selected sheets:", allRanges);

                    if (allRanges.length > 0) {
                        result.dateRanges = allRanges;

                        // अब check करें कि क्या सभी selected sheets के date ranges match करते हैं
                        if (allRanges.length === 1) {
                            // अगर सिर्फ एक ही sheet में date range है
                            console.log("✅ Only one sheet has date range - validation passed");
                            result.isValid = true;
                        } else {
                            // Multiple sheets में date ranges हैं - इन्हें आपस में compare करें
                            const firstRange = allRanges[0];
                            const firstFrom = firstRange.parsedFrom;
                            const firstTo = firstRange.parsedTo;

                            // Check if all date ranges in SELECTED SHEETS match each other
                            const allSame = allRanges.every(item => {
                                if (!item.parsedFrom || !item.parsedTo || !firstFrom || !firstTo) {
                                    console.log(`❌ Cannot parse date range in ${item.sheet}: ${item.dateRangeText}`);
                                    return false;
                                }
                                return item.parsedFrom.getTime() === firstFrom.getTime() &&
                                       item.parsedTo.getTime() === firstTo.getTime();
                            });

                            if (!allSame) {
                                result.isValid = false;

                                // Group by date range to show mismatches
                                let rangeGroups = {};
                                allRanges.forEach(item => {
                                    const rangeKey = item.dateRangeText;
                                    if (!rangeGroups[rangeKey]) {
                                        rangeGroups[rangeKey] = [];
                                    }
                                    rangeGroups[rangeKey].push({
                                        sheet: item.sheet,
                                        location: item.location,
                                        from: item.parsedFrom,
                                        to: item.parsedTo
                                    });
                                });

                                // Convert to array format
                                result.mismatches = Object.keys(rangeGroups).map(rangeText => ({
                                    dateRangeText: rangeText,
                                    sheets: rangeGroups[rangeText]
                                }));

                                console.log("❌ Date range mismatches found BETWEEN SELECTED SHEETS:", result.mismatches);
                            } else {
                                console.log("✅ All date ranges MATCH BETWEEN SELECTED SHEETS:", firstRange.dateRangeText);
                            }
                        }
                    } else {
                        console.log("ℹ️ No valid date ranges found in selected sheets after parsing");
                        result.isValid = true; // कोई date range नहीं है तो validation pass
                    }
                } else {
                    console.log("ℹ️ No date ranges found in selected sheets");
                    result.isValid = true; // कोई date range नहीं है तो validation pass
                }

                console.log("Date Range Validation Result for selected sheets:", result);
                return result;
            }

                        // Helper function to parse "From" date from range string - UPDATED FOR MULTIPLE FORMATS
    function parseDateFromRange(rangeText) {
        try {
            console.log(`Parsing FROM date from range: "${rangeText}"`);

            // Format 1: "01-09-2022 TO 30-09-2022" (DD-MM-YYYY TO DD-MM-YYYY)
            const format1 = rangeText.match(/^(\d{1,2})-(\d{1,2})-(\d{4})\s+TO\s+(\d{1,2})-(\d{1,2})-(\d{4})$/i);
            if (format1) {
                const day = parseInt(format1[1]);
                const month = parseInt(format1[2]);
                const year = parseInt(format1[3]);
                console.log(`Parsed with format1: ${day}/${month}/${year}`);
                return new Date(year, month - 1, day);
            }

            // Format 2: "01 Nov 2025 TO 30 Nov 2025" (DD MMM YYYY TO DD MMM YYYY)
            const format2 = rangeText.match(/^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})\s+TO\s+(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i);
            if (format2) {
                const day = parseInt(format2[1]);
                const month = getMonthNumber(format2[2]);
                const year = parseInt(format2[3]);
                console.log(`Parsed with format2: ${day}/${month}/${year}`);
                if (month) {
                    return new Date(year, month - 1, day);
                }
            }

            // Format 3: "01/09/2022 TO 30/09/2022" (DD/MM/YYYY TO DD/MM/YYYY)
            const format3 = rangeText.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+TO\s+(\d{1,2})\/(\d{1,2})\/(\d{4})$/i);
            if (format3) {
                const day = parseInt(format3[1]);
                const month = parseInt(format3[2]);
                const year = parseInt(format3[3]);
                console.log(`Parsed with format3: ${day}/${month}/${year}`);
                return new Date(year, month - 1, day);
            }

            console.log(`❌ Could not parse FROM date from: "${rangeText}"`);
            return null;
        } catch (error) {
            console.error("Error parsing date from range:", error);
            return null;
        }
    }

    // Helper function to parse "To" date from range string - UPDATED FOR MULTIPLE FORMATS
    function parseDateToRange(rangeText) {
        try {
            console.log(`Parsing TO date from range: "${rangeText}"`);

            // Format 1: "01-09-2022 TO 30-09-2022" (DD-MM-YYYY TO DD-MM-YYYY)
            const format1 = rangeText.match(/^(\d{1,2})-(\d{1,2})-(\d{4})\s+TO\s+(\d{1,2})-(\d{1,2})-(\d{4})$/i);
            if (format1) {
                const day = parseInt(format1[4]);
                const month = parseInt(format1[5]);
                const year = parseInt(format1[6]);
                console.log(`Parsed with format1: ${day}/${month}/${year}`);
                return new Date(year, month - 1, day);
            }

            // Format 2: "01 Nov 2025 TO 30 Nov 2025" (DD MMM YYYY TO DD MMM YYYY)
            const format2 = rangeText.match(/^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})\s+TO\s+(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i);
            if (format2) {
                const day = parseInt(format2[4]);
                const month = getMonthNumber(format2[5]);
                const year = parseInt(format2[6]);
                console.log(`Parsed with format2: ${day}/${month}/${year}`);
                if (month) {
                    return new Date(year, month - 1, day);
                }
            }

            // Format 3: "01/09/2022 TO 30/09/2022" (DD/MM/YYYY TO DD/MM/YYYY)
            const format3 = rangeText.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+TO\s+(\d{1,2})\/(\d{1,2})\/(\d{4})$/i);
            if (format3) {
                const day = parseInt(format3[4]);
                const month = parseInt(format3[5]);
                const year = parseInt(format3[6]);
                console.log(`Parsed with format3: ${day}/${month}/${year}`);
                return new Date(year, month - 1, day);
            }

            console.log(`❌ Could not parse TO date from: "${rangeText}"`);
            return null;
        } catch (error) {
            console.error("Error parsing date to range:", error);
            return null;
        }
    }

    // Month name to number function (अगर नहीं है तो add करें)
    function getMonthNumber(monthName) {
        const months = {
            'january': 1, 'jan': 1,
            'february': 2, 'feb': 2,
            'march': 3, 'mar': 3,
            'april': 4, 'apr': 4,
            'may': 5,
            'june': 6, 'jun': 6,
            'july': 7, 'jul': 7,
            'august': 8, 'aug': 8,
            'september': 9, 'sep': 9, 'sept': 9,
            'october': 10, 'oct': 10,
            'november': 11, 'nov': 11,
            'december': 12, 'dec': 12
        };

        const monthKey = monthName.toLowerCase();
        const monthNum = months[monthKey];
        console.log(`Month name "${monthName}" -> number: ${monthNum}`);
        return monthNum;
    }

                        // पुराने functions
                        function parseDateString(dateString) {
                            console.log(`Parsing date: "${dateString}"`);

                            const dateFormats = [
                                /^([A-Za-z]+),\s*(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                                /^([A-Za-z]+),\s*([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                                /^(\d{1,2})\s+([A-Za-z]+),\s*(\d{4})$/i,
                                /^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/i,
                                /^(\d{4})-(\d{1,2})-(\d{1,2})$/,
                                /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
                                /^(\d{1,2})-([A-Za-z]+)-(\d{4})$/i,
                                /^(\d{1,2})\s+([A-Za-z]+)\s+(\d{4})$/i
                            ];

                            for (const format of dateFormats) {
                                const match = dateString.match(format);
                                if (match) {
                                    console.log(`Matched format: ${format}`);

                                    let day, month, year;

                                    if (format === dateFormats[0]) {
                                        day = parseInt(match[2]);
                                        month = getMonthNumber(match[3]);
                                        year = parseInt(match[4]);
                                    } else if (format === dateFormats[1]) {
                                        day = parseInt(match[3]);
                                        month = getMonthNumber(match[2]);
                                        year = parseInt(match[4]);
                                    } else if (format === dateFormats[2]) {
                                        day = parseInt(match[1]);
                                        month = getMonthNumber(match[2]);
                                        year = parseInt(match[3]);
                                    } else if (format === dateFormats[3]) {
                                        day = parseInt(match[2]);
                                        month = getMonthNumber(match[1]);
                                        year = parseInt(match[3]);
                                    } else if (format === dateFormats[4]) {
                                        year = parseInt(match[1]);
                                        month = parseInt(match[2]);
                                        day = parseInt(match[3]);
                                    } else if (format === dateFormats[5]) {
                                        const monthCandidate = parseInt(match[1]);
                                        const dayCandidate = parseInt(match[2]);
                                        year = parseInt(match[3]);

                                        if (monthCandidate >= 1 && monthCandidate <= 12) {
                                            month = monthCandidate;
                                            day = dayCandidate;
                                        } else {
                                            month = dayCandidate;
                                            day = monthCandidate;
                                        }
                                    } else if (format === dateFormats[6]) {
                                        day = parseInt(match[1]);
                                        month = getMonthNumber(match[2]);
                                        year = parseInt(match[3]);
                                    } else if (format === dateFormats[7]) {
                                        day = parseInt(match[1]);
                                        month = getMonthNumber(match[2]);
                                        year = parseInt(match[3]);
                                    }

                                    if (month && day && year) {
                                        const parsedDate = new Date(year, month - 1, day);
                                        console.log(`Successfully parsed: ${parsedDate}`);
                                        return parsedDate;
                                    }
                                }
                            }

                            const parsed = Date.parse(dateString);
                            if (!isNaN(parsed)) {
                                console.log(`Parsed using Date.parse: ${new Date(parsed)}`);
                                return new Date(parsed);
                            }

                            console.log(`❌ Could not parse date: "${dateString}"`);
                            return null;
                        }

                        function getMonthNumber(monthName) {
                            const months = {
                                'january': 1, 'jan': 1,
                                'february': 2, 'feb': 2,
                                'march': 3, 'mar': 3,
                                'april': 4, 'apr': 4,
                                'may': 5,
                                'june': 6, 'jun': 6,
                                'july': 7, 'jul': 7,
                                'august': 8, 'aug': 8,
                                'september': 9, 'sep': 9,
                                'october': 10, 'oct': 10,
                                'november': 11, 'nov': 11,
                                'december': 12, 'dec': 12
                            };

                            return months[monthName.toLowerCase()] || null;
                        }

                        function showDateMismatchDetailsImproved(parsedDates) {
                            let dateGroups = {};

                            parsedDates.forEach(item => {
                                const dateKey = item.parsedDate.toDateString();
                                if (!dateGroups[dateKey]) {
                                    dateGroups[dateKey] = [];
                                }
                                dateGroups[dateKey].push({
                                    sheet: item.sheet,
                                    location: item.location,
                                    originalText: item.originalText,
                                    formattedDate: item.parsedDate.toLocaleDateString('en-US', {
                                        weekday: 'long',
                                        year: 'numeric',
                                        month: 'long',
                                        day: 'numeric'
                                    })
                                });
                            });

                            console.log("Date Groups:", dateGroups);

                            if (Object.keys(dateGroups).length > 1) {
                                let errorHTML = `
                                    <div class="text-start">
                                        <h5 class="text-danger mb-3">❌ Invoice Date Mismatch Found</h5>
                                        <p class="mb-3">Different invoice dates found in sheets:</p>
                                        <div class="alert alert-warning border-0">
                                `;

                                let groupCounter = 1;
                                for (const [dateKey, sheets] of Object.entries(dateGroups)) {
                                    const dateObj = new Date(dateKey);
                                    const formattedDate = dateObj.toLocaleDateString('en-US', {
                                        weekday: 'long',
                                        year: 'numeric',
                                        month: 'long',
                                        day: 'numeric'
                                    });

                                    errorHTML += `
                                        <div class="mb-3">
                                            <strong>Date Group ${groupCounter}: ${formattedDate}</strong>
                                            <ul class="mb-0 mt-1">
                                    `;

                                    sheets.forEach(sheet => {
                                        errorHTML += `
                                            <li>
                                                <strong>${sheet.sheet}</strong>
                                                (${sheet.location}):
                                                <code>${sheet.originalText}</code>
                                            </li>
                                        `;
                                    });

                                    errorHTML += `
                                            </ul>
                                        </div>
                                    `;
                                    groupCounter++;
                                }

                                errorHTML += `
                                        </div>
                                        <p class="text-muted mt-3">
                                            <i class="fas fa-info-circle me-1"></i>
                                            All invoice dates must have the same date value (format can be different).
                                        </p>
                                    </div>
                                `;

                                Swal.fire({
                                    icon: 'error',
                                    title: 'Invoice Date Mismatch',
                                    html: errorHTML,
                                    confirmButtonText: 'OK',
                                    confirmButtonColor: '#dc3545',
                                    backdrop: true,
                                    allowOutsideClick: false,
                                    width: '800px'
                                });
                            }
                        }

                        // Show Invoice Number validation error (नया)
                        function showInvoiceNumberValidationError(validationResult) {
                            let errorHTML = `
                                <div class="text-start">
                                    <h5 class="text-danger mb-3">❌ Invoice Number Mismatch Found</h5>
                                    <p class="mb-3">Different invoice numbers found across sheets:</p>
                                    <div class="alert alert-warning border-0">
                            `;

                            if (validationResult.mismatches && validationResult.mismatches.length > 1) {
                                validationResult.mismatches.forEach((group, index) => {
                                    errorHTML += `
                                        <div class="mb-3">
                                            <strong>Invoice Number ${index + 1}: ${group.number}</strong>
                                            <ul class="mb-0 mt-1">
                                    `;

                                    group.sheets.forEach(sheet => {
                                        errorHTML += `
                                            <li>
                                                <strong>${sheet.sheet}</strong>
                                                (${sheet.location})
                                            </li>
                                        `;
                                    });

                                    errorHTML += `
                                            </ul>
                                        </div>
                                    `;
                                });
                            }

                            errorHTML += `
                                    </div>
                                    <p class="text-muted mt-3">
                                        <i class="fas fa-info-circle me-1"></i>
                                        All invoice numbers must be the same across all sheets.
                                    </p>
                                </div>
                            `;

                            Swal.fire({
                                icon: 'error',
                                title: 'Invoice Number Mismatch',
                                html: errorHTML,
                                confirmButtonText: 'OK',
                                confirmButtonColor: '#dc3545',
                                backdrop: true,
                                allowOutsideClick: false,
                                width: '800px'
                            });
                        }

                        // Show Date Range validation error (नया)
                              function showDateRangeValidationError(validationResult) {
                let errorHTML = `
                    <div class="text-start">
                        <h5 class="text-danger mb-3">❌ Date Range Mismatch Found in Selected Sheets</h5>
                        <p class="mb-3">Different date ranges found in the sheets you selected:</p>
                        <div class="alert alert-warning border-0">
                `;

                if (validationResult.mismatches && validationResult.mismatches.length > 0) {
                    validationResult.mismatches.forEach((group, index) => {
                        errorHTML += `
                            <div class="mb-3">
                                <strong>Date Range ${index + 1}: <code>${group.dateRangeText}</code></strong>
                                <ul class="mb-0 mt-1">
                        `;

                        group.sheets.forEach(sheet => {
                            errorHTML += `
                                <li>
                                    <strong>${sheet.sheet}</strong>
                                    (${sheet.location})
                                    ${sheet.from ? `<br><small>From: ${sheet.from.toLocaleDateString()}, To: ${sheet.to.toLocaleDateString()}</small>` : ''}
                                </li>
                            `;
                        });

                        errorHTML += `
                                </ul>
                            </div>
                        `;
                    });

                    errorHTML += `
                            </div>
                            <p class="text-muted mt-3">
                                <i class="fas fa-info-circle me-1"></i>
                                <strong>All selected sheets must have identical date ranges.</strong><br>
                                Please either:
                                <ul class="mt-2 mb-0">
                                    <li>Fix the date ranges in Excel to match, OR</li>
                                    <li>Uncheck the sheets with mismatched date ranges from selection</li>
                                </ul>
                            </p>
                        </div>
                    `;
                } else {
                    errorHTML = `
                        <div class="text-start">
                            <h5 class="text-danger mb-3">❌ Date Range Validation Failed</h5>
                            <p class="mb-3">Unable to parse date ranges in selected sheets.</p>
                            <div class="alert alert-warning border-0">
                                <p>Please check the date ranges in your Excel file are in correct format: <code>01-10-2025 TO 31-10-2025</code></p>
                            </div>
                        </div>
                    `;
                }

                Swal.fire({
                    icon: 'error',
                    title: 'Date Range Mismatch',
                    html: errorHTML,
                    confirmButtonText: 'OK',
                    confirmButtonColor: '#dc3545',
                    backdrop: true,
                    allowOutsideClick: false,
                    width: '800px'
                });
            }

                        function showValidationError(message) {
                            Swal.fire({
                                icon: 'error',
                                title: 'Validation Failed',
                                html: `
                                    <div class="text-start">
                                        <h5 class="text-danger mb-3">❌ Cannot Convert to PDF</h5>
                                        <p class="mb-3">${message}</p>
                                        <div class="alert alert-warning border-0">
                                            <i class="fas fa-exclamation-triangle me-2"></i>
                                            <strong>Please fix these issues:</strong>
                                            <ul class="mb-0 mt-2">
                                                ${message.includes('#NAME?') ? '<li>Fix all #NAME? formula errors in Excel file</li>' : ''}
                                                ${message.includes('Invoice Date') ? '<li>Ensure all Invoice Dates have the same value</li>' : ''}
                                                ${message.includes('Invoice Number') ? '<li>Ensure all Invoice Numbers match</li>' : ''}
                                                ${message.includes('Date Range') ? '<li>Ensure all Date Ranges match (01-10-2025 TO 31-10-2025)</li>' : ''}
                                            </ul>
                                        </div>
                                    </div>
                                `,
                                confirmButtonText: 'OK',
                                confirmButtonColor: '#dc3545',
                                backdrop: true,
                                allowOutsideClick: false
                            });
                        }

                        // PDF Upload Functionality
                        mergePdfBtn.addEventListener('click', function() {
                            if (!validateBeforeConversion()) {
                                return;
                            }
                            pdfUploadSection.style.display = 'block';
                            mergedPdfSection.style.display = 'block';
                            this.style.display = 'none';
                            updateMergedPdfList();
                        });

                        cancelUploadBtn.addEventListener('click', function() {
                            pdfUploadSection.style.display = 'none';
                            mergePdfBtn.style.display = 'block';
                        });

                        addMorePdfsBtn.addEventListener('click', function() {
                            pdfFileInput.value = '';
                            pdfFileInput.click();
                        });

                        // File input change
                        pdfFileInput.addEventListener('change', function(e) {
                            const files = Array.from(e.target.files);
                            handlePdfFiles(files);
                        });

                        // Drag and drop functionality
                        pdfFileUploadArea.addEventListener('dragover', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            pdfFileUploadArea.classList.add('drag-over');
                            pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
                        });

                        pdfFileUploadArea.addEventListener('dragenter', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            pdfFileUploadArea.classList.add('drag-over');
                            pdfFileUploadArea.classList.add('border-info', 'bg-info', 'bg-opacity-10');
                        });

                        pdfFileUploadArea.addEventListener('dragleave', function(e) {
                            e.preventDefault();
                            e.stopPropagation();

                            const relatedTarget = e.relatedTarget;
                            if (!pdfFileUploadArea.contains(relatedTarget)) {
                                pdfFileUploadArea.classList.remove('drag-over');
                                pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');
                            }
                        });

                        pdfFileUploadArea.addEventListener('drop', function(e) {
                            e.preventDefault();
                            e.stopPropagation();

                            pdfFileUploadArea.classList.remove('drag-over');
                            pdfFileUploadArea.classList.remove('border-info', 'bg-info', 'bg-opacity-10');

                            const files = Array.from(e.dataTransfer.files).filter(file =>
                                file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                            );

                            if (files.length > 0) {
                                handlePdfFiles(files);
                            } else {
                                showError('Please drop PDF files only.');
                            }
                        });

                        // File upload area click
                        pdfFileUploadArea.addEventListener('click', function(e) {
                            if (e.target === pdfFileUploadArea || !e.target.closest('label')) {
                                pdfFileInput.click();
                            }
                        });

                        function handlePdfFiles(files) {
                            let validFiles = [];
                            let invalidFiles = [];

                            files.forEach(file => {
                                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                                    if (file.size <= 50 * 1024 * 1024) {
                                        validFiles.push(file);
                                    } else {
                                        invalidFiles.push(`${file.name} (File too large)`);
                                    }
                                } else {
                                    invalidFiles.push(`${file.name} (Not a PDF)`);
                                }
                            });

                            if (invalidFiles.length > 0) {
                                showError(`Invalid files:\n${invalidFiles.join('\n')}`);
                            }

                            if (validFiles.length > 0) {
                                uploadPdfFiles(validFiles);
                            }
                        }

                        async function uploadPdfFiles(files) {
                const formData = new FormData();
                files.forEach(file => {
                    formData.append('pdfFiles', file);
                });

                formData.append('sessionId', sessionId);

                try {
                    const response = await fetch('@Url.Action("UploadPdfFiles", "Home")', {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        }
                    });

                    const result = await response.json();
                    if (result.success) {
                        // Append new files to existing list - FIXED HERE
                        if (result.uploadedFiles && result.uploadedFiles.length > 0) {
                            result.uploadedFiles.forEach(file => {
                                uploadedPdfs.push({
                                    name: file.name,
                                    size: file.size,
                                    uniqueName: file.uniqueName
                                });
                            });
                            updateUploadedFilesList();
                            showSuccess(`${files.length} PDF file(s) uploaded successfully`);
                        }

                        pdfFileInput.value = '';
                        mergeUploadedPdfsBtn.style.display = 'block';
                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error uploading PDF files:', error);
                    showError('Error uploading files: ' + error.message);
                }
            }

            function updateUploadedFilesList() {
                uploadedFilesContainer.innerHTML = '';

                if (uploadedPdfs.length === 0) {
                    uploadedFilesList.style.display = 'none';
                    pdfFileNames.textContent = 'No files uploaded';
                    return;
                }

                uploadedFilesList.style.display = 'block';
                pdfFileNames.textContent = `${uploadedPdfs.length} PDF file(s) uploaded`;

                uploadedPdfs.forEach((pdf, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                    listItem.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-file-pdf text-danger me-3 fs-5"></i>
                            <div>
                                <div class="fw-bold">${pdf.name}</div>
                                <small class="text-muted">${(pdf.size / 1024).toFixed(2)} KB</small>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger remove-pdf-btn" data-index="${index}">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    uploadedFilesContainer.appendChild(listItem);
                });

                document.querySelectorAll('.remove-pdf-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const index = parseInt(this.getAttribute('data-index'));
                        removePdfFile(index);
                    });
                });
            }

                        function removePdfFile(index) {
                            if (index >= 0 && index < uploadedPdfs.length) {
                                fetch('@Url.Action("RemovePdfFile", "Home")', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                    },
                                    body: JSON.stringify({
                                        sessionId: sessionId,
                                        fileName: uploadedPdfs[index].name
                                    })
                                }).then(response => response.json())
                                  .then(result => {
                                      if (result.success) {
                                          uploadedPdfs.splice(index, 1);
                                          updateUploadedFilesList();
                                          showSuccess('PDF file removed');
                                      }
                                  });
                            }
                        }

                        // mergeUploadedPdfsBtn.addEventListener('click', async function() {
                        //     if (uploadedPdfs.length === 0) {
                        //         showError('Please upload PDF files first.');
                        //         return;
                        //     }

                        //     this.disabled = true;
                        //     this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

                        //     try {
                        //         const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
                        //             method: 'POST',
                        //             headers: {
                        //                 'Content-Type': 'application/json',
                        //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        //             },
                        //             body: JSON.stringify({
                        //                 sessionId: sessionId
                        //             })
                        //         });

                        //         const result = await response.json();
                        //         if (result.success) {
                        //             mergedPdfs.push({
                        //                 name: result.fileName,
                        //                 size: result.fileSize,
                        //                 pages: result.totalPages,
                        //                 timestamp: new Date().toLocaleString()
                        //             });

                        //             updateMergedPdfList();
                        //             showSuccess(`PDF files merged successfully (${result.totalPages} pages)`);

                        //             uploadedPdfs = [];
                        //             updateUploadedFilesList();
                        //             pdfUploadSection.style.display = 'none';
                        //             mergePdfBtn.style.display = 'block';
                        //         } else {
                        //             showError(result.message);
                        //         }
                        //     } catch (error) {
                        //         console.error('Error merging PDFs:', error);
                        //         showError('Error merging PDFs: ' + error.message);
                        //     } finally {
                        //         this.disabled = false;
                        //         this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
                        //     }
                        // });

            //                     mergeUploadedPdfsBtn.addEventListener('click', async function() {
            //     if (uploadedPdfs.length === 0) {
            //         showError('Please upload PDF files first.');
            //         return;
            //     }

            //     this.disabled = true;
            //     this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

            //     try {
            //         const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
            //             method: 'POST',
            //             headers: {
            //                 'Content-Type': 'application/json',
            //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
            //             },
            //             body: JSON.stringify({
            //                 sessionId: sessionId
            //             })
            //         });

            //         const result = await response.json();
            //         if (result.success) {
            //             // ✅ IMPORTANT CHANGE: Always update the same merged PDF
            //             if (mergedPdfs.length === 0) {
            //                 // First time merge - add new merged PDF
            //                 mergedPdfs.push({
            //                     name: result.fileName,
            //                     size: result.fileSize,
            //                     pages: result.totalPages,
            //                     timestamp: new Date().toLocaleString()
            //                 });
            //             } else {
            //                 // Subsequent merges - update the existing merged PDF
            //                 mergedPdfs[0] = {
            //                     name: result.fileName,
            //                     size: result.fileSize,
            //                     pages: result.totalPages,
            //                     timestamp: new Date().toLocaleString()
            //                 };
            //             }

            //             updateMergedPdfList();
            //             showSuccess(`PDF files merged successfully (${result.totalPages} pages)`);

            //             // Clear uploaded files after successful merge
            //             uploadedPdfs = [];
            //             updateUploadedFilesList();

            //             // Keep the PDF upload section open for more uploads
            //             pdfFileInput.value = '';
            //             pdfFileNames.textContent = 'No files uploaded';

            //         } else {
            //             showError(result.message);
            //         }
            //     } catch (error) {
            //         console.error('Error merging PDFs:', error);
            //         showError('Error merging PDFs: ' + error.message);
            //     } finally {
            //         this.disabled = false;
            //         this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
            //     }
            // });


    //         mergeUploadedPdfsBtn.addEventListener('click', async function() {
    //     if (uploadedPdfs.length === 0) {
    //         showError('Please upload PDF files first.');
    //         return;
    //     }

    //     this.disabled = true;
    //     this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

    //     try {
    //         const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
    //             method: 'POST',
    //             headers: {
    //                 'Content-Type': 'application/json',
    //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
    //             },
    //             body: JSON.stringify({
    //                 sessionId: sessionId
    //             })
    //         });

    //         const result = await response.json();
    //         if (result.success) {
    //             // ✅ CRITICAL: REPLACE the merged PDFs array, don't push
    //             mergedPdfs = [{
    //                 name: result.fileName,
    //                 size: result.fileSize,
    //                 pages: result.totalPages,
    //                 timestamp: new Date().toLocaleString()
    //             }];

    //             updateMergedPdfList();
    //             showSuccess(`PDF files merged successfully (${result.totalPages} pages)`);

    //             // Clear uploaded files
    //             uploadedPdfs = [];
    //             updateUploadedFilesList();

    //         } else {
    //             showError(result.message);
    //         }
    //     } catch (error) {
    //         console.error('Error merging PDFs:', error);
    //         showError('Error merging PDFs: ' + error.message);
    //     } finally {
    //         this.disabled = false;
    //         this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
    //     }

    // });


    // mergeUploadedPdfsBtn.addEventListener('click', async function() {
    //     if (uploadedPdfs.length === 0) {
    //         showError('Please upload PDF files first.');
    //         return;
    //     }

    //     this.disabled = true;
    //     this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

    //     try {
    //         const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
    //             method: 'POST',
    //             headers: {
    //                 'Content-Type': 'application/json',
    //                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
    //             },
    //             body: JSON.stringify({
    //                 sessionId: sessionId
    //             })
    //         });

    //         const result = await response.json();
    //         if (result.success) {
    //             // ✅ IMPORTANT: COMPLETELY REPLACE the array
    //             mergedPdfs = [{
    //                 name: result.fileName + " (Combined)",
    //                 size: result.fileSize,
    //                 pages: result.totalPages,
    //                 timestamp: new Date().toLocaleString()
    //             }];

    //             updateMergedPdfList();
    //             showSuccess(`Successfully merged ${result.totalPages} pages`);

    //             // ✅ Clear ALL uploaded files from UI
    //             uploadedPdfs = [];
    //             updateUploadedFilesList();

    //             // Hide the uploaded files section
    //             uploadedFilesList.style.display = 'none';
    //             pdfFileNames.textContent = 'Files merged successfully';

    //         } else {
    //             showError(result.message);
    //         }
    //     } catch (error) {
    //         console.error('Error merging PDFs:', error);
    //         showError('Error merging PDFs: ' + error.message);
    //     } finally {
    //         this.disabled = false;
    //         this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
    //     }
    // });

            mergeUploadedPdfsBtn.addEventListener('click', async function() {
                if (uploadedPdfs.length === 0) {
                    showError('Please upload PDF files first.');
                    return;
                }

                this.disabled = true;
                this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Merging...';

                try {
                    const response = await fetch('@Url.Action("MergeUploadedPdfs", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        // ✅ Update merged PDFs array
                        mergedPdfs = [{
                            name: "Combined PDF (" + result.totalPages + " pages)",
                            size: result.fileSize,
                            pages: result.totalPages,
                            timestamp: new Date().toLocaleString()
                        }];

                        updateMergedPdfList();
                        showSuccess(result.message);

                        // ✅ Clear uploaded files
                        uploadedPdfs = [];
                        updateUploadedFilesList();

                    } else {
                        showError(result.message);
                    }
                } catch (error) {
                    console.error('Error merging PDFs:', error);
                    showError('Error merging PDFs: ' + error.message);
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<i class="fas fa-merge me-2"></i>Merge Uploaded PDFs';
                }
            });

                        // function updateMergedPdfList() {
                        //     mergedPdfList.innerHTML = '';

                        //     if (mergedPdfs.length === 0) {
                        //         mergedPdfSection.style.display = 'none';
                        //         return;
                        //     }

                        //     mergedPdfSection.style.display = 'block';

                        //     mergedPdfs.forEach((pdf, index) => {
                        //         const listItem = document.createElement('div');
                        //         listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                        //         listItem.innerHTML = `
                        //             <div class="d-flex align-items-center">
                        //                 <i class="fas fa-file-pdf text-success me-3 fs-5"></i>
                        //                 <div>
                        //                     <div class="fw-bold">${pdf.name}</div>
                        //                     <div class="small text-muted">
                        //                         <span>${pdf.pages} pages • ${(pdf.size / 1024).toFixed(2)} KB</span>
                        //                         <br>
                        //                         <span>Created: ${pdf.timestamp}</span>
                        //                     </div>
                        //                 </div>
                        //             </div>
                        //             <div>
                        //                 <button type="button" class="btn btn-sm btn-outline-primary download-merged-btn me-2" data-index="${index}">
                        //                     <i class="fas fa-download"></i>
                        //                 </button>
                        //                 <button type="button" class="btn btn-sm btn-outline-danger remove-merged-btn" data-index="${index}">
                        //                     <i class="fas fa-times"></i>
                        //                 </button>
                        //             </div>
                        //         `;
                        //         mergedPdfList.appendChild(listItem);
                        //     });

                        //     document.querySelectorAll('.download-merged-btn').forEach(btn => {
                        //         btn.addEventListener('click', function() {
                        //             const index = parseInt(this.getAttribute('data-index'));
                        //             downloadMergedPdf(index);
                        //         });
                        //     });

                        //     document.querySelectorAll('.remove-merged-btn').forEach(btn => {
                        //         btn.addEventListener('click', function() {
                        //             const index = parseInt(this.getAttribute('data-index'));
                        //             removeMergedPdf(index);
                        //         });
                        //     });
                        // }


                        function updateMergedPdfList() {
        mergedPdfList.innerHTML = '';

        if (mergedPdfs.length === 0) {
            mergedPdfSection.style.display = 'none';
            return;
        }

        mergedPdfSection.style.display = 'block';

        // ✅ Always show only the latest merged PDF
        const latestPdf = mergedPdfs[0]; // Should be only one

        const listItem = document.createElement('div');
        listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
        listItem.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="fas fa-file-pdf text-success me-3 fs-5"></i>
                <div>
                    <div class="fw-bold">${latestPdf.name} (Combined)</div>
                    <div class="small text-muted">
                        <span>${latestPdf.pages} pages • ${(latestPdf.size / 1024).toFixed(2)} KB</span>
                        <br>
                        <span>Last Updated: ${latestPdf.timestamp}</span>
                    </div>
                </div>
            </div>
            <div>
                <button type="button" class="btn btn-sm btn-outline-primary download-merged-btn me-2" data-index="0">
                    <i class="fas fa-download"></i>
                </button>
                <button type="button" class="btn btn-sm btn-outline-danger remove-merged-btn" data-index="0">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        mergedPdfList.appendChild(listItem);

        document.querySelector('.download-merged-btn').addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            downloadMergedPdf(index);
        });

        document.querySelector('.remove-merged-btn').addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            removeMergedPdf(index);
        });
    }


                        async function downloadMergedPdf(index) {
                            if (index >= 0 && index < mergedPdfs.length) {
                                try {
                                    const response = await fetch('@Url.Action("DownloadMergedPdf", "Home")', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                        },
                                        body: JSON.stringify({
                                            sessionId: sessionId,
                                            fileName: mergedPdfs[index].name
                                        })
                                    });

                                    const result = await response.json();
                                    if (result.success) {
                                        const link = document.createElement('a');
                                        link.href = 'data:application/pdf;base64,' + result.pdfData;
                                        link.download = result.fileName;
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                    }
                                } catch (error) {
                                    console.error('Error downloading merged PDF:', error);
                                    showError('Error downloading PDF: ' + error.message);
                                }
                            }
                        }

                        // async function removeMergedPdf(index) {
                        //     if (index >= 0 && index < mergedPdfs.length) {
                        //         try {
                        //             const response = await fetch('@Url.Action("RemoveMergedPdf", "Home")', {
                        //                 method: 'POST',
                        //                 headers: {
                        //                     'Content-Type': 'application/json',
                        //                     'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        //                 },
                        //                 body: JSON.stringify({
                        //                     sessionId: sessionId,
                        //                     fileName: mergedPdfs[index].name
                        //                 })
                        //             });

                        //             const result = await response.json();
                        //             if (result.success) {
                        //                 mergedPdfs.splice(index, 1);
                        //                 updateMergedPdfList();
                        //                 showSuccess('Merged PDF removed');
                        //             }
                        //         } catch (error) {
                        //             console.error('Error removing merged PDF:', error);
                        //         }
                        //     }
                        // }

                        async function removeMergedPdf(index) {
        if (index >= 0 && index < mergedPdfs.length) {
            if (confirm('Are you sure you want to remove the merged PDF? All uploaded PDFs will be deleted.')) {
                try {
                    const response = await fetch('@Url.Action("RemoveMergedPdf", "Home")', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            sessionId: sessionId,
                            fileName: mergedPdfs[index].name
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        // Clear all merged PDFs
                        mergedPdfs = [];
                        updateMergedPdfList();
                        showSuccess('Merged PDF removed. All uploaded files cleared.');
                    }
                } catch (error) {
                    console.error('Error removing merged PDF:', error);
                }
            }
        }
    }


            //             pdfPreviewBtn.addEventListener('click', async function() {
            //     if (!validateBeforeConversion()) {
            //         return;
            //     }

            //     if (!sessionId) {
            //         showError('Session information not available.');
            //         return;
            //     }

            //     const selectedSheets = getSelectedSheets();
            //     if (selectedSheets.length === 0) {
            //         showError('Please select at least one sheet for PDF preview.');
            //         return;
            //     }

            //     pdfPreviewBtn.disabled = true;
            //     pdfPreviewBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating PDF...';

            //     try {
            //         const pageOrderData = [];

            //         if (pageOrder && pageOrder.length > 0) {
            //             pageOrder.forEach(p => {
            //                 pageOrderData.push({
            //                     OriginalPage: p.originalPage,
            //                     CurrentOrder: p.currentOrder,
            //                     Visible: p.visible,
            //                     Orientation: p.orientation || 'portrait',
            //                     Rotation: p.rotation || 0
            //                 });
            //             });
            //         }

            //         // ALWAYS include merged PDFs if they exist
            //         const includeMergedPdfs = true; // Changed to always include

            //         const result = await generatePdfPreviewWithFitToPage(
            //             sessionId,
            //             selectedSheets,
            //             pageOrderData.length > 0 ? pageOrderData : null,
            //             includeMergedPdfs);

            //         if (result.success) {
            //             pdfData = result.pdfData;
            //             pdfFileName = result.fileName;

            //             pdfPreviewModal.show();
            //             await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName);
            //             showSuccess('PDF generated with FitToPage applied!');
            //         } else {
            //             showError(result.message || 'Failed to generate PDF preview.');
            //         }
            //     } catch (error) {
            //         console.error('Error generating PDF preview:', error);
            //         showError('Error generating PDF preview: ' + error.message);
            //     } finally {
            //         pdfPreviewBtn.disabled = false;
            //         pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager';
            //     }
            // });





            // ✅ Modified: displayPdfPreview function
async function displayPdfPreviewFromUrl(pdfUrl, fileName) {
    console.log(`📄 Loading PDF from URL: ${pdfUrl}`);
    
    // Show loading
    pdfPreviewContainer.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x text-white mb-3"></i><p class="text-white">Loading PDF from server...</p></div>';
    thumbnailContainer.innerHTML = '';
    
    // Reset variables
    pageOrder = [];
    currentOrientations = {};
    currentRotations = {};
    
    try {
        // ✅ Load PDF directly from URL using PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // ✅ Use URL loading with range requests enabled
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            withCredentials: false,
            rangeChunkSize: 65536, // 64KB chunks for better streaming
            disableAutoFetch: false,
            disableStream: false
        });
        
        const pdfDoc_ = await loadingTask.promise;
        pdfDoc = pdfDoc_;
        currentPdfUrl = pdfUrl; // Store URL for reference
        
        const totalPages = pdfDoc.numPages;
        console.log(`✅ PDF loaded from URL: ${totalPages} pages`);
        
        // Initialize page order and settings
        for (let i = 1; i <= totalPages; i++) {
            try {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 1.0 });
                const isLandscape = viewport.width > viewport.height;
                
                currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                currentRotations[i] = 0;
                
                pageOrder.push({
                    originalPage: i,
                    currentOrder: i,
                    orientation: isLandscape ? 'landscape' : 'portrait',
                    rotation: 0,
                    visible: true
                });
            } catch (error) {
                console.error(`Error loading page ${i}:`, error);
                pageOrder.push({
                    originalPage: i,
                    currentOrder: i,
                    orientation: 'portrait',
                    rotation: 0,
                    visible: true
                });
            }
        }
        
        console.log(`🆕 Initialized pageOrder with ${pageOrder.length} pages`);
        
        // Update UI
        pageCountSpan.textContent = totalPages;
        totalPagesCount.textContent = totalPages;
        totalPagesDisplay2.textContent = totalPages;
        pageCountBadge.textContent = totalPages;
        visiblePagesCount.textContent = totalPages;
        visiblePagesDisplay.textContent = totalPages;
        pageNumInput.max = totalPages;
        pageNumInput.value = 1;
        currentPageDisplay.textContent = '1';
        currentPageInfo.textContent = '1';
        rotationDisplay.textContent = '0°';
        
        updateOrientationDisplay(1);
        updateOrientationSummary();
        
        pdfControls.style.display = 'block';
        pageInfoBar.style.display = 'block';
        downloadFinalPdfBtn.style.display = 'block';
        
        pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';
        
        pageNum = 1;
        await renderPage(pageNum);
        
        await createThumbnails();
        initializeThumbnailSortable();
        
        console.log('✅ PDF preview loaded successfully from URL');
        
    } catch (error) {
        console.error('❌ Error loading PDF from URL:', error);
        
        // Fallback to error message
        pdfPreviewContainer.innerHTML = `
            <div class="alert alert-danger m-3">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Error loading PDF from server: ${error.message}
                <br>
                <small>URL: ${pdfUrl}</small>
            </div>
        `;
        
        // Try alternative method for large files
        if (error.message.includes('range') || error.message.includes('NetworkError')) {
            console.log('⚠️ Trying alternative loading method...');
            await tryAlternativeLoading(pdfUrl);
        }
    }
}

// ✅ Alternative loading method for very large files
async function tryAlternativeLoading(pdfUrl) {
    try {
        // Load PDF in chunks using fetch
        const response = await fetch(pdfUrl);
        const blob = await response.blob();
        
        // Create object URL
        const objectUrl = URL.createObjectURL(blob);
        
        // Load with PDF.js
        const loadingTask = pdfjsLib.getDocument(objectUrl);
        const pdfDoc_ = await loadingTask.promise;
        pdfDoc = pdfDoc_;
        
        console.log(`✅ PDF loaded via blob URL: ${pdfDoc.numPages} pages`);
        
        // Cleanup object URL
        URL.revokeObjectURL(objectUrl);
        
        // Continue with normal initialization...
        // ... rest of the initialization code ...
        
    } catch (error) {
        console.error('❌ Alternative loading also failed:', error);
    }
}





            pdfPreviewBtn.addEventListener('click', async function() {
        if (!validateBeforeConversion()) {
            return;
        }

        if (!sessionId) {
            showError('Session information not available.');
            return;
        }

        const selectedSheets = getSelectedSheets();
        if (selectedSheets.length === 0) {
            showError('Please select at least one sheet for PDF preview.');
            return;
        }

        // ✅ Show loading modal with progress
        Swal.fire({
            title: 'Generating PDF Preview',
            html: `
                <div class="text-start">
                    <div class="mb-2">
                        <div class="d-flex justify-content-between">
                            <small>Preparing preview...</small>
                            <small id="previewProgress">0%</small>
                        </div>
                        <div class="progress" style="height: 10px;">
                            <div id="previewProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div id="previewStatus" class="small text-muted mt-2">Initializing...</div>
                </div>
            `,
            showConfirmButton: false,
            allowOutsideClick: false,
            allowEscapeKey: false,
            didOpen: () => {
                // Update progress every 500ms
                let progress = 0;
                const progressInterval = setInterval(() => {
                    if (progress < 90) {
                        progress += 5;
                        document.getElementById('previewProgress').textContent = `${progress}%`;
                        document.getElementById('previewProgressBar').style.width = `${progress}%`;

                        // Update status messages
                        const statusMessages = [
                            "Converting Excel to PDF...",
                            "Merging with uploaded files...",
                            "Applying page settings...",
                            "Finalizing preview..."
                        ];
                        const statusIndex = Math.min(Math.floor(progress / 25), 3);
                        document.getElementById('previewStatus').textContent = statusMessages[statusIndex];
                    }
                }, 500);

                // Store interval for cleanup
                Swal.getPopup().setAttribute('data-progress-interval', progressInterval);
            },
            willClose: () => {
                // Clear interval
                const interval = Swal.getPopup().getAttribute('data-progress-interval');
                if (interval) clearInterval(interval);
            }
        });

        try {
            const pageOrderData = [];

            if (pageOrder && pageOrder.length > 0) {
                pageOrder.forEach(p => {
                    pageOrderData.push({
                        OriginalPage: p.originalPage,
                        CurrentOrder: p.currentOrder,
                        Visible: p.visible,
                        Orientation: p.orientation || 'portrait',
                        Rotation: p.rotation || 0
                    });
                });
            }

            const includeMergedPdfs = true;

            const result = await generatePdfPreviewWithFitToPage(
                sessionId,
                selectedSheets,
                pageOrderData.length > 0 ? pageOrderData : null,
                includeMergedPdfs);

            if (result.success) {
                Swal.close();

                    if (result.pdfUrl) {
                        pdfData = null; // Clear base64 data
                        pdfFileName = result.fileName;
                        pdfPreviewModal.show();

                        // ✅ Load from URL
                        await displayPdfPreviewFromUrl(result.pdfUrl, result.fileName);
                        showSuccess('PDF generated successfully!');
                    } else {
                        showError('Preview URL not available.');
                    }
                
                // pdfData = result.pdfData;
                // pdfFileName = result.fileName;

                // pdfPreviewModal.show();
                // await displayPdfPreviewWithExistingSettings(result.pdfData, result.fileName);
                // showSuccess('PDF generated successfully!');
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Preview Generation Failed',
                    text: result.message || 'Failed to generate preview',
                    confirmButtonText: 'OK'
                });
            }
        } catch (error) {
            console.error('Error generating PDF preview:', error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'Preview generation failed: ' + error.message,
                confirmButtonText: 'OK'
            });
        } finally {
            pdfPreviewBtn.disabled = false;
            pdfPreviewBtn.innerHTML = '<i class="fas fa-eye me-2"></i>PDF Preview Manager';
        }
    });





                        async function generatePdfPreviewWithFitToPage(sessionId, selectedSheets, pageOrderData, includeMergedPdfs = false) {
                            // const formattedPageOrderData = pageOrderData
                            //     ? pageOrderData.map(p => ({
                            //         OriginalPage: p.originalPage || p.OriginalPage || 0,
                            //         CurrentOrder: p.currentOrder || p.CurrentOrder || 0,
                            //         Visible: p.visible !== undefined ? p.visible : (p.Visible !== undefined ? p.Visible : true),
                            //         Orientation: p.orientation || p.Orientation || 'portrait',
                            //         Rotation: p.rotation || p.Rotation || 0
                            //     }))
                            //     : null;

                                                const formattedPageOrderData = pageOrderData
                            ? pageOrderData.map(p => ({
                                OriginalPage: p.OriginalPage || p.originalPage || 0,
                                CurrentOrder: p.CurrentOrder || p.currentOrder || 0,
                                Visible: p.Visible !== undefined ? p.Visible : (p.visible !== undefined ? p.visible : true),
                                Orientation: p.Orientation || p.orientation || 'portrait',
                                Rotation: p.Rotation || p.rotation || 0
                            }))
                            : null;

                            const requestBody = {
                                sessionId: sessionId,
                                selectedSheets: selectedSheets,
                                includeMergedPdfs: includeMergedPdfs
                            };

                            if (formattedPageOrderData) {
                                requestBody.pageOrderData = formattedPageOrderData;
                            }

                            const response = await fetch('@Url.Action("GeneratePdfPreviewWithFitToPage", "Home")', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                },
                                body: JSON.stringify(requestBody)
                            });

                            return await response.json();
                        }

                        async function displayPdfPreviewWithExistingSettings(pdfData, fileName) {
                            console.log('📱 Loading PDF with existing page settings...');

                            const byteCharacters = atob(pdfData);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: 'application/pdf' });

                            if (currentPdfUrl) {
                                URL.revokeObjectURL(currentPdfUrl);
                            }
                            currentPdfUrl = URL.createObjectURL(blob);

                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                            const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

                            try {
                                const pdfDoc_ = await loadingTask.promise;
                                pdfDoc = pdfDoc_;
                                const totalPages = pdfDoc.numPages;

                                console.log(`📊 PDF loaded: ${totalPages} pages`);

                                pageOrder = [];
                                currentOrientations = {};
                                currentRotations = {};

                                for (let i = 1; i <= totalPages; i++) {
                                    try {
                                        const page = await pdfDoc.getPage(i);
                                        const viewport = page.getViewport({ scale: 1.0 });
                                        const isLandscape = viewport.width > viewport.height;

                                        currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                                        currentRotations[i] = 0;

                                        pageOrder.push({
                                            originalPage: i,
                                            currentOrder: i,
                                            orientation: isLandscape ? 'landscape' : 'portrait',
                                            rotation: 0,
                                            visible: true
                                        });
                                    } catch (error) {
                                        console.error(`Error loading page ${i}:`, error);
                                        pageOrder.push({
                                            originalPage: i,
                                            currentOrder: i,
                                            orientation: 'portrait',
                                            rotation: 0,
                                            visible: true
                                        });
                                    }
                                }

                                console.log(`🆕 Initialized pageOrder with ${pageOrder.length} pages`);

                                pageCountSpan.textContent = totalPages;
                                totalPagesCount.textContent = totalPages;
                                totalPagesDisplay2.textContent = totalPages;
                                pageCountBadge.textContent = totalPages;
                                visiblePagesCount.textContent = totalPages;
                                visiblePagesDisplay.textContent = totalPages;
                                pageNumInput.max = totalPages;
                                pageNumInput.value = 1;
                                currentPageDisplay.textContent = '1';
                                currentPageInfo.textContent = '1';
                                rotationDisplay.textContent = '0°';

                                updateOrientationDisplay(1);
                                updateOrientationSummary();

                                pdfControls.style.display = 'block';
                                pageInfoBar.style.display = 'block';
                                downloadFinalPdfBtn.style.display = 'block';

                                pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                                pageNum = 1;
                                await renderPage(pageNum);

                                await createThumbnails();
                                initializeThumbnailSortable();

                            } catch (error) {
                                console.error('Error loading PDF:', error);
                                pdfPreviewContainer.innerHTML = `
                                    <div class="alert alert-danger m-3">
                                        <i class="fas fa-exclamation-triangle me-2"></i>
                                        Error loading PDF: ${error.message}
                                    </div>
                                `;
                            }
                        }

                        async function displayPdfPreview(pdfData, fileName) {
                            pdfPreviewContainer.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x text-white mb-3"></i><p class="text-white">Loading PDF...</p></div>';
                            thumbnailContainer.innerHTML = '';
                            pageOrder = [];
                            currentOrientations = {};
                            currentRotations = {};

                            const byteCharacters = atob(pdfData);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: 'application/pdf' });

                            if (currentPdfUrl) {
                                URL.revokeObjectURL(currentPdfUrl);
                            }
                            currentPdfUrl = URL.createObjectURL(blob);

                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                            const loadingTask = pdfjsLib.getDocument(currentPdfUrl);

                            try {
                                const pdfDoc_ = await loadingTask.promise;
                                pdfDoc = pdfDoc_;
                                const totalPages = pdfDoc.numPages;

                                pageOrder = [];
                                for (let i = 1; i <= totalPages; i++) {
                                    const page = await pdfDoc.getPage(i);
                                    const viewport = page.getViewport({ scale: 1.0 });
                                    const isLandscape = viewport.width > viewport.height;

                                    currentOrientations[i] = isLandscape ? 'landscape' : 'portrait';
                                    currentRotations[i] = 0;

                                    pageOrder.push({
                                        originalPage: i,
                                        currentOrder: i,
                                        orientation: isLandscape ? 'landscape' : 'portrait',
                                        rotation: 0,
                                        visible: true
                                    });
                                }

                                pageCountSpan.textContent = totalPages;
                                totalPagesCount.textContent = totalPages;
                                totalPagesDisplay2.textContent = totalPages;
                                pageCountBadge.textContent = totalPages;
                                visiblePagesCount.textContent = totalPages;
                                visiblePagesDisplay.textContent = totalPages;
                                pageNumInput.max = totalPages;
                                pageNumInput.value = 1;
                                currentPageDisplay.textContent = '1';
                                currentPageInfo.textContent = '1';
                                rotationDisplay.textContent = '0°';

                                updateOrientationDisplay(1);
                                updateOrientationSummary();

                                pdfControls.style.display = 'block';
                                pageInfoBar.style.display = 'block';
                                downloadFinalPdfBtn.style.display = 'block';

                                pdfPreviewContainer.innerHTML = '<div id="canvas-container" class="d-flex justify-content-center align-items-center p-4"></div>';

                                pageNum = 1;
                                await renderPage(pageNum);

                                await createThumbnails();
                                initializeThumbnailSortable();

                            } catch (error) {
                                console.error('Error loading PDF:', error);
                                pdfPreviewContainer.innerHTML = `
                                    <div class="alert alert-danger m-3">
                                        <i class="fas fa-exclamation-triangle me-2"></i>
                                        Error loading PDF: ${error.message}
                                    </div>
                                `;
                            }
                        }

                        async function renderPage(num) {
                            pageRendering = true;

                            const pageData = pageOrder.find(p => p.originalPage === num && p.visible);
                            if (!pageData) {
                                const nextVisible = pageOrder.find(p => p.visible && p.originalPage > num);
                                if (nextVisible) {
                                    pageNum = nextVisible.originalPage;
                                    queueRenderPage(pageNum);
                                    return;
                                }
                            }

                            try {
                                const page = await pdfDoc.getPage(num);
                                const viewport = page.getViewport({ scale: 1.0 });
                                const originalWidth = viewport.width;
                                const originalHeight = viewport.height;

                                const currentOrientation = currentOrientations[num] || 'portrait';
                                const currentRotation = currentRotations[num] || 0;

                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                const containerWidth = pdfPreviewContainer.clientWidth - 100;
                                const containerHeight = pdfPreviewContainer.clientHeight - 100;

                                let baseScaleX = containerWidth / originalWidth;
                                let baseScaleY = containerHeight / originalHeight;
                                let baseScale = Math.min(baseScaleX, baseScaleY) * 0.9;

                                let renderWidth, renderHeight;

                                if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                                    renderWidth = originalHeight * baseScale;
                                    renderHeight = originalWidth * baseScale;
                                } else {
                                    renderWidth = originalWidth * baseScale;
                                    renderHeight = originalHeight * baseScale;
                                }

                                let finalScale = baseScale;

                                if (currentRotation !== 0) {
                                    const rotatedWidth = Math.abs(renderWidth * Math.cos(currentRotation * Math.PI / 180)) +
                                                      Math.abs(renderHeight * Math.sin(currentRotation * Math.PI / 180));
                                    const rotatedHeight = Math.abs(renderWidth * Math.sin(currentRotation * Math.PI / 180)) +
                                                       Math.abs(renderHeight * Math.cos(currentRotation * Math.PI / 180));

                                    const rotatedScaleX = containerWidth / rotatedWidth;
                                    const rotatedScaleY = containerHeight / rotatedHeight;
                                    finalScale = Math.min(rotatedScaleX, rotatedScaleY) * 0.9;
                                }

                                if (currentRotation === 90 || currentRotation === -90 || currentRotation === 270) {
                                    renderWidth = originalHeight * finalScale;
                                    renderHeight = originalWidth * finalScale;
                                } else {
                                    renderWidth = originalWidth * finalScale;
                                    renderHeight = originalHeight * finalScale;
                                }

                                let canvasWidth = renderWidth;
                                let canvasHeight = renderHeight;

                                if (currentRotation !== 0) {
                                    const padding = 50;
                                    canvasWidth = renderWidth + padding * 2;
                                    canvasHeight = renderHeight + padding * 2;
                                }

                                canvas.width = canvasWidth;
                                canvas.height = canvasHeight;

                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);

                                ctx.save();
                                ctx.translate(canvas.width / 2, canvas.height / 2);
                                ctx.rotate(currentRotation * Math.PI / 180);
                                ctx.translate(-renderWidth / 2, -renderHeight / 2);

                                const renderContext = {
                                    canvasContext: ctx,
                                    viewport: page.getViewport({ scale: finalScale })
                                };

                                await page.render(renderContext).promise;
                                ctx.restore();

                                const container = document.getElementById('canvas-container');
                                container.innerHTML = '';

                                const wrapperDiv = document.createElement('div');
                                wrapperDiv.style.position = 'relative';
                                wrapperDiv.style.border = '2px solid ' + (currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd');
                                wrapperDiv.style.borderRadius = '8px';
                                wrapperDiv.style.backgroundColor = 'white';
                                wrapperDiv.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
                                wrapperDiv.style.padding = '15px';
                                wrapperDiv.style.overflow = 'hidden';

                                const orientationLabel = document.createElement('div');
                                orientationLabel.className = 'page-info-label orientation-label';
                                orientationLabel.innerHTML = `<i class="fas ${currentOrientation === 'landscape' ? 'fa-landscape' : 'fa-portrait'}"></i> ${currentOrientation.toUpperCase()}`;
                                orientationLabel.style.position = 'absolute';
                                orientationLabel.style.top = '5px';
                                orientationLabel.style.right = '5px';
                                orientationLabel.style.backgroundColor = currentOrientation === 'landscape' ? '#ffc107' : '#0d6efd';
                                orientationLabel.style.color = 'white';
                                orientationLabel.style.padding = '2px 8px';
                                orientationLabel.style.borderRadius = '4px';
                                orientationLabel.style.fontSize = '12px';
                                orientationLabel.style.zIndex = '100';
                                wrapperDiv.appendChild(orientationLabel);

                                if (currentRotation !== 0) {
                                    const rotationLabel = document.createElement('div');
                                    rotationLabel.className = 'page-info-label rotation-label';
                                    rotationLabel.innerHTML = `<i class="fas fa-sync-alt"></i> ${currentRotation}°`;
                                    rotationLabel.style.position = 'absolute';
                                    rotationLabel.style.top = '5px';
                                    rotationLabel.style.left = '5px';
                                    rotationLabel.style.backgroundColor = '#dc3545';
                                    rotationLabel.style.color = 'white';
                                    rotationLabel.style.padding = '2px 8px';
                                    rotationLabel.style.borderRadius = '4px';
                                    rotationLabel.style.fontSize = '12px';
                                    rotationLabel.style.zIndex = '100';
                                    wrapperDiv.appendChild(rotationLabel);
                                }

                                const canvasContainer = document.createElement('div');
                                canvasContainer.style.width = '100%';
                                canvasContainer.style.height = '100%';
                                canvasContainer.style.display = 'flex';
                                canvasContainer.style.justifyContent = 'center';
                                canvasContainer.style.alignItems = 'center';
                                canvasContainer.style.overflow = 'hidden';

                                canvasContainer.appendChild(canvas);
                                wrapperDiv.appendChild(canvasContainer);
                                container.appendChild(wrapperDiv);

                                pageRendering = false;

                                if (pageNumPending !== null) {
                                    renderPage(pageNumPending);
                                    pageNumPending = null;
                                }

                                const visiblePageNumber = pageOrder.filter(p => p.visible && p.originalPage <= num).length;
                                pageNumInput.value = visiblePageNumber;
                                currentPageDisplay.textContent = visiblePageNumber;
                                currentPageInfo.textContent = visiblePageNumber;
                                updateOrientationDisplay(num);
                                updateRotationDisplay(num);
                                updateUIControls(num);

                            } catch (error) {
                                console.error('Error rendering page:', error);
                            }
                        }

                        function queueRenderPage(num) {
                            if (pageRendering) {
                                pageNumPending = num;
                            } else {
                                renderPage(num);
                            }
                        }

                        function updateOrientationDisplay(pageNum) {
                            const orientation = currentOrientations[pageNum] || 'portrait';
                            orientationDisplay.textContent = orientation === 'portrait' ? 'Portrait' : 'Landscape';
                        }

                        function updateRotationDisplay(pageNum) {
                            const rotation = currentRotations[pageNum] || 0;
                            rotationDisplay.textContent = rotation + '°';
                        }

                        function updateUIControls(pageNum) {
                            document.querySelectorAll('.orientation-btn').forEach(btn => {
                                btn.classList.remove('active');
                                if (btn.dataset.orientation === (currentOrientations[pageNum] || 'portrait')) {
                                    btn.classList.add('active');
                                }
                            });

                            updateThumbnailRotationBadge(pageNum, currentRotations[pageNum] || 0);
                        }

                        async function createThumbnails() {
                            thumbnailContainer.innerHTML = '';

                            if (!pdfDoc) return;

                            const visiblePages = pageOrder
                                .filter(page => page.visible)
                                .sort((a, b) => a.currentOrder - b.currentOrder);

                            for (let i = 0; i < visiblePages.length; i++) {
                                const page = visiblePages[i];
                                const pageNum = page.originalPage;
                                await createThumbnailElement(pageNum, i, page.orientation, page.rotation);
                            }

                            updatePageStatistics();
                        }

                        async function createThumbnailElement(pageNum, index, orientation, rotation = 0) {
                            const colDiv = document.createElement('div');
                            colDiv.className = 'col-6 col-md-4';
                            colDiv.setAttribute('data-page', pageNum);

                            const thumbnailDiv = document.createElement('div');
                            thumbnailDiv.className = 'thumbnail-item';
                            thumbnailDiv.dataset.page = pageNum;
                            thumbnailDiv.style.cssText = `
                                cursor: move;
                                border: 2px solid ${orientation === 'landscape' ? '#ffc107' : '#0d6efd'};
                                border-radius: 8px;
                                overflow: hidden;
                                background: white;
                                transition: all 0.2s ease;
                                margin-bottom: 10px;
                                height: 180px;
                                display: flex;
                                flex-direction: column;
                                position: relative;
                            `;

                            const orientationIcon = orientation === 'portrait' ? 'fa-portrait' : 'fa-landscape';
                            const orientationColor = orientation === 'portrait' ? 'primary' : 'warning';

                            thumbnailDiv.innerHTML = `
                                <div class="position-absolute top-0 end-0 p-1">
                                    <button type="button" class="btn btn-sm btn-danger remove-page-btn"
                                            data-page="${pageNum}"
                                            title="Remove this page">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <div class="position-absolute top-0 start-0 p-1">
                                    <span class="badge bg-${orientationColor}">
                                        <i class="fas ${orientationIcon}"></i>
                                    </span>
                                </div>
                                <div class="thumbnail-canvas flex-grow-1 d-flex justify-content-center align-items-center p-2">
                                    <div class="spinner-border spinner-border-sm" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                </div>
                                <div class="thumbnail-label bg-light p-2 text-center border-top">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">Page ${pageNum}</small>
                                        <div>
                                            <small class="badge bg-${orientationColor}">
                                                <i class="fas ${orientationIcon}"></i>
                                            </small>
                                            <small class="badge bg-info rotation-badge ms-1">${rotation}°</small>
                                        </div>
                                    </div>
                                    <div class="mt-1">
                                        <small class="text-primary">
                                            <i class="fas fa-sort me-1"></i>Order: ${index + 1}
                                        </small>
                                    </div>
                                </div>
                            `;

                            thumbnailContainer.appendChild(colDiv);
                            colDiv.appendChild(thumbnailDiv);

                            await loadThumbnail(pageNum, thumbnailDiv.querySelector('.thumbnail-canvas'), rotation);

                            thumbnailDiv.querySelector('.remove-page-btn').addEventListener('click', function(e) {
                                e.stopPropagation();
                                const pageToRemove = parseInt(this.getAttribute('data-page'));
                                removePage(pageToRemove);
                            });

                            thumbnailDiv.addEventListener('click', function(e) {
                                if (!e.target.closest('.remove-page-btn')) {
                                    const pageNum = parseInt(this.dataset.page);
                                    goToPage(pageNum);
                                }
                            });
                        }

                        async function loadThumbnail(pageNum, canvasContainer, rotation = 0) {
                            try {
                                const page = await pdfDoc.getPage(pageNum);
                                const viewport = page.getViewport({ scale: 0.15 });
                                const originalWidth = viewport.width;
                                const originalHeight = viewport.height;

                                const thumbnailSize = 100;

                                let scaleX = thumbnailSize / originalWidth;
                                let scaleY = thumbnailSize / originalHeight;
                                let scale = Math.min(scaleX, scaleY);

                                let canvasWidth = originalWidth * scale;
                                let canvasHeight = originalHeight * scale;

                                if (rotation === 90 || rotation === -90 || rotation === 270) {
                                    const temp = canvasWidth;
                                    canvasWidth = canvasHeight;
                                    canvasHeight = temp;
                                }

                                const padding = 10;
                                const finalWidth = canvasWidth + padding * 2;
                                const finalHeight = canvasHeight + padding * 2;

                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                canvas.width = finalWidth;
                                canvas.height = finalHeight;

                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);

                                ctx.save();
                                ctx.translate(finalWidth / 2, finalHeight / 2);
                                ctx.rotate(rotation * Math.PI / 180);
                                ctx.translate(-canvasWidth / 2, -canvasHeight / 2);

                                const renderContext = {
                                    canvasContext: ctx,
                                    viewport: page.getViewport({ scale: scale })
                                };

                                await page.render(renderContext).promise;
                                ctx.restore();

                                canvasContainer.innerHTML = '';
                                canvasContainer.appendChild(canvas);

                            } catch (error) {
                                console.error(`Error loading thumbnail for page ${pageNum}:`, error);
                                canvasContainer.innerHTML = '<div class="text-muted small">Error loading thumbnail</div>';
                            }
                        }

                        function initializeThumbnailSortable() {
                            if (thumbnailSortable) {
                                thumbnailSortable.destroy();
                            }

                            thumbnailSortable = new Sortable(thumbnailContainer, {
                                animation: 150,
                                ghostClass: 'sortable-ghost',
                                chosenClass: 'sortable-chosen',
                                dragClass: 'sortable-drag',
                                filter: '.remove-page-btn',
                                onStart: function(evt) {
                                    evt.item.style.opacity = '0.8';
                                },
                                onEnd: function(evt) {
                                    evt.item.style.opacity = '1';

                                    const items = thumbnailContainer.querySelectorAll('[data-page]');
                                    const newOrder = [];

                                    items.forEach((item, index) => {
                                        const pageNum = parseInt(item.getAttribute('data-page'));
                                        const pageData = pageOrder.find(p => p.originalPage === pageNum);
                                        if (pageData) {
                                            pageData.currentOrder = index + 1;
                                            newOrder.push(pageData);
                                        }
                                    });

                                    pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);
                                    updateThumbnailLabels();
                                    updatePageStatistics();
                                    showToast('Page order updated!');
                                }
                            });
                        }

                        function updateThumbnailLabels() {
                            const thumbnails = document.querySelectorAll('.thumbnail-item');
                            thumbnails.forEach((thumb, index) => {
                                const label = thumb.querySelector('.text-primary small');
                                if (label) {
                                    label.innerHTML = `<i class="fas fa-sort me-1"></i>Order: ${index + 1}`;
                                }
                            });
                        }

                        function removePage(pageNum) {
                            const pageIndex = pageOrder.findIndex(p => p.originalPage === pageNum);
                            if (pageIndex !== -1) {
                                pageOrder[pageIndex].visible = false;
                                pageOrder[pageIndex].currentOrder = 9999;

                                if (pageNum === pageNum) {
                                    const nextVisiblePage = pageOrder.find(p => p.visible);
                                    if (nextVisiblePage) {
                                        goToPage(nextVisiblePage.originalPage);
                                    } else {
                                        pdfPreviewContainer.innerHTML = `
                                            <div class="text-center">
                                                <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                                <h5 class="mb-2 text-white">No pages to display</h5>
                                                <p class="text-light">All pages have been removed</p>
                                            </div>
                                        `;
                                    }
                                }

                                createThumbnails();
                                updatePageStatistics();
                                showToast(`Page ${pageNum} removed from download list`);
                            }
                        }

                        function goToPage(targetPage) {
                            const pageData = pageOrder.find(p => p.originalPage === targetPage);
                            if (pageData && pageData.visible) {
                                pageNum = targetPage;
                                queueRenderPage(pageNum);
                            }
                        }

                        document.querySelectorAll('.orientation-btn').forEach(btn => {
                            btn.addEventListener('click', function() {
                                const orientation = this.dataset.orientation;
                                setCurrentPageOrientation(orientation);
                            });
                        });

                        function setCurrentPageOrientation(orientation) {
                            if (!pageNum) return;

                            currentOrientations[pageNum] = orientation;

                            const pageData = pageOrder.find(p => p.originalPage === pageNum);
                            if (pageData) {
                                pageData.orientation = orientation;
                            }

                            updateOrientationDisplay(pageNum);

                            document.querySelectorAll('.orientation-btn').forEach(btn => {
                                btn.classList.remove('active');
                                if (btn.dataset.orientation === orientation) {
                                    btn.classList.add('active');
                                }
                            });

                            queueRenderPage(pageNum);
                            updateOrientationSummary();
                            showToast(`Page ${pageNum} set to ${orientation}`);
                        }

                        applyToAllPortrait.addEventListener('click', function() {
                            if (confirm('Apply Portrait orientation to all pages?')) {
                                pageOrder.forEach(page => {
                                    if (page.visible) {
                                        page.orientation = 'portrait';
                                        currentOrientations[page.originalPage] = 'portrait';
                                    }
                                });
                                createThumbnails();
                                updateOrientationSummary();
                                queueRenderPage(pageNum);
                                showToast('Portrait orientation applied to all pages');
                            }
                        });

                        applyToAllLandscape.addEventListener('click', function() {
                            if (confirm('Apply Landscape orientation to all pages?')) {
                                pageOrder.forEach(page => {
                                    if (page.visible) {
                                        page.orientation = 'landscape';
                                        currentOrientations[page.originalPage] = 'landscape';
                                    }
                                });
                                createThumbnails();
                                updateOrientationSummary();
                                queueRenderPage(pageNum);
                                showToast('Landscape orientation applied to all pages');
                            }
                        });

                        function updateOrientationSummary() {
                            let portraitCount = 0;
                            let landscapeCount = 0;

                            pageOrder.forEach(page => {
                                if (page.visible) {
                                    if (page.orientation === 'portrait') {
                                        portraitCount++;
                                    } else {
                                        landscapeCount++;
                                    }
                                }
                            });

                            orientationSummary.textContent = `Portrait: ${portraitCount}, Landscape: ${landscapeCount}`;
                        }

                        document.querySelectorAll('.rotate-btn').forEach(btn => {
                            btn.addEventListener('click', function() {
                                if (this.id === 'resetRotation') {
                                    resetRotation();
                                } else {
                                    const rotation = parseInt(this.dataset.rotation);
                                    applyRotation(rotation);
                                }
                            });
                        });

                        function applyRotation(rotation) {
                            if (!pageNum) return;

                            if (!currentRotations[pageNum]) {
                                currentRotations[pageNum] = 0;
                            }

                            currentRotations[pageNum] = (currentRotations[pageNum] + rotation) % 360;
                            if (currentRotations[pageNum] < 0) {
                                currentRotations[pageNum] += 360;
                            }

                            const pageData = pageOrder.find(p => p.originalPage === pageNum);
                            if (pageData) {
                                pageData.rotation = currentRotations[pageNum];
                            }

                            updateRotationDisplay(pageNum);
                            queueRenderPage(pageNum);

                            updateThumbnailRotationBadge(pageNum, currentRotations[pageNum]);

                            showToast(`Page rotated to ${currentRotations[pageNum]}°`);
                        }

                        function resetRotation() {
                            if (!pageNum) return;

                            currentRotations[pageNum] = 0;
                            const pageData = pageOrder.find(p => p.originalPage === pageNum);
                            if (pageData) {
                                pageData.rotation = 0;
                            }

                            updateRotationDisplay(pageNum);
                            queueRenderPage(pageNum);
                            updateThumbnailRotationBadge(pageNum, 0);

                            showToast('Rotation reset to 0°');
                        }

                        function updateThumbnailRotationBadge(pageNum, rotation) {
                            const thumbnails = document.querySelectorAll(`[data-page="${pageNum}"] .thumbnail-item`);
                            thumbnails.forEach(thumb => {
                                const rotationElement = thumb.querySelector('.rotation-badge');
                                if (rotationElement) {
                                    rotationElement.textContent = rotation + '°';
                                }
                            });
                        }

                        prevPage.addEventListener('click', function() {
                            const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                            const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

                            if (currentIndex > 0) {
                                const prevPageNum = visiblePages[currentIndex - 1].originalPage;
                                pageNum = prevPageNum;
                                queueRenderPage(pageNum);
                            }
                        });

                        nextPage.addEventListener('click', function() {
                            const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                            const currentIndex = visiblePages.findIndex(p => p.originalPage === pageNum);

                            if (currentIndex < visiblePages.length - 1) {
                                const nextPageNum = visiblePages[currentIndex + 1].originalPage;
                                pageNum = nextPageNum;
                                queueRenderPage(pageNum);
                            }
                        });

                        quickPrevPage.addEventListener('click', function() {
                            prevPage.click();
                        });

                        quickNextPage.addEventListener('click', function() {
                            nextPage.click();
                        });

                        pageNumInput.addEventListener('change', function() {
                            const visiblePages = pageOrder.filter(p => p.visible).sort((a, b) => a.currentOrder - b.currentOrder);
                            let newIndex = parseInt(this.value) - 1;

                            if (newIndex < 0) newIndex = 0;
                            if (newIndex >= visiblePages.length) newIndex = visiblePages.length - 1;

                            if (visiblePages[newIndex]) {
                                pageNum = visiblePages[newIndex].originalPage;
                                queueRenderPage(pageNum);
                            }
                        });

                        showAllPages.addEventListener('click', function() {
                            pageOrder.forEach(page => {
                                page.visible = true;
                                page.currentOrder = page.originalPage;
                            });

                            pageOrder.sort((a, b) => a.currentOrder - b.currentOrder);

                            createThumbnails();
                            initializeThumbnailSortable();
                            showToast('All pages restored');
                        });

                        removeAllPages.addEventListener('click', function() {
                            if (confirm('Remove all pages from download list?')) {
                                pageOrder.forEach(page => {
                                    page.visible = false;
                                    page.currentOrder = 9999;
                                });

                                createThumbnails();
                                pdfPreviewContainer.innerHTML = `
                                    <div class="text-center">
                                        <i class="fas fa-file-pdf text-muted mb-3" style="font-size: 4rem;"></i>
                                        <h5 class="mb-2 text-white">All pages removed</h5>
                                        <p class="text-light">Click "Show All" to restore pages</p>
                                    </div>
                                `;
                                updatePageStatistics();
                                showToast('All pages removed from download list');
                            }
                        });

                        function updatePageStatistics() {
                            const visiblePages = pageOrder.filter(p => p.visible).length;
                            const totalPages = pageOrder.length;

                            visiblePagesCount.textContent = visiblePages;
                            visiblePagesDisplay.textContent = visiblePages;
                            pageCountBadge.textContent = visiblePages;

                            downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages} pages)`;

                            pageCountSpan.textContent = visiblePages;
                            totalPagesDisplay2.textContent = visiblePages;

                            updateOrientationSummary();
                        }






    //                     downloadFinalPdfBtn.addEventListener('click', async function() {

    //                                  await new Promise(resolve => setTimeout(resolve, 300));

    //                     if (!currentPdfUrl) {
    //                         showError('No PDF available to download.');
    //                         return;
    //                     }

    //                     const visiblePages = pageOrder
    //                         .filter(p => p.visible)
    //                         .sort((a, b) => a.currentOrder - b.currentOrder);

    //                     if (visiblePages.length === 0) {
    //                         showError('No pages selected for download.');
    //                         return;
    //                     }

    //                     downloadFinalPdfBtn.disabled = true;
    //                     downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

    //                     try {



    //                         // Download button के click handler में ये add करें (try block के शुरू में):
    // console.log('🔍 DEBUG - Current Page Order:');
    // pageOrder.forEach(p => {
    //     if (p.visible) {
    //         console.log(`   Page ${p.originalPage} → Order ${p.currentOrder} (Orientation: ${p.orientation}, Rotation: ${p.rotation}°)`);
    //     }
    // });


    //                         // Prepare page data with rotation - SIMPLIFIED
    //                         const pageOrderData = pageOrder.map(page => ({
    //                             OriginalPage: page.originalPage,
    //                             CurrentOrder: page.currentOrder,
    //                             Visible: page.visible,
    //                             Orientation: page.orientation,
    //                             Rotation: page.rotation
    //                         }));

    //                         // Prepare orientation and rotation data
    //                         const orientationData = {};
    //                         const rotationData = {};

    //                         pageOrder.forEach(page => {
    //                             if (page.visible) {
    //                                 orientationData[page.originalPage] = page.orientation;
    //                                 rotationData[page.originalPage] = page.rotation;
    //                             }
    //                         });

    //                         // Get selected sheets
    //                         const selectedSheets = getSelectedSheets();

    //                         // Send to server for processing - USE SIMPLIFIED VERSION
    //                         const response = await fetch('@Url.Action("GenerateReorderedPdf", "Home")', {
    //                             method: 'POST',
    //                             headers: {
    //                                 'Content-Type': 'application/json',
    //                                 'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
    //                             },
    //                             body: JSON.stringify({
    //                                 sessionId: sessionId,
    //                                 selectedSheets: selectedSheets,
    //                                 pageOrderData: pageOrderData,
    //                                 orientationData: orientationData,
    //                                 rotationData: rotationData,
    //                                                 // ✅ SIMPLE FIX: Add scale factor
    //                         // scaleFactor: 0.85 // 85% instead of 90%

    //                             })
    //                         });

    //                         const result = await response.json();

    //                         if (result.success) {



    //                             // और response मिलने के बाद:
    // console.log('📥 Download Response Received:', {
    //     success: result.success,
    //     fileName: result.fileName,
    //     message: result.message,
    //     dataLength: result.pdfData?.length




    // });



    //                             // Download the PDF
    //                             const link = document.createElement('a');
    //                             link.href = 'data:application/pdf;base64,' + result.pdfData;
    //                             link.download = result.fileName || 'document.pdf';
    //                             document.body.appendChild(link);
    //                             link.click();
    //                             document.body.removeChild(link);

    //                             showSuccess(`Downloaded ${visiblePages.length} pages with orientations and rotations applied`);
    //                         } else {
    //                             showError(result.message || 'Failed to generate PDF');
    //                         }
    //                     } catch (error) {
    //                         console.error('Error downloading PDF:', error);
    //                         showError('Error downloading PDF: ' + error.message);
    //                     } finally {
    //                         downloadFinalPdfBtn.disabled = false;
    //                         downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
    //                     }
    //                 });



    // ✅ NEW: Download from Preview (No re-conversion)
    document.getElementById('downloadFinalPdfBtn').addEventListener('click', async function() {
        await new Promise(resolve => setTimeout(resolve, 300));

        const visiblePages = pageOrder
            .filter(p => p.visible)
            .sort((a, b) => a.currentOrder - b.currentOrder);

        if (visiblePages.length === 0) {
            showError('No pages selected for download.');
            return;
        }

        this.disabled = true;
        this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

        try {
            // Prepare page data with current rotations and orientations
            const pageOrderData = pageOrder.map(page => ({
                OriginalPage: page.originalPage,
                CurrentOrder: page.currentOrder,
                Visible: page.visible,
                Orientation: page.orientation,
                Rotation: page.rotation
            }));

             // ✅ IMPORTANT: Show loading indicator
            Swal.fire({
                title: 'Preparing Download',
                html: '<div class="text-center"><i class="fas fa-spinner fa-spin fa-3x mb-3"></i><p>Applying your modifications...</p></div>',
                showConfirmButton: false,
                allowOutsideClick: false,
                allowEscapeKey: false
            });

            // ✅ NEW: Call DownloadFromPreview endpoint
            const response = await fetch('@Url.Action("DownloadFromPreview", "Home")', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                },
                body: JSON.stringify({
                    sessionId: '@Model.SessionId',
                    applyPageOrderData: pageOrderData
                })
            });

            // Close loading indicator
            Swal.close();

            // const result = await response.json();

            // if (result.success) {
            //     // Download the PDF directly
            //     const link = document.createElement('a');
            //     link.href = 'data:application/pdf;base64,' + result.pdfData;
            //     link.download = result.fileName || 'document.pdf';
            //     document.body.appendChild(link);
            //     link.click();
            //     document.body.removeChild(link);

            //     showSuccess(`Downloaded ${visiblePages.length} pages (from preview)`);
            // } else {
            //     showError(result.message || 'Failed to download PDF');
            // }

                     if (response.ok) {

                    // Create download link
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'document.pdf';
                    document.body.appendChild(a);
                    a.click();

                    // Cleanup
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);

                    // showSuccess(`Downloaded ${visiblePages.length} pages`);

                            showSuccess(`Downloaded ${visiblePages.length} pages with all modifications applied`);
                } else {
                    const error = await response.json();
                    showError(error.message || 'Failed to download PDF');
                }


        } catch (error) {
            console.error('Error downloading PDF:', error);
            showError('Error downloading PDF: ' + error.message);
        } finally {
            this.disabled = false;
            this.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
        }
    });




    //                 downloadFinalPdfBtn.addEventListener('click', async function() {
    //     await new Promise(resolve => setTimeout(resolve, 500));

    //     if (!pdfData) {
    //         showError('No PDF available to download.');
    //         return;
    //     }

    //     const visiblePages = pageOrder
    //         .filter(p => p.visible)
    //         .sort((a, b) => a.currentOrder - b.currentOrder);

    //     if (visiblePages.length === 0) {
    //         showError('No pages selected for download.');
    //         return;
    //     }

    //     downloadFinalPdfBtn.disabled = true;
    //     downloadFinalPdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Processing...';

    //     try {
    //         // ✅ SIMPLE: Download the PREVIEW PDF directly
    //         const link = document.createElement('a');
    //         link.href = 'data:application/pdf;base64,' + pdfData;
    //         link.download = pdfFileName || 'document.pdf';
    //         document.body.appendChild(link);
    //         link.click();
    //         document.body.removeChild(link);

    //         showSuccess(`Downloaded ${visiblePages.length} pages successfully`);

    //     } catch (error) {
    //         console.error('Error downloading PDF:', error);
    //         showError('Error downloading PDF: ' + error.message);
    //     } finally {
    //         downloadFinalPdfBtn.disabled = false;
    //         downloadFinalPdfBtn.innerHTML = `<i class="fas fa-download me-1"></i>Download (${visiblePages.length} pages)`;
    //     }
    // });


                        function showToast(message) {
                            const toast = document.createElement('div');
                            toast.className = 'toast align-items-center text-white bg-primary border-0';
                            toast.setAttribute('role', 'alert');
                            toast.innerHTML = `
                                <div class="d-flex">
                                    <div class="toast-body">
                                        <i class="fas fa-check-circle me-2"></i>
                                        ${message}
                                    </div>
                                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                                </div>
                            `;

                            const toastContainer = document.querySelector('.toast-container');
                            if (!toastContainer) {
                                const container = document.createElement('div');
                                container.className = 'toast-container position-fixed top-0 end-0 p-3';
                                document.body.appendChild(container);
                                container.appendChild(toast);
                            } else {
                                toastContainer.appendChild(toast);
                            }

                            const bsToast = new bootstrap.Toast(toast);
                            bsToast.show();

                            setTimeout(() => {
                                toast.remove();
                            }, 3000);
                        }

                        function getSelectedSheets() {
                            const selectedSheets = [];
                            document.querySelectorAll('.sheet-checkbox:checked').forEach(checkbox => {
                                selectedSheets.push(checkbox.value);
                            });
                            return selectedSheets;
                        }

                        const sortableElement = document.getElementById('sortable');
                        if (sortableElement) {
                            const sortable = new Sortable(sortableElement, {
                                handle: '.drag-handle',
                                animation: 150,
                                ghostClass: 'sortable-ghost',
                                chosenClass: 'sortable-chosen',
                                dragClass: 'sortable-drag',
                                onStart: function(evt) {
                                    evt.item.style.backgroundColor = '#e3f2fd';
                                    document.body.style.cursor = 'grabbing';
                                },
                                onEnd: function(evt) {
                                    evt.item.style.backgroundColor = '';
                                    document.body.style.cursor = '';
                                    updateOrderNumbers();
                                    updateSelectedCount();
                                }
                            });
                        }

                        selectAllCheckbox.addEventListener('change', function() {
                            const isChecked = this.checked;
                            sheetCheckboxes.forEach(checkbox => {
                                checkbox.checked = isChecked;
                            });
                            updateSelectedCount();
                        });

                        sheetCheckboxes.forEach(checkbox => {
                            checkbox.addEventListener('change', updateSelectedCount);
                        });

                        function updateOrderNumbers() {
                            const rows = document.querySelectorAll('#sortable tr');
                            rows.forEach((row, index) => {
                                const badge = row.querySelector('.order-badge');
                                if (badge) {
                                    badge.textContent = index + 1;
                                    row.setAttribute('data-order', index);
                                }
                            });
                        }

                        function updateSelectedCount() {
                            const selectedCount = document.querySelectorAll('.sheet-checkbox:checked').length;
                            selectedSheetsCount.textContent = selectedCount;
                            const totalCheckboxes = sheetCheckboxes.length;
                            selectAllCheckbox.checked = selectedCount === totalCheckboxes;
                            selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCheckboxes;
                        }

                        convertBtn.addEventListener('click', function() {
                            if (!validateBeforeConversion()) {
                                return;
                            }

                            const selectedSheets = getSelectedSheets();
                            if (selectedSheets.length === 0) {
                                alert('Please select at least one sheet to convert.');
                                return;
                            }

                            submitConversionForm(selectedSheets);
                        });

                        function submitConversionForm(selectedSheets) {
                            const btn = convertBtn;
                            btn.disabled = true;
                            btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Converting...';

                            const form = document.createElement('form');
                            form.method = 'POST';
                            form.action = '@Url.Action("ConvertToPdf")';

                            const sessionIdInput = document.createElement('input');
                            sessionIdInput.type = 'hidden';
                            sessionIdInput.name = 'sessionId';
                            sessionIdInput.value = sessionId;
                            form.appendChild(sessionIdInput);

                            selectedSheets.forEach((sheet, index) => {
                                const sheetInput = document.createElement('input');
                                sheetInput.type = 'hidden';
                                sheetInput.name = 'selectedSheets';
                                sheetInput.value = sheet;
                                form.appendChild(sheetInput);

                                const orderInput = document.createElement('input');
                                orderInput.type = 'hidden';
                                orderInput.name = 'sheetOrders';
                                orderInput.value = index;
                                form.appendChild(orderInput);
                            });

                            const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]');
                            if (antiForgeryToken) {
                                form.appendChild(antiForgeryToken.cloneNode(true));
                            }

                            document.body.appendChild(form);
                            form.submit();
                        }

                        function showError(message) {
                            Swal.fire({
                                icon: 'error',
                                title: 'Error',
                                text: message,
                                confirmButtonColor: '#dc3545'
                            });
                        }

                        function showSuccess(message) {
                            Swal.fire({
                                icon: 'success',
                                title: 'Success',
                                text: message,
                                confirmButtonColor: '#198754',
                                timer: 3000
                            });
                        }

                        updateOrderNumbers();
                        updateSelectedCount();
                    });
        </script>

        <style>
            .text-gradient {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }

            .sortable-ghost {
                opacity: 0.5;
                background: #e3f2fd;
            }

            .sortable-chosen {
                background-color: #e3f2fd !important;
            }

            .sortable-drag {
                transform: rotate(5deg);
            }

            .thumbnail-item:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            }

            .thumbnail-canvas canvas {
                max-width: 100%;
                max-height: 100%;
            }

            .page-info-label {
                position: absolute;
                top: 5px;
                padding: 2px 8px;
                border-radius: 4px;
                font-size: 12px;
                z-index: 10;
                color: white;
            }

            .orientation-label {
                right: 5px;
                background-color: #0d6efd;
            }

            .rotation-label {
                left: 5px;
                background-color: #dc3545;
            }

            .btn-primary {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border: none;
                border-radius: 8px;
            }

            .btn-success {
                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                border: none;
                border-radius: 8px;
            }

            .btn-info {
                background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
                border: none;
                border-radius: 8px;
            }

            .card {
                border-radius: 15px;
            }

            .table th {
                font-weight: 600;
                border-bottom: 2px solid #dee2e6;
            }

            .badge {
                font-size: 0.85em;
                font-weight: 500;
            }

            .drag-handle {
                cursor: grab;
            }

                .drag-handle:active {
                    cursor: grabbing;
                }

            .file-upload-area {
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                background-color: transparent !important;
            }

                .file-upload-area:hover {
                    border-color: #17a2b8;
                    background-color: rgba(23, 162, 184, 0.05);
                }

                .file-upload-area.drag-over {
                    border-color: #17a2b8 !important;
                    background-color: rgba(23, 162, 184, 0.15) !important;
                    transform: scale(1.02);
                }

            .border-dashed {
                border: 2px dashed #dee2e6;
                transition: all 0.3s ease;
            }

            .list-group-item {
                border-left: 0;
                border-right: 0;
            }

                .list-group-item:first-child {
                    border-top: 0;
                }

                .list-group-item:last-child {
                    border-bottom: 0;
                }
        </style>
}


